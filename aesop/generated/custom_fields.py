# Generated by ariadne-codegen

from typing import Any, Dict, Optional, Union

from . import (
    EntityType,
    KnowledgeCardType,
    NamespaceType,
    SearchContext,
    UserDefinedOrderType,
    UserDefinedResourceType,
)
from .base_operation import GraphQLField
from .custom_typing_fields import (
    AcknowledgeChangeRequestGraphQLField,
    ActivityDependencyGraphQLField,
    ActivityFeedConnectionGraphQLField,
    ActivityFeedEdgeGraphQLField,
    AggregationBucketGraphQLField,
    AggregationMetadataGraphQLField,
    AISearchQueryGraphQLField,
    AnchorEntityLabelGraphQLField,
    ApiKeyBaseGraphQLField,
    ApiKeyDeletionPayloadGraphQLField,
    ApiKeyGraphQLField,
    ApiKeyInputGraphQLField,
    AspectGraphQLField,
    AssetConnectionGraphQLField,
    AssetContactsGraphQLField,
    AssetDescriptionKnowledgeCardGraphQLField,
    AssetDescriptionTokenizedContentGraphQLField,
    AssetDocumentAggregationBucketGraphQLField,
    AssetEdgeGraphQLField,
    AssetFollowersGraphQLField,
    AssetGraphQLField,
    AssetLikesGraphQLField,
    AssetSearchDocumentGraphQLField,
    AssetSearchHighlightGraphQLField,
    AssetSearchResultGraphQLField,
    AssetStructureGraphQLField,
    AthenaQueryResultGraphQLField,
    AthenaResultRowGraphQLField,
    AuditStampGraphQLField,
    AuthorizationGraphQLField,
    AutoGeneratedDocumentGraphQLField,
    AzureAdSSOGraphQLField,
    AzureDataFactoryActivityGraphQLField,
    AzureDataFactoryPipelineGraphQLField,
    BrowsePathGraphQLField,
    BrowsePathSegmentGraphQLField,
    ChangeRequestKnowledgeCardGraphQLField,
    ChangeRequestTokenizedContentGraphQLField,
    ChartGraphQLField,
    ChartQueryGraphQLField,
    ColumnDescriptionKnowledgeCardGraphQLField,
    CommentGraphQLField,
    CommentTokenizedContentGraphQLField,
    CommonColumnAttributesBaseGraphQLField,
    CommonColumnAttributesGraphQLField,
    CommonColumnDescriptionExclusionBaseGraphQLField,
    CommonColumnDescriptionExclusionGraphQLField,
    CrawlerGraphQLField,
    CrawlerMetadataBaseGraphQLField,
    CrawlerRunMetadataConnectionGraphQLField,
    CrawlerRunMetadataEdgeGraphQLField,
    CrawlerRunMetadataGraphQLField,
    CrawlerRunStatusGraphQLField,
    CrawlerScheduleGraphQLField,
    CrawlerTypeResponseGraphQLField,
    CustomDirectorySearchResultGraphQLField,
    CustomMetadataConfigGraphQLField,
    CustomMetadataGraphQLField,
    CustomMetadataItemGraphQLField,
    CustomSortableNamedAssetCollectionGraphQLField,
    CustomSortableSavedLiveQueryGraphQLField,
    CustomTagAttributesGraphQLField,
    DashboardConnectionGraphQLField,
    DashboardEdgeGraphQLField,
    DashboardGraphQLField,
    DashboardHighlightGraphQLField,
    DashboardInfoGraphQLField,
    DashboardLogicalIdGraphQLField,
    DashboardSearchDocumentGraphQLField,
    DashboardSearchInfoGraphQLField,
    DashboardSearchResultGraphQLField,
    DataDocumentGraphQLField,
    DataDocumentSearchResultGraphQLField,
    DataDocumentTokenizedContentGraphQLField,
    DataGroupSearchResultGraphQLField,
    DataMonitorGraphQLField,
    DataMonitorTargetGraphQLField,
    DataQualityStatusSourceGraphQLField,
    DatasetColumnsGraphQLField,
    DatasetConnectionGraphQLField,
    DatasetDataQualityGraphQLField,
    DatasetDocumentationGraphQLField,
    DatasetEdgeGraphQLField,
    DatasetFieldAssociationsGraphQLField,
    DatasetFieldStatisticsGraphQLField,
    DatasetGraphQLField,
    DatasetHighlightGraphQLField,
    DatasetLogicalIdGraphQLField,
    DatasetPatternGraphQLField,
    DatasetSchemaGraphQLField,
    DatasetSearchDocumentGraphQLField,
    DatasetSearchInfoGraphQLField,
    DatasetSearchResultGraphQLField,
    DatasetStatisticsGraphQLField,
    DatasetStructureGraphQLField,
    DatasetUsageGraphQLField,
    DbtMacroArgumentGraphQLField,
    DbtMacroGraphQLField,
    DbtMaterializationGraphQLField,
    DbtMetadataItemGraphQLField,
    DbtMetricGraphQLField,
    DbtModelGraphQLField,
    DbtModelSearchResultGraphQLField,
    DbtTestGraphQLField,
    DeleteCrawlersResponseGraphQLField,
    DeleteWebhookResponseGraphQLField,
    DeprecationKnowledgeCardGraphQLField,
    DeprecationTokenizedContentGraphQLField,
    DerivedAssetDescriptionsGraphQLField,
    DesignatedContactGraphQLField,
    EntityConnectionGraphQLField,
    EntityCountGraphQLField,
    EntityEdgeGraphQLField,
    EntityGraphQLField,
    EntityLineageConnectionGraphQLField,
    EntityLineageEdgeGraphQLField,
    EntityUpstreamGraphQLField,
    FieldDocumentationGraphQLField,
    FieldMappingGraphQLField,
    FieldPathPermissionGraphQLField,
    FieldQueryCountGraphQLField,
    FieldQueryCountsGraphQLField,
    FieldStatisticsGraphQLField,
    FieldTagAssociationsGraphQLField,
    FiveTranConnectorStatusGraphQLField,
    FivetranPipelineGraphQLField,
    FollowOrUnfollowOutputGraphQLField,
    ForeignKeyGraphQLField,
    GeneratedAssetDescriptionGraphQLField,
    GeneratedFieldDescriptionGraphQLField,
    GoogleSocialLoginGraphQLField,
    GoogleWorkspaceSSOGraphQLField,
    GovernedEntityGraphQLField,
    GroupBaseGraphQLField,
    GroupConnectionGraphQLField,
    GroupDescriptionGraphQLField,
    GroupEdgeGraphQLField,
    GroupGraphQLField,
    GroupInfoBaseGraphQLField,
    GroupInfoGraphQLField,
    GroupLogicalIdGraphQLField,
    HashtagGraphQLField,
    HierarchyConnectionGraphQLField,
    HierarchyEdgeGraphQLField,
    HierarchyGraphQLField,
    HierarchyInfoGraphQLField,
    HierarchyLogicalIdGraphQLField,
    HowToUseTokenizedContentGraphQLField,
    IncidentKnowledgeCardGraphQLField,
    IncidentTokenizedContentGraphQLField,
    InformaticaMappingGraphQLField,
    IntegrationsGraphQLField,
    InterestedPartyGraphQLField,
    KeyValuePairGraphQLField,
    KnowledgeCardBaseGraphQLField,
    KnowledgeCardConnectionGraphQLField,
    KnowledgeCardDeletePayloadGraphQLField,
    KnowledgeCardDetailGraphQLField,
    KnowledgeCardEdgeGraphQLField,
    KnowledgeCardGraphQLField,
    KnowledgeCardHighlightGraphQLField,
    KnowledgeCardInfoBaseGraphQLField,
    KnowledgeCardInfoGraphQLField,
    KnowledgeCardInfoOutputGraphQLField,
    KnowledgeCardLogicalIdGraphQLField,
    KnowledgeCardSearchDocumentGraphQLField,
    KnowledgeCardSearchResultGraphQLField,
    LDAPGraphQLField,
    LDAPGroupSearchGraphQLField,
    LDAPUserSearchGraphQLField,
    LinkedInSocialLoginGraphQLField,
    LogicalIdUnion,
    LookerExploreFilterGraphQLField,
    LookerExploreGraphQLField,
    LookerExploreJoinGraphQLField,
    LookerExploreSearchResultGraphQLField,
    LookerViewDimensionGraphQLField,
    LookerViewFilterGraphQLField,
    LookerViewGraphQLField,
    LookerViewMeasureGraphQLField,
    LookerViewQueryGraphQLField,
    LookerViewSearchResultGraphQLField,
    MetabaseCollectionGraphQLField,
    MetricBaseGraphQLField,
    MetricConnectionGraphQLField,
    MetricEdgeGraphQLField,
    MetricFilterGraphQLField,
    MetricGraphQLField,
    MetricInfoBaseGraphQLField,
    MetricInfoGraphQLField,
    MetricLogicalIdGraphQLField,
    MetricSearchInfoGraphQLField,
    MetricSearchResultGraphQLField,
    MicrosoftSocialLoginGraphQLField,
    NamespaceAssetsGraphQLField,
    NamespaceBaseGraphQLField,
    NamespaceConnectionGraphQLField,
    NamespaceDeletePayloadGraphQLField,
    NamespaceDescriptionGraphQLField,
    NamespaceEdgeGraphQLField,
    NamespaceGraphQLField,
    NamespaceHighlightGraphQLField,
    NamespaceInfoBaseGraphQLField,
    NamespaceInfoGraphQLField,
    NamespaceLogicalIdGraphQLField,
    NamespaceSearchDocumentGraphQLField,
    NamespaceSearchResultGraphQLField,
    NamespaceSummaryGraphQLField,
    NamespaceTypeDetailBaseGraphQLField,
    NamespaceTypeDetailGraphQLField,
    NodeGraphQLField,
    NonProdGraphQLField,
    OktaSSOGraphQLField,
    OnboardingEmailGraphQLField,
    OnboardingExperienceGraphQLField,
    OrderedEntryGraphQLField,
    OrganizationGraphQLField,
    OverallDataQualityGraphQLField,
    PageInfoGraphQLField,
    PersonActivityGraphQLField,
    PersonalizationOptionsBaseGraphQLField,
    PersonalizationOptionsGraphQLField,
    PersonalizationTraitGraphQLField,
    PersonConnectionGraphQLField,
    PersonDetailsInterfaceGraphQLField,
    PersonEdgeGraphQLField,
    PersonGraphQLField,
    PersonHighlightGraphQLField,
    PersonLogicalIdGraphQLField,
    PersonOrganizationGraphQLField,
    PersonPinsGraphQLField,
    PersonPinsPinningOutputGraphQLField,
    PersonPropertiesGraphQLField,
    PersonSearchDocumentGraphQLField,
    PersonSearchResultGraphQLField,
    PersonSlackProfileGraphQLField,
    PipelineGraphQLField,
    PipelineHighlightGraphQLField,
    PipelineInfoGraphQLField,
    PipelineLogicalIdGraphQLField,
    PipelineMappingGraphQLField,
    PipelineSearchDocumentGraphQLField,
    PipelineSearchInfoGraphQLField,
    PipelineSearchResultGraphQLField,
    PowerBiAppGraphQLField,
    PowerBIColumnGraphQLField,
    PowerBIDataflowGraphQLField,
    PowerBIDatasetGraphQLField,
    PowerBIDatasetParameterGraphQLField,
    PowerBIDatasetSearchResultGraphQLField,
    PowerBIDatasetTableGraphQLField,
    PowerBiEndorsementGraphQLField,
    PowerBiInfoGraphQLField,
    PowerBIMeasureGraphQLField,
    PowerBIRefreshScheduleGraphQLField,
    PowerBiSensitivityLabelGraphQLField,
    PowerBiSubscriptionGraphQLField,
    PowerBiSubscriptionUserGraphQLField,
    PowerBiUserGraphQLField,
    PowerBiWorkspaceGraphQLField,
    PowerBiWorkspaceUserGraphQLField,
    QueryCountGraphQLField,
    QueryCountPercentileGraphQLField,
    QueryCountsGraphQLField,
    QueryExplainerGraphQLField,
    QueryExplainerTokenizedContentGraphQLField,
    QueryInfoConnectionGraphQLField,
    QueryInfoEdgeGraphQLField,
    QueryInfoGraphQLField,
    QueryKnowledgeCardGraphQLField,
    QueryResultGraphQLField,
    RecentUserActivitiesGraphQLField,
    ResultRowGraphQLField,
    RunCrawlerResponseGraphQLField,
    SampleSearchQuestionGraphQLField,
    SavedLiveQueryGraphQLField,
    SchemaFieldGraphQLField,
    SchemaFieldWithCommonAttributesGraphQLField,
    SearchQueryGraphQLField,
    SearchScoreDetailsGraphQLField,
    SearchStatisticsResultGraphQLField,
    SettingsGraphQLField,
    SnowflakeStreamInfoGraphQLField,
    SocialLoginGraphQLField,
    SoftDeletionGraphQLField,
    SourceFieldGraphQLField,
    SourceInfoGraphQLField,
    SparkJobGraphQLField,
    SQLExplainerResultGraphQLField,
    SqlSchemaGraphQLField,
    SSOGraphQLField,
    StatusGraphQLField,
    SuggestItemGraphQLField,
    SuggestResultGraphQLField,
    SystemContactGraphQLField,
    SystemContactsGraphQLField,
    SystemDescriptionGraphQLField,
    SystemTagCountsConnectionGraphQLField,
    SystemTagCountsEdgeGraphQLField,
    SystemTagCountsGraphQLField,
    SystemTagGraphQLField,
    SystemTagsGraphQLField,
    SystemTagSourcesGraphQLField,
    TableauDatasourceGraphQLField,
    TableauDatasourceSearchResultGraphQLField,
    TableauFieldGraphQLField,
    TableColumnsUsageGraphQLField,
    TableJoinGraphQLField,
    TableJoinScenarioGraphQLField,
    TableJoinsGraphQLField,
    TenantInfoGraphQLField,
    ThoughtSpotColumnGraphQLField,
    ThoughtSpotDataObjectGraphQLField,
    ThoughtSpotDataObjectSearchResultGraphQLField,
    ThoughtSpotInfoGraphQLField,
    UnityCatalogGraphQLField,
    UnityCatalogTableInfoGraphQLField,
    UnityCatalogVolumeInfoGraphQLField,
    UniversalSearchResultGraphQLField,
    UpdateCrawlerScheduleGraphQLField,
    UsageKnowledgeCardGraphQLField,
    UserActivityActorInfoGraphQLField,
    UserActivityGraphQLField,
    UserDefinedResourceBaseGraphQLField,
    UserDefinedResourceConnectionGraphQLField,
    UserDefinedResourceDeletePayloadGraphQLField,
    UserDefinedResourceDescriptionGraphQLField,
    UserDefinedResourceEdgeGraphQLField,
    UserDefinedResourceGraphQLField,
    UserDefinedResourceHighlightGraphQLField,
    UserDefinedResourceInfoBaseGraphQLField,
    UserDefinedResourceInfoGraphQLField,
    UserDefinedResourceLogicalIdGraphQLField,
    UserDefinedResourceSearchDocumentGraphQLField,
    UserDefinedResourceSearchResultGraphQLField,
    UserQueryCountGraphQLField,
    UserQueryCountsGraphQLField,
    UserSpecifiedOrderingGraphQLField,
    VersionHistoryConnectionGraphQLField,
    VersionHistoryEdgeGraphQLField,
    VersionHistoryGraphQLField,
    ViewActivityConnectionGraphQLField,
    ViewActivityEdgeGraphQLField,
    ViewedByConnectionGraphQLField,
    ViewedByEdgeGraphQLField,
    ViewerPermissionsGraphQLField,
    VirtualViewConnectionGraphQLField,
    VirtualViewEdgeGraphQLField,
    VirtualViewGraphQLField,
    VirtualViewHighlightGraphQLField,
    VirtualViewLogicalIdGraphQLField,
    VirtualViewSearchDocumentGraphQLField,
    VirtualViewSearchInfoGraphQLField,
    VirtualViewSearchResultGraphQLField,
    VolumeFileGraphQLField,
    WebhookGraphQLField,
)
from .input_types import (
    AssetConnectionFilterInput,
    AssetsConnectionFilterInput,
    AssociatedAssetConnectionFilterInput,
    BaseConnectionFilter,
    ConnectionOrderBy,
    DatasetRelationInput,
    DbtDownstreamLineageInput,
    DbtModelRelationInput,
    DbtUpstreamLineageInput,
    GovernedTagFilterInput,
    KnowledgeCardConnectionFilterInput,
    LineageFilterInput,
    NamespaceInfoConnectionFilterInput,
    PersonConnectionFilterInput,
    PinsConnectionFilterInput,
    QueryInfoConnectionFilterInput,
    RecentUserActivitiesFilterInput,
    ResourceInfoConnectionFilterInput,
    TableauDatasourceDownstreamLineageInput,
    TableauDatasourceUpstreamLineageInput,
    ThoughtSpotDataObjectDownstreamLineageInput,
    ThoughtSpotDataObjectUpstreamLineageInput,
)


class AISearchQueryFields(GraphQLField):
    query: "AISearchQueryGraphQLField" = AISearchQueryGraphQLField("query")

    def fields(self, *subfields: AISearchQueryGraphQLField) -> "AISearchQueryFields":
        """Subfields should come from the AISearchQueryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AISearchQueryFields":
        self._alias = alias
        return self


class AcknowledgeChangeRequestFields(GraphQLField):
    @classmethod
    def acknowledged_by(cls) -> "AuditStampFields":
        return AuditStampFields("acknowledged_by")

    entity_id: "AcknowledgeChangeRequestGraphQLField" = (
        AcknowledgeChangeRequestGraphQLField("entityId")
    )
    message: "AcknowledgeChangeRequestGraphQLField" = (
        AcknowledgeChangeRequestGraphQLField("message")
    )

    def fields(
        self,
        *subfields: Union[AcknowledgeChangeRequestGraphQLField, "AuditStampFields"]
    ) -> "AcknowledgeChangeRequestFields":
        """Subfields should come from the AcknowledgeChangeRequestFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AcknowledgeChangeRequestFields":
        self._alias = alias
        return self


class ActivityDependencyFields(GraphQLField):
    dependency_conditions: "ActivityDependencyGraphQLField" = (
        ActivityDependencyGraphQLField("dependencyConditions")
    )
    name: "ActivityDependencyGraphQLField" = ActivityDependencyGraphQLField("name")

    def fields(
        self, *subfields: ActivityDependencyGraphQLField
    ) -> "ActivityDependencyFields":
        """Subfields should come from the ActivityDependencyFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ActivityDependencyFields":
        self._alias = alias
        return self


class ActivityFeedConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "ActivityFeedEdgeFields":
        return ActivityFeedEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "ActivityFeedConnectionGraphQLField" = (
        ActivityFeedConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            ActivityFeedConnectionGraphQLField,
            "ActivityFeedEdgeFields",
            "PageInfoFields",
        ]
    ) -> "ActivityFeedConnectionFields":
        """Subfields should come from the ActivityFeedConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ActivityFeedConnectionFields":
        self._alias = alias
        return self


class ActivityFeedEdgeFields(GraphQLField):
    action: "ActivityFeedEdgeGraphQLField" = ActivityFeedEdgeGraphQLField("action")
    cursor: "ActivityFeedEdgeGraphQLField" = ActivityFeedEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "EntityInterface":
        return EntityInterface("node")

    def fields(
        self, *subfields: Union[ActivityFeedEdgeGraphQLField, "EntityInterface"]
    ) -> "ActivityFeedEdgeFields":
        """Subfields should come from the ActivityFeedEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ActivityFeedEdgeFields":
        self._alias = alias
        return self


class AggregationBucketFields(GraphQLField):
    count: "AggregationBucketGraphQLField" = AggregationBucketGraphQLField("count")
    display_name: "AggregationBucketGraphQLField" = AggregationBucketGraphQLField(
        "displayName"
    )
    key: "AggregationBucketGraphQLField" = AggregationBucketGraphQLField("key")

    def fields(
        self, *subfields: AggregationBucketGraphQLField
    ) -> "AggregationBucketFields":
        """Subfields should come from the AggregationBucketFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AggregationBucketFields":
        self._alias = alias
        return self


class AggregationMetadataFields(GraphQLField):
    @classmethod
    def buckets(cls) -> "AggregationBucketFields":
        return AggregationBucketFields("buckets")

    display_name: "AggregationMetadataGraphQLField" = AggregationMetadataGraphQLField(
        "displayName"
    )
    is_custom_metadata: "AggregationMetadataGraphQLField" = (
        AggregationMetadataGraphQLField("isCustomMetadata")
    )
    name: "AggregationMetadataGraphQLField" = AggregationMetadataGraphQLField("name")

    def fields(
        self,
        *subfields: Union[AggregationMetadataGraphQLField, "AggregationBucketFields"]
    ) -> "AggregationMetadataFields":
        """Subfields should come from the AggregationMetadataFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AggregationMetadataFields":
        self._alias = alias
        return self


class AnchorEntityLabelFields(GraphQLField):
    count: "AnchorEntityLabelGraphQLField" = AnchorEntityLabelGraphQLField("count")
    value: "AnchorEntityLabelGraphQLField" = AnchorEntityLabelGraphQLField("value")

    def fields(
        self, *subfields: AnchorEntityLabelGraphQLField
    ) -> "AnchorEntityLabelFields":
        """Subfields should come from the AnchorEntityLabelFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AnchorEntityLabelFields":
        self._alias = alias
        return self


class ApiKeyFields(GraphQLField):
    description: "ApiKeyGraphQLField" = ApiKeyGraphQLField("description")
    enabled: "ApiKeyGraphQLField" = ApiKeyGraphQLField("enabled")
    id: "ApiKeyGraphQLField" = ApiKeyGraphQLField("id")
    name: "ApiKeyGraphQLField" = ApiKeyGraphQLField("name")
    value: "ApiKeyGraphQLField" = ApiKeyGraphQLField("value")

    def fields(self, *subfields: ApiKeyGraphQLField) -> "ApiKeyFields":
        """Subfields should come from the ApiKeyFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ApiKeyFields":
        self._alias = alias
        return self


class ApiKeyBaseInterface(GraphQLField):
    description: "ApiKeyBaseGraphQLField" = ApiKeyBaseGraphQLField("description")
    enabled: "ApiKeyBaseGraphQLField" = ApiKeyBaseGraphQLField("enabled")

    def fields(self, *subfields: ApiKeyBaseGraphQLField) -> "ApiKeyBaseInterface":
        """Subfields should come from the ApiKeyBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ApiKeyBaseInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "ApiKeyBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class ApiKeyDeletionPayloadFields(GraphQLField):
    deleted_ids: "ApiKeyDeletionPayloadGraphQLField" = (
        ApiKeyDeletionPayloadGraphQLField("deletedIds")
    )
    failed_ids: "ApiKeyDeletionPayloadGraphQLField" = ApiKeyDeletionPayloadGraphQLField(
        "failedIds"
    )

    def fields(
        self, *subfields: ApiKeyDeletionPayloadGraphQLField
    ) -> "ApiKeyDeletionPayloadFields":
        """Subfields should come from the ApiKeyDeletionPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ApiKeyDeletionPayloadFields":
        self._alias = alias
        return self


class ApiKeyInputInterface(GraphQLField):
    description: "ApiKeyInputGraphQLField" = ApiKeyInputGraphQLField("description")
    enabled: "ApiKeyInputGraphQLField" = ApiKeyInputGraphQLField("enabled")
    name: "ApiKeyInputGraphQLField" = ApiKeyInputGraphQLField("name")

    def fields(self, *subfields: ApiKeyInputGraphQLField) -> "ApiKeyInputInterface":
        """Subfields should come from the ApiKeyInputInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ApiKeyInputInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "ApiKeyInputInterface":
        self._inline_fragments[type_name] = subfields
        return self


class AspectInterface(GraphQLField):
    created_at: "AspectGraphQLField" = AspectGraphQLField("createdAt")
    entity_id: "AspectGraphQLField" = AspectGraphQLField("entityId")

    def fields(self, *subfields: AspectGraphQLField) -> "AspectInterface":
        """Subfields should come from the AspectInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AspectInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "AspectInterface":
        self._inline_fragments[type_name] = subfields
        return self


class AssetInterface(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "AssetGraphQLField" = AssetGraphQLField("createdAt")
    deleted_at: "AssetGraphQLField" = AssetGraphQLField("deletedAt")
    display_name: "AssetGraphQLField" = AssetGraphQLField("displayName")
    entity_type: "AssetGraphQLField" = AssetGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def force_shown(cls) -> "AuditStampFields":
        return AuditStampFields("force_shown")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "AssetGraphQLField" = AssetGraphQLField("id")
    is_complete: "AssetGraphQLField" = AssetGraphQLField("isComplete")
    is_deleted: "AssetGraphQLField" = AssetGraphQLField("isDeleted")
    is_production: "AssetGraphQLField" = AssetGraphQLField("isProduction")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    last_ingested_at: "AssetGraphQLField" = AssetGraphQLField("lastIngestedAt")
    last_modified_at: "AssetGraphQLField" = AssetGraphQLField("lastModifiedAt")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def system_contacts(cls) -> "SystemContactsFields":
        return SystemContactsFields("system_contacts")

    @classmethod
    def system_description(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("system_description")

    system_tag_values: "AssetGraphQLField" = AssetGraphQLField("systemTagValues")

    @classmethod
    def system_tags(cls) -> "SystemTagsFields":
        return SystemTagsFields("system_tags")

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            AssetGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "AuditStampFields",
            "BrowsePathFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "SystemContactsFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
        ]
    ) -> "AssetInterface":
        """Subfields should come from the AssetInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "AssetInterface":
        self._inline_fragments[type_name] = subfields
        return self


class AssetConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "AssetEdgeFields":
        return AssetEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "AssetConnectionGraphQLField" = AssetConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            AssetConnectionGraphQLField, "AssetEdgeFields", "PageInfoFields"
        ]
    ) -> "AssetConnectionFields":
        """Subfields should come from the AssetConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetConnectionFields":
        self._alias = alias
        return self


class AssetContactsFields(GraphQLField):
    @classmethod
    def contacts(cls) -> "DesignatedContactFields":
        return DesignatedContactFields("contacts")

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "AssetContactsGraphQLField" = AssetContactsGraphQLField("createdAt")
    entity_id: "AssetContactsGraphQLField" = AssetContactsGraphQLField("entityId")

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    def fields(
        self,
        *subfields: Union[
            AssetContactsGraphQLField, "AuditStampFields", "DesignatedContactFields"
        ]
    ) -> "AssetContactsFields":
        """Subfields should come from the AssetContactsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetContactsFields":
        self._alias = alias
        return self


class AssetDescriptionKnowledgeCardFields(GraphQLField):
    description: "AssetDescriptionKnowledgeCardGraphQLField" = (
        AssetDescriptionKnowledgeCardGraphQLField("description")
    )
    title: "AssetDescriptionKnowledgeCardGraphQLField" = (
        AssetDescriptionKnowledgeCardGraphQLField("title")
    )

    @classmethod
    def tokenized_content(cls) -> "AssetDescriptionTokenizedContentFields":
        return AssetDescriptionTokenizedContentFields("tokenized_content")

    def fields(
        self,
        *subfields: Union[
            AssetDescriptionKnowledgeCardGraphQLField,
            "AssetDescriptionTokenizedContentFields",
        ]
    ) -> "AssetDescriptionKnowledgeCardFields":
        """Subfields should come from the AssetDescriptionKnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetDescriptionKnowledgeCardFields":
        self._alias = alias
        return self


class AssetDescriptionTokenizedContentFields(GraphQLField):
    description: "AssetDescriptionTokenizedContentGraphQLField" = (
        AssetDescriptionTokenizedContentGraphQLField("description")
    )

    def fields(
        self, *subfields: AssetDescriptionTokenizedContentGraphQLField
    ) -> "AssetDescriptionTokenizedContentFields":
        """Subfields should come from the AssetDescriptionTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetDescriptionTokenizedContentFields":
        self._alias = alias
        return self


class AssetDocumentAggregationBucketFields(GraphQLField):
    count: "AssetDocumentAggregationBucketGraphQLField" = (
        AssetDocumentAggregationBucketGraphQLField("count")
    )
    entity_type: "AssetDocumentAggregationBucketGraphQLField" = (
        AssetDocumentAggregationBucketGraphQLField("entityType")
    )
    sub_type: "AssetDocumentAggregationBucketGraphQLField" = (
        AssetDocumentAggregationBucketGraphQLField("subType")
    )

    def fields(
        self, *subfields: AssetDocumentAggregationBucketGraphQLField
    ) -> "AssetDocumentAggregationBucketFields":
        """Subfields should come from the AssetDocumentAggregationBucketFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetDocumentAggregationBucketFields":
        self._alias = alias
        return self


class AssetEdgeFields(GraphQLField):
    cursor: "AssetEdgeGraphQLField" = AssetEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "AssetInterface":
        return AssetInterface("node")

    def fields(
        self, *subfields: Union[AssetEdgeGraphQLField, "AssetInterface"]
    ) -> "AssetEdgeFields":
        """Subfields should come from the AssetEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetEdgeFields":
        self._alias = alias
        return self


class AssetFollowersFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "AssetFollowersGraphQLField" = AssetFollowersGraphQLField("createdAt")
    entity_id: "AssetFollowersGraphQLField" = AssetFollowersGraphQLField("entityId")

    @classmethod
    def followers(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("followers", arguments=cleared_arguments)

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    number_of_followers: "AssetFollowersGraphQLField" = AssetFollowersGraphQLField(
        "numberOfFollowers"
    )
    viewer_does_follow: "AssetFollowersGraphQLField" = AssetFollowersGraphQLField(
        "viewerDoesFollow"
    )

    def fields(
        self,
        *subfields: Union[
            AssetFollowersGraphQLField, "AuditStampFields", "PersonConnectionFields"
        ]
    ) -> "AssetFollowersFields":
        """Subfields should come from the AssetFollowersFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetFollowersFields":
        self._alias = alias
        return self


class AssetLikesFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "AssetLikesGraphQLField" = AssetLikesGraphQLField("createdAt")
    entity_id: "AssetLikesGraphQLField" = AssetLikesGraphQLField("entityId")

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    like_count: "AssetLikesGraphQLField" = AssetLikesGraphQLField("likeCount")

    @classmethod
    def liked_by(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("liked_by", arguments=cleared_arguments)

    viewer_does_like: "AssetLikesGraphQLField" = AssetLikesGraphQLField(
        "viewerDoesLike"
    )

    def fields(
        self,
        *subfields: Union[
            AssetLikesGraphQLField, "AuditStampFields", "PersonConnectionFields"
        ]
    ) -> "AssetLikesFields":
        """Subfields should come from the AssetLikesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetLikesFields":
        self._alias = alias
        return self


class AssetSearchDocumentFields(GraphQLField):
    browse_path_hierarchy: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browse_path_segments: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    column_descriptions: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("columnDescriptions")
    )
    column_names: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "columnNames"
    )
    column_tags: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "columnTags"
    )
    contact_display_names: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("contactDisplayNames")
    )
    created: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "created"
    )

    @classmethod
    def dashboard(cls) -> "DashboardSearchInfoFields":
        return DashboardSearchInfoFields("dashboard")

    @classmethod
    def dataset(cls) -> "DatasetSearchInfoFields":
        return DatasetSearchInfoFields("dataset")

    description: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "description"
    )
    document_id: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "documentId"
    )
    domain_display_names: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("domainDisplayNames")
    )
    domains: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "domains"
    )
    embedded_string_1: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("embeddedString_1")
    )
    embedded_string_2: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("embeddedString_2")
    )
    entity_id: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "entityId"
    )
    entity_type: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "entityType"
    )
    governed_tags: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "governedTags"
    )
    has_column_lineage: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("hasColumnLineage")
    )
    has_table_lineage: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("hasTableLineage")
    )
    hashtags: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "hashtags"
    )
    hierarchies: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "hierarchies"
    )

    @classmethod
    def highlight(cls) -> "AssetSearchHighlightFields":
        return AssetSearchHighlightFields("highlight")

    is_complete: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "isComplete"
    )
    is_deleted: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "isDeleted"
    )
    is_production: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "isProduction"
    )
    knowledge_card_count: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("knowledgeCardCount")
    )
    last_queried: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "lastQueried"
    )
    last_refreshed: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "lastRefreshed"
    )
    last_updated: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "lastUpdated"
    )

    @classmethod
    def metric(cls) -> "MetricSearchInfoFields":
        return MetricSearchInfoFields("metric")

    model: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField("model")
    name: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField("name")
    overall_data_quality: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("overallDataQuality")
    )
    pagination_token: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("paginationToken")
    )

    @classmethod
    def pipeline(cls) -> "PipelineSearchInfoFields":
        return PipelineSearchInfoFields("pipeline")

    platform: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "platform"
    )
    project: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "project"
    )

    @classmethod
    def score_details(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("score_details")

    sub_type: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "subType"
    )
    view_count: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "viewCount"
    )

    @classmethod
    def virtual_view(cls) -> "VirtualViewSearchInfoFields":
        return VirtualViewSearchInfoFields("virtual_view")

    workspace: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "workspace"
    )

    def fields(
        self,
        *subfields: Union[
            AssetSearchDocumentGraphQLField,
            "AssetSearchHighlightFields",
            "BrowsePathFields",
            "DashboardSearchInfoFields",
            "DatasetSearchInfoFields",
            "MetricSearchInfoFields",
            "PipelineSearchInfoFields",
            "SearchScoreDetailsFields",
            "VirtualViewSearchInfoFields",
        ]
    ) -> "AssetSearchDocumentFields":
        """Subfields should come from the AssetSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetSearchDocumentFields":
        self._alias = alias
        return self


class AssetSearchHighlightFields(GraphQLField):
    chart_descriptions: "AssetSearchHighlightGraphQLField" = (
        AssetSearchHighlightGraphQLField("chartDescriptions")
    )
    charts: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField(
        "charts"
    )
    column_descriptions: "AssetSearchHighlightGraphQLField" = (
        AssetSearchHighlightGraphQLField("columnDescriptions")
    )
    column_names: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField(
        "columnNames"
    )
    column_tags: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField(
        "columnTags"
    )
    contact_display_names: "AssetSearchHighlightGraphQLField" = (
        AssetSearchHighlightGraphQLField("contactDisplayNames")
    )
    dashboard_id: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField(
        "dashboardId"
    )
    description: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField(
        "description"
    )
    governed_tags: "AssetSearchHighlightGraphQLField" = (
        AssetSearchHighlightGraphQLField("governedTags")
    )
    hashtags: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField(
        "hashtags"
    )
    name: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField("name")
    pipeline_id: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField(
        "pipelineId"
    )

    def fields(
        self, *subfields: AssetSearchHighlightGraphQLField
    ) -> "AssetSearchHighlightFields":
        """Subfields should come from the AssetSearchHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetSearchHighlightFields":
        self._alias = alias
        return self


class AssetSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "AssetSearchDocumentFields":
        return AssetSearchDocumentFields("documents")

    error_message: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField(
        "errorMessage"
    )
    from_: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField("from")
    has_more: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField("hasMore")

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField(
        "paginationToken"
    )
    search_context: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField(
        "searchContext"
    )
    search_index: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField(
        "searchIndex"
    )
    size: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField("size")
    total_count: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            AssetSearchResultGraphQLField,
            "AggregationMetadataFields",
            "AssetSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "AssetSearchResultFields":
        """Subfields should come from the AssetSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetSearchResultFields":
        self._alias = alias
        return self


class AssetStructureFields(GraphQLField):
    created_at: "AssetStructureGraphQLField" = AssetStructureGraphQLField("createdAt")
    directories: "AssetStructureGraphQLField" = AssetStructureGraphQLField(
        "directories"
    )
    entity_id: "AssetStructureGraphQLField" = AssetStructureGraphQLField("entityId")
    name: "AssetStructureGraphQLField" = AssetStructureGraphQLField("name")

    def fields(self, *subfields: AssetStructureGraphQLField) -> "AssetStructureFields":
        """Subfields should come from the AssetStructureFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetStructureFields":
        self._alias = alias
        return self


class AthenaQueryResultFields(GraphQLField):
    columns: "AthenaQueryResultGraphQLField" = AthenaQueryResultGraphQLField("columns")
    next_token: "AthenaQueryResultGraphQLField" = AthenaQueryResultGraphQLField(
        "nextToken"
    )

    @classmethod
    def rows(cls) -> "AthenaResultRowFields":
        return AthenaResultRowFields("rows")

    def fields(
        self, *subfields: Union[AthenaQueryResultGraphQLField, "AthenaResultRowFields"]
    ) -> "AthenaQueryResultFields":
        """Subfields should come from the AthenaQueryResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AthenaQueryResultFields":
        self._alias = alias
        return self


class AthenaResultRowFields(GraphQLField):
    values: "AthenaResultRowGraphQLField" = AthenaResultRowGraphQLField("values")

    def fields(
        self, *subfields: AthenaResultRowGraphQLField
    ) -> "AthenaResultRowFields":
        """Subfields should come from the AthenaResultRowFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AthenaResultRowFields":
        self._alias = alias
        return self


class AuditStampFields(GraphQLField):
    @classmethod
    def acting_person(cls) -> "PersonFields":
        return PersonFields("acting_person")

    actor: "AuditStampGraphQLField" = AuditStampGraphQLField("actor")
    time: "AuditStampGraphQLField" = AuditStampGraphQLField("time")

    def fields(
        self, *subfields: Union[AuditStampGraphQLField, "PersonFields"]
    ) -> "AuditStampFields":
        """Subfields should come from the AuditStampFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AuditStampFields":
        self._alias = alias
        return self


class AuthorizationFields(GraphQLField):
    new_user_default_role: "AuthorizationGraphQLField" = AuthorizationGraphQLField(
        "newUserDefaultRole"
    )

    def fields(self, *subfields: AuthorizationGraphQLField) -> "AuthorizationFields":
        """Subfields should come from the AuthorizationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AuthorizationFields":
        self._alias = alias
        return self


class AutoGeneratedDocumentFields(GraphQLField):
    generated_content: "AutoGeneratedDocumentGraphQLField" = (
        AutoGeneratedDocumentGraphQLField("generatedContent")
    )
    path: "AutoGeneratedDocumentGraphQLField" = AutoGeneratedDocumentGraphQLField(
        "path"
    )
    title: "AutoGeneratedDocumentGraphQLField" = AutoGeneratedDocumentGraphQLField(
        "title"
    )

    def fields(
        self, *subfields: AutoGeneratedDocumentGraphQLField
    ) -> "AutoGeneratedDocumentFields":
        """Subfields should come from the AutoGeneratedDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AutoGeneratedDocumentFields":
        self._alias = alias
        return self


class AzureAdSSOFields(GraphQLField):
    metadata_url: "AzureAdSSOGraphQLField" = AzureAdSSOGraphQLField("metadataUrl")

    def fields(self, *subfields: AzureAdSSOGraphQLField) -> "AzureAdSSOFields":
        """Subfields should come from the AzureAdSSOFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AzureAdSSOFields":
        self._alias = alias
        return self


class AzureDataFactoryActivityFields(GraphQLField):
    @classmethod
    def depends_on(cls) -> "ActivityDependencyFields":
        return ActivityDependencyFields("depends_on")

    name: "AzureDataFactoryActivityGraphQLField" = AzureDataFactoryActivityGraphQLField(
        "name"
    )
    type: "AzureDataFactoryActivityGraphQLField" = AzureDataFactoryActivityGraphQLField(
        "type"
    )

    def fields(
        self,
        *subfields: Union[
            AzureDataFactoryActivityGraphQLField, "ActivityDependencyFields"
        ]
    ) -> "AzureDataFactoryActivityFields":
        """Subfields should come from the AzureDataFactoryActivityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AzureDataFactoryActivityFields":
        self._alias = alias
        return self


class AzureDataFactoryPipelineFields(GraphQLField):
    @classmethod
    def activities(cls) -> "AzureDataFactoryActivityFields":
        return AzureDataFactoryActivityFields("activities")

    created_at: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("createdAt")
    )
    entity_id: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("entityId")
    )
    factory: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("factory")
    )
    last_duration_in_ms: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("lastDurationInMs")
    )
    last_invoke_type: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("lastInvokeType")
    )
    last_publish_time: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("lastPublishTime")
    )
    last_run_end: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("lastRunEnd")
    )
    last_run_message: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("lastRunMessage")
    )
    last_run_start: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("lastRunStart")
    )
    last_run_status: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("lastRunStatus")
    )
    pipeline_name: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("pipelineName")
    )
    pipeline_url: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("pipelineUrl")
    )
    sinks: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("sinks")
    )
    sources: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("sources")
    )

    def fields(
        self,
        *subfields: Union[
            AzureDataFactoryPipelineGraphQLField, "AzureDataFactoryActivityFields"
        ]
    ) -> "AzureDataFactoryPipelineFields":
        """Subfields should come from the AzureDataFactoryPipelineFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AzureDataFactoryPipelineFields":
        self._alias = alias
        return self


class BrowsePathFields(GraphQLField):
    index: "BrowsePathGraphQLField" = BrowsePathGraphQLField("index")

    @classmethod
    def segments(cls) -> "BrowsePathSegmentFields":
        return BrowsePathSegmentFields("segments")

    def fields(
        self, *subfields: Union[BrowsePathGraphQLField, "BrowsePathSegmentFields"]
    ) -> "BrowsePathFields":
        """Subfields should come from the BrowsePathFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "BrowsePathFields":
        self._alias = alias
        return self


class BrowsePathSegmentFields(GraphQLField):
    count: "BrowsePathSegmentGraphQLField" = BrowsePathSegmentGraphQLField("count")
    display_name: "BrowsePathSegmentGraphQLField" = BrowsePathSegmentGraphQLField(
        "displayName"
    )
    native_type: "BrowsePathSegmentGraphQLField" = BrowsePathSegmentGraphQLField(
        "nativeType"
    )
    segment_id: "BrowsePathSegmentGraphQLField" = BrowsePathSegmentGraphQLField(
        "segmentId"
    )
    text: "BrowsePathSegmentGraphQLField" = BrowsePathSegmentGraphQLField("text")
    type: "BrowsePathSegmentGraphQLField" = BrowsePathSegmentGraphQLField("type")

    def fields(
        self, *subfields: BrowsePathSegmentGraphQLField
    ) -> "BrowsePathSegmentFields":
        """Subfields should come from the BrowsePathSegmentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "BrowsePathSegmentFields":
        self._alias = alias
        return self


class ChangeRequestKnowledgeCardFields(GraphQLField):
    @classmethod
    def acknowledged(cls) -> "AcknowledgeChangeRequestFields":
        return AcknowledgeChangeRequestFields("acknowledged")

    message: "ChangeRequestKnowledgeCardGraphQLField" = (
        ChangeRequestKnowledgeCardGraphQLField("message")
    )

    @classmethod
    def recipient(cls) -> "PersonFields":
        return PersonFields("recipient")

    recipient_id: "ChangeRequestKnowledgeCardGraphQLField" = (
        ChangeRequestKnowledgeCardGraphQLField("recipientId")
    )
    request_type: "ChangeRequestKnowledgeCardGraphQLField" = (
        ChangeRequestKnowledgeCardGraphQLField("requestType")
    )

    @classmethod
    def status(cls) -> "StatusFields":
        return StatusFields("status")

    title: "ChangeRequestKnowledgeCardGraphQLField" = (
        ChangeRequestKnowledgeCardGraphQLField("title")
    )

    @classmethod
    def tokenized_content(cls) -> "ChangeRequestTokenizedContentFields":
        return ChangeRequestTokenizedContentFields("tokenized_content")

    def fields(
        self,
        *subfields: Union[
            ChangeRequestKnowledgeCardGraphQLField,
            "AcknowledgeChangeRequestFields",
            "ChangeRequestTokenizedContentFields",
            "PersonFields",
            "StatusFields",
        ]
    ) -> "ChangeRequestKnowledgeCardFields":
        """Subfields should come from the ChangeRequestKnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ChangeRequestKnowledgeCardFields":
        self._alias = alias
        return self


class ChangeRequestTokenizedContentFields(GraphQLField):
    message: "ChangeRequestTokenizedContentGraphQLField" = (
        ChangeRequestTokenizedContentGraphQLField("message")
    )

    def fields(
        self, *subfields: ChangeRequestTokenizedContentGraphQLField
    ) -> "ChangeRequestTokenizedContentFields":
        """Subfields should come from the ChangeRequestTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ChangeRequestTokenizedContentFields":
        self._alias = alias
        return self


class ChartFields(GraphQLField):
    chart_type: "ChartGraphQLField" = ChartGraphQLField("chartType")
    description: "ChartGraphQLField" = ChartGraphQLField("description")
    id: "ChartGraphQLField" = ChartGraphQLField("id")
    preview: "ChartGraphQLField" = ChartGraphQLField("preview")

    @classmethod
    def query(cls) -> "ChartQueryFields":
        return ChartQueryFields("query")

    title: "ChartGraphQLField" = ChartGraphQLField("title")
    url: "ChartGraphQLField" = ChartGraphQLField("url")

    def fields(
        self, *subfields: Union[ChartGraphQLField, "ChartQueryFields"]
    ) -> "ChartFields":
        """Subfields should come from the ChartFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ChartFields":
        self._alias = alias
        return self


class ChartQueryFields(GraphQLField):
    account: "ChartQueryGraphQLField" = ChartQueryGraphQLField("account")
    default_database: "ChartQueryGraphQLField" = ChartQueryGraphQLField(
        "defaultDatabase"
    )
    default_schema: "ChartQueryGraphQLField" = ChartQueryGraphQLField("defaultSchema")
    platform: "ChartQueryGraphQLField" = ChartQueryGraphQLField("platform")
    query: "ChartQueryGraphQLField" = ChartQueryGraphQLField("query")

    def fields(self, *subfields: ChartQueryGraphQLField) -> "ChartQueryFields":
        """Subfields should come from the ChartQueryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ChartQueryFields":
        self._alias = alias
        return self


class ColumnDescriptionKnowledgeCardFields(GraphQLField):
    description: "ColumnDescriptionKnowledgeCardGraphQLField" = (
        ColumnDescriptionKnowledgeCardGraphQLField("description")
    )
    field_path: "ColumnDescriptionKnowledgeCardGraphQLField" = (
        ColumnDescriptionKnowledgeCardGraphQLField("fieldPath")
    )
    field_path_namespace: "ColumnDescriptionKnowledgeCardGraphQLField" = (
        ColumnDescriptionKnowledgeCardGraphQLField("fieldPathNamespace")
    )
    title: "ColumnDescriptionKnowledgeCardGraphQLField" = (
        ColumnDescriptionKnowledgeCardGraphQLField("title")
    )

    def fields(
        self, *subfields: ColumnDescriptionKnowledgeCardGraphQLField
    ) -> "ColumnDescriptionKnowledgeCardFields":
        """Subfields should come from the ColumnDescriptionKnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ColumnDescriptionKnowledgeCardFields":
        self._alias = alias
        return self


class CommentFields(GraphQLField):
    comment: "CommentGraphQLField" = CommentGraphQLField("comment")
    parent_comment_id: "CommentGraphQLField" = CommentGraphQLField("parentCommentId")

    @classmethod
    def replies(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("replies", arguments=cleared_arguments)

    title: "CommentGraphQLField" = CommentGraphQLField("title")

    @classmethod
    def tokenized_content(cls) -> "CommentTokenizedContentFields":
        return CommentTokenizedContentFields("tokenized_content")

    def fields(
        self,
        *subfields: Union[
            CommentGraphQLField,
            "CommentTokenizedContentFields",
            "KnowledgeCardConnectionFields",
        ]
    ) -> "CommentFields":
        """Subfields should come from the CommentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CommentFields":
        self._alias = alias
        return self


class CommentTokenizedContentFields(GraphQLField):
    comment: "CommentTokenizedContentGraphQLField" = (
        CommentTokenizedContentGraphQLField("comment")
    )

    def fields(
        self, *subfields: CommentTokenizedContentGraphQLField
    ) -> "CommentTokenizedContentFields":
        """Subfields should come from the CommentTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CommentTokenizedContentFields":
        self._alias = alias
        return self


class CommonColumnAttributesFields(GraphQLField):
    @classmethod
    def asset_contacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("asset_contacts")

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "CommonColumnAttributesGraphQLField" = (
        CommonColumnAttributesGraphQLField("createdAt")
    )

    @classmethod
    def description(cls) -> "UserDefinedResourceDescriptionFields":
        return UserDefinedResourceDescriptionFields("description")

    entity_id: "CommonColumnAttributesGraphQLField" = (
        CommonColumnAttributesGraphQLField("entityId")
    )

    @classmethod
    def exclusion(cls) -> "DatasetColumnsFields":
        return DatasetColumnsFields("exclusion")

    @classmethod
    def governed_tags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governed_tags", arguments=cleared_arguments
        )

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    def fields(
        self,
        *subfields: Union[
            CommonColumnAttributesGraphQLField,
            "AssetContactsFields",
            "AuditStampFields",
            "DatasetColumnsFields",
            "UserDefinedResourceConnectionFields",
            "UserDefinedResourceDescriptionFields",
        ]
    ) -> "CommonColumnAttributesFields":
        """Subfields should come from the CommonColumnAttributesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CommonColumnAttributesFields":
        self._alias = alias
        return self


class CommonColumnAttributesBaseInterface(GraphQLField):
    created_at: "CommonColumnAttributesBaseGraphQLField" = (
        CommonColumnAttributesBaseGraphQLField("createdAt")
    )

    @classmethod
    def description(cls) -> "UserDefinedResourceDescriptionFields":
        return UserDefinedResourceDescriptionFields("description")

    entity_id: "CommonColumnAttributesBaseGraphQLField" = (
        CommonColumnAttributesBaseGraphQLField("entityId")
    )

    @classmethod
    def exclusion(cls) -> "DatasetColumnsFields":
        return DatasetColumnsFields("exclusion")

    def fields(
        self,
        *subfields: Union[
            CommonColumnAttributesBaseGraphQLField,
            "DatasetColumnsFields",
            "UserDefinedResourceDescriptionFields",
        ]
    ) -> "CommonColumnAttributesBaseInterface":
        """Subfields should come from the CommonColumnAttributesBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CommonColumnAttributesBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "CommonColumnAttributesBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class CommonColumnDescriptionExclusionFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "CommonColumnDescriptionExclusionGraphQLField" = (
        CommonColumnDescriptionExclusionGraphQLField("createdAt")
    )
    entity_id: "CommonColumnDescriptionExclusionGraphQLField" = (
        CommonColumnDescriptionExclusionGraphQLField("entityId")
    )

    @classmethod
    def exclusion(cls) -> "DatasetColumnsFields":
        return DatasetColumnsFields("exclusion")

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    def fields(
        self,
        *subfields: Union[
            CommonColumnDescriptionExclusionGraphQLField,
            "AuditStampFields",
            "DatasetColumnsFields",
        ]
    ) -> "CommonColumnDescriptionExclusionFields":
        """Subfields should come from the CommonColumnDescriptionExclusionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CommonColumnDescriptionExclusionFields":
        self._alias = alias
        return self


class CommonColumnDescriptionExclusionBaseInterface(GraphQLField):
    created_at: "CommonColumnDescriptionExclusionBaseGraphQLField" = (
        CommonColumnDescriptionExclusionBaseGraphQLField("createdAt")
    )
    entity_id: "CommonColumnDescriptionExclusionBaseGraphQLField" = (
        CommonColumnDescriptionExclusionBaseGraphQLField("entityId")
    )

    @classmethod
    def exclusion(cls) -> "DatasetColumnsFields":
        return DatasetColumnsFields("exclusion")

    def fields(
        self,
        *subfields: Union[
            CommonColumnDescriptionExclusionBaseGraphQLField, "DatasetColumnsFields"
        ]
    ) -> "CommonColumnDescriptionExclusionBaseInterface":
        """Subfields should come from the CommonColumnDescriptionExclusionBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CommonColumnDescriptionExclusionBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "CommonColumnDescriptionExclusionBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class CrawlerFields(GraphQLField):
    contacts: "CrawlerGraphQLField" = CrawlerGraphQLField("contacts")
    crawler_config: "CrawlerGraphQLField" = CrawlerGraphQLField("crawlerConfig")
    display_name: "CrawlerGraphQLField" = CrawlerGraphQLField("displayName")
    id: "CrawlerGraphQLField" = CrawlerGraphQLField("id")
    is_metaphor_managed: "CrawlerGraphQLField" = CrawlerGraphQLField(
        "isMetaphorManaged"
    )
    platform: "CrawlerGraphQLField" = CrawlerGraphQLField("platform")

    @classmethod
    def run_history(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "CrawlerRunMetadataConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return CrawlerRunMetadataConnectionFields(
            "run_history", arguments=cleared_arguments
        )

    @classmethod
    def run_metadata(cls) -> "CrawlerRunMetadataFields":
        return CrawlerRunMetadataFields("run_metadata")

    @classmethod
    def schedule(cls) -> "CrawlerScheduleFields":
        return CrawlerScheduleFields("schedule")

    @classmethod
    def status(cls) -> "CrawlerRunStatusFields":
        return CrawlerRunStatusFields("status")

    def fields(
        self,
        *subfields: Union[
            CrawlerGraphQLField,
            "CrawlerRunMetadataConnectionFields",
            "CrawlerRunMetadataFields",
            "CrawlerRunStatusFields",
            "CrawlerScheduleFields",
        ]
    ) -> "CrawlerFields":
        """Subfields should come from the CrawlerFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerFields":
        self._alias = alias
        return self


class CrawlerMetadataBaseInterface(GraphQLField):
    id: "CrawlerMetadataBaseGraphQLField" = CrawlerMetadataBaseGraphQLField("id")
    is_metaphor_managed: "CrawlerMetadataBaseGraphQLField" = (
        CrawlerMetadataBaseGraphQLField("isMetaphorManaged")
    )

    def fields(
        self, *subfields: CrawlerMetadataBaseGraphQLField
    ) -> "CrawlerMetadataBaseInterface":
        """Subfields should come from the CrawlerMetadataBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerMetadataBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "CrawlerMetadataBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class CrawlerRunMetadataFields(GraphQLField):
    crawler_name: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "crawlerName"
    )
    description: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "description"
    )
    end_time: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "endTime"
    )
    entity_count: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "entityCount"
    )
    error_message: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "errorMessage"
    )
    log_file: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "logFile"
    )
    log_file_signed_url: "CrawlerRunMetadataGraphQLField" = (
        CrawlerRunMetadataGraphQLField("logFileSignedUrl")
    )
    platform: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "platform"
    )
    stack_trace: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "stackTrace"
    )
    start_time: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "startTime"
    )
    status: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField("status")

    def fields(
        self, *subfields: CrawlerRunMetadataGraphQLField
    ) -> "CrawlerRunMetadataFields":
        """Subfields should come from the CrawlerRunMetadataFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerRunMetadataFields":
        self._alias = alias
        return self


class CrawlerRunMetadataConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "CrawlerRunMetadataEdgeFields":
        return CrawlerRunMetadataEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "CrawlerRunMetadataConnectionGraphQLField" = (
        CrawlerRunMetadataConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            CrawlerRunMetadataConnectionGraphQLField,
            "CrawlerRunMetadataEdgeFields",
            "PageInfoFields",
        ]
    ) -> "CrawlerRunMetadataConnectionFields":
        """Subfields should come from the CrawlerRunMetadataConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerRunMetadataConnectionFields":
        self._alias = alias
        return self


class CrawlerRunMetadataEdgeFields(GraphQLField):
    cursor: "CrawlerRunMetadataEdgeGraphQLField" = CrawlerRunMetadataEdgeGraphQLField(
        "cursor"
    )

    @classmethod
    def node(cls) -> "CrawlerRunMetadataFields":
        return CrawlerRunMetadataFields("node")

    def fields(
        self,
        *subfields: Union[
            CrawlerRunMetadataEdgeGraphQLField, "CrawlerRunMetadataFields"
        ]
    ) -> "CrawlerRunMetadataEdgeFields":
        """Subfields should come from the CrawlerRunMetadataEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerRunMetadataEdgeFields":
        self._alias = alias
        return self


class CrawlerRunStatusFields(GraphQLField):
    estimated_completion_time: "CrawlerRunStatusGraphQLField" = (
        CrawlerRunStatusGraphQLField("estimatedCompletionTime")
    )
    last_status: "CrawlerRunStatusGraphQLField" = CrawlerRunStatusGraphQLField(
        "lastStatus"
    )
    start_time: "CrawlerRunStatusGraphQLField" = CrawlerRunStatusGraphQLField(
        "startTime"
    )

    def fields(
        self, *subfields: CrawlerRunStatusGraphQLField
    ) -> "CrawlerRunStatusFields":
        """Subfields should come from the CrawlerRunStatusFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerRunStatusFields":
        self._alias = alias
        return self


class CrawlerScheduleFields(GraphQLField):
    description: "CrawlerScheduleGraphQLField" = CrawlerScheduleGraphQLField(
        "description"
    )
    enabled: "CrawlerScheduleGraphQLField" = CrawlerScheduleGraphQLField("enabled")
    is_daily: "CrawlerScheduleGraphQLField" = CrawlerScheduleGraphQLField("isDaily")
    schedule: "CrawlerScheduleGraphQLField" = CrawlerScheduleGraphQLField("schedule")
    type: "CrawlerScheduleGraphQLField" = CrawlerScheduleGraphQLField("type")

    def fields(
        self, *subfields: CrawlerScheduleGraphQLField
    ) -> "CrawlerScheduleFields":
        """Subfields should come from the CrawlerScheduleFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerScheduleFields":
        self._alias = alias
        return self


class CrawlerTypeResponseFields(GraphQLField):
    platform: "CrawlerTypeResponseGraphQLField" = CrawlerTypeResponseGraphQLField(
        "platform"
    )
    type: "CrawlerTypeResponseGraphQLField" = CrawlerTypeResponseGraphQLField("type")

    def fields(
        self, *subfields: CrawlerTypeResponseGraphQLField
    ) -> "CrawlerTypeResponseFields":
        """Subfields should come from the CrawlerTypeResponseFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerTypeResponseFields":
        self._alias = alias
        return self


class CustomDirectorySearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "NamespaceSearchDocumentFields":
        return NamespaceSearchDocumentFields("documents")

    error_message: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("errorMessage")
    )
    from_: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("from")
    )
    has_more: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("paginationToken")
    )
    search_context: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("searchContext")
    )
    search_index: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("searchIndex")
    )
    size: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("size")
    )
    total_count: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            CustomDirectorySearchResultGraphQLField,
            "AggregationMetadataFields",
            "NamespaceSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "CustomDirectorySearchResultFields":
        """Subfields should come from the CustomDirectorySearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CustomDirectorySearchResultFields":
        self._alias = alias
        return self


class CustomMetadataFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "CustomMetadataGraphQLField" = CustomMetadataGraphQLField("createdAt")
    entity_id: "CustomMetadataGraphQLField" = CustomMetadataGraphQLField("entityId")

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    @classmethod
    def metadata(cls) -> "CustomMetadataItemFields":
        return CustomMetadataItemFields("metadata")

    def fields(
        self,
        *subfields: Union[
            CustomMetadataGraphQLField, "AuditStampFields", "CustomMetadataItemFields"
        ]
    ) -> "CustomMetadataFields":
        """Subfields should come from the CustomMetadataFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CustomMetadataFields":
        self._alias = alias
        return self


class CustomMetadataConfigFields(GraphQLField):
    data_type: "CustomMetadataConfigGraphQLField" = CustomMetadataConfigGraphQLField(
        "dataType"
    )
    display_name: "CustomMetadataConfigGraphQLField" = CustomMetadataConfigGraphQLField(
        "displayName"
    )
    highlight: "CustomMetadataConfigGraphQLField" = CustomMetadataConfigGraphQLField(
        "highlight"
    )
    key: "CustomMetadataConfigGraphQLField" = CustomMetadataConfigGraphQLField("key")
    searchable: "CustomMetadataConfigGraphQLField" = CustomMetadataConfigGraphQLField(
        "searchable"
    )

    def fields(
        self, *subfields: CustomMetadataConfigGraphQLField
    ) -> "CustomMetadataConfigFields":
        """Subfields should come from the CustomMetadataConfigFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CustomMetadataConfigFields":
        self._alias = alias
        return self


class CustomMetadataItemFields(GraphQLField):
    key: "CustomMetadataItemGraphQLField" = CustomMetadataItemGraphQLField("key")
    value: "CustomMetadataItemGraphQLField" = CustomMetadataItemGraphQLField("value")

    def fields(
        self, *subfields: CustomMetadataItemGraphQLField
    ) -> "CustomMetadataItemFields":
        """Subfields should come from the CustomMetadataItemFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CustomMetadataItemFields":
        self._alias = alias
        return self


class CustomSortableNamedAssetCollectionFields(GraphQLField):
    asset_ids: "CustomSortableNamedAssetCollectionGraphQLField" = (
        CustomSortableNamedAssetCollectionGraphQLField("assetIds")
    )

    @classmethod
    def assets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("assets", arguments=cleared_arguments)

    @classmethod
    def custom_asset_ordering(
        cls, *, type: Optional[UserDefinedOrderType] = None
    ) -> "OrderedEntryFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "UserDefinedOrderType", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return OrderedEntryFields("custom_asset_ordering", arguments=cleared_arguments)

    id: "CustomSortableNamedAssetCollectionGraphQLField" = (
        CustomSortableNamedAssetCollectionGraphQLField("id")
    )
    name: "CustomSortableNamedAssetCollectionGraphQLField" = (
        CustomSortableNamedAssetCollectionGraphQLField("name")
    )
    position: "CustomSortableNamedAssetCollectionGraphQLField" = (
        CustomSortableNamedAssetCollectionGraphQLField("position")
    )

    def fields(
        self,
        *subfields: Union[
            CustomSortableNamedAssetCollectionGraphQLField,
            "EntityConnectionFields",
            "OrderedEntryFields",
        ]
    ) -> "CustomSortableNamedAssetCollectionFields":
        """Subfields should come from the CustomSortableNamedAssetCollectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CustomSortableNamedAssetCollectionFields":
        self._alias = alias
        return self


class CustomSortableSavedLiveQueryFields(GraphQLField):
    context: "CustomSortableSavedLiveQueryGraphQLField" = (
        CustomSortableSavedLiveQueryGraphQLField("context")
    )

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    facets_json: "CustomSortableSavedLiveQueryGraphQLField" = (
        CustomSortableSavedLiveQueryGraphQLField("facetsJSON")
    )
    id: "CustomSortableSavedLiveQueryGraphQLField" = (
        CustomSortableSavedLiveQueryGraphQLField("id")
    )
    keyword: "CustomSortableSavedLiveQueryGraphQLField" = (
        CustomSortableSavedLiveQueryGraphQLField("keyword")
    )

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    name: "CustomSortableSavedLiveQueryGraphQLField" = (
        CustomSortableSavedLiveQueryGraphQLField("name")
    )
    position: "CustomSortableSavedLiveQueryGraphQLField" = (
        CustomSortableSavedLiveQueryGraphQLField("position")
    )

    def fields(
        self,
        *subfields: Union[CustomSortableSavedLiveQueryGraphQLField, "AuditStampFields"]
    ) -> "CustomSortableSavedLiveQueryFields":
        """Subfields should come from the CustomSortableSavedLiveQueryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CustomSortableSavedLiveQueryFields":
        self._alias = alias
        return self


class CustomTagAttributesFields(GraphQLField):
    color: "CustomTagAttributesGraphQLField" = CustomTagAttributesGraphQLField("color")
    icon_key: "CustomTagAttributesGraphQLField" = CustomTagAttributesGraphQLField(
        "iconKey"
    )

    def fields(
        self, *subfields: CustomTagAttributesGraphQLField
    ) -> "CustomTagAttributesFields":
        """Subfields should come from the CustomTagAttributesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CustomTagAttributesFields":
        self._alias = alias
        return self


class DashboardFields(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def asset_contacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("asset_contacts")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "DashboardGraphQLField" = DashboardGraphQLField("createdAt")

    @classmethod
    def dashboard_info(cls) -> "DashboardInfoFields":
        return DashboardInfoFields("dashboard_info")

    deleted_at: "DashboardGraphQLField" = DashboardGraphQLField("deletedAt")

    @classmethod
    def descriptions(cls) -> "DerivedAssetDescriptionsFields":
        return DerivedAssetDescriptionsFields("descriptions")

    display_name: "DashboardGraphQLField" = DashboardGraphQLField("displayName")

    @classmethod
    def downstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineage_for: Optional[LineageFilterInput] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineage_for},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstream_of_type", arguments=cleared_arguments
        )

    entity_type: "DashboardGraphQLField" = DashboardGraphQLField("entityType")

    @classmethod
    def entity_upstream(cls) -> "EntityUpstreamFields":
        return EntityUpstreamFields("entity_upstream")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def force_shown(cls) -> "AuditStampFields":
        return AuditStampFields("force_shown")

    @classmethod
    def governed_tags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governed_tags", arguments=cleared_arguments
        )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "DashboardGraphQLField" = DashboardGraphQLField("id")

    @classmethod
    def interested_parties(cls) -> "InterestedPartyFields":
        return InterestedPartyFields("interested_parties")

    is_complete: "DashboardGraphQLField" = DashboardGraphQLField("isComplete")
    is_deleted: "DashboardGraphQLField" = DashboardGraphQLField("isDeleted")
    is_production: "DashboardGraphQLField" = DashboardGraphQLField("isProduction")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledge_cards(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledge_cards", arguments=cleared_arguments
        )

    @classmethod
    def labels(cls) -> "AnchorEntityLabelFields":
        return AnchorEntityLabelFields("labels")

    last_ingested_at: "DashboardGraphQLField" = DashboardGraphQLField("lastIngestedAt")
    last_modified_at: "DashboardGraphQLField" = DashboardGraphQLField("lastModifiedAt")

    @classmethod
    def logical_id(cls) -> "DashboardLogicalIdFields":
        return DashboardLogicalIdFields("logical_id")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def overall_data_quality(cls) -> "OverallDataQualityFields":
        return OverallDataQualityFields("overall_data_quality")

    @classmethod
    def recent_user_activities(
        cls, *, input: Optional[RecentUserActivitiesFilterInput] = None
    ) -> "RecentUserActivitiesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "RecentUserActivitiesFilterInput", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return RecentUserActivitiesFields(
            "recent_user_activities", arguments=cleared_arguments
        )

    @classmethod
    def recently_viewed_by(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "ViewedByConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewedByConnectionFields(
            "recently_viewed_by", arguments=cleared_arguments
        )

    @classmethod
    def related_metrics(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("related_metrics", arguments=cleared_arguments)

    @classmethod
    def source_info(cls) -> "SourceInfoFields":
        return SourceInfoFields("source_info")

    @classmethod
    def structure(cls) -> "AssetStructureFields":
        return AssetStructureFields("structure")

    @classmethod
    def system_contacts(cls) -> "SystemContactsFields":
        return SystemContactsFields("system_contacts")

    @classmethod
    def system_description(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("system_description")

    system_tag_values: "DashboardGraphQLField" = DashboardGraphQLField(
        "systemTagValues"
    )

    @classmethod
    def system_tags(cls) -> "SystemTagsFields":
        return SystemTagsFields("system_tags")

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    @classmethod
    def top_knowledge_card_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(
            "top_knowledge_card_authors", arguments=cleared_arguments
        )

    @classmethod
    def upstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineage_for: Optional[LineageFilterInput] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineage_for},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstream_of_type", arguments=cleared_arguments
        )

    viewer_can_assign_asset_contacts: "DashboardGraphQLField" = DashboardGraphQLField(
        "viewerCanAssignAssetContacts"
    )
    viewer_has_pinned: "DashboardGraphQLField" = DashboardGraphQLField(
        "viewerHasPinned"
    )

    def fields(
        self,
        *subfields: Union[
            DashboardGraphQLField,
            "AggregationMetadataFields",
            "AnchorEntityLabelFields",
            "AssetContactsFields",
            "AssetFollowersFields",
            "AssetStructureFields",
            "AuditStampFields",
            "BrowsePathFields",
            "DashboardInfoFields",
            "DashboardLogicalIdFields",
            "DerivedAssetDescriptionsFields",
            "EntityConnectionFields",
            "EntityLineageConnectionFields",
            "EntityUpstreamFields",
            "HashtagFields",
            "InterestedPartyFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "OverallDataQualityFields",
            "PersonConnectionFields",
            "RecentUserActivitiesFields",
            "SourceInfoFields",
            "SystemContactsFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
            "UserDefinedResourceConnectionFields",
            "ViewedByConnectionFields",
        ]
    ) -> "DashboardFields":
        """Subfields should come from the DashboardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardFields":
        self._alias = alias
        return self


class DashboardConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "DashboardEdgeFields":
        return DashboardEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "DashboardConnectionGraphQLField" = DashboardConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            DashboardConnectionGraphQLField, "DashboardEdgeFields", "PageInfoFields"
        ]
    ) -> "DashboardConnectionFields":
        """Subfields should come from the DashboardConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardConnectionFields":
        self._alias = alias
        return self


class DashboardEdgeFields(GraphQLField):
    cursor: "DashboardEdgeGraphQLField" = DashboardEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "DashboardFields":
        return DashboardFields("node")

    def fields(
        self, *subfields: Union[DashboardEdgeGraphQLField, "DashboardFields"]
    ) -> "DashboardEdgeFields":
        """Subfields should come from the DashboardEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardEdgeFields":
        self._alias = alias
        return self


class DashboardHighlightFields(GraphQLField):
    chart_descriptions: "DashboardHighlightGraphQLField" = (
        DashboardHighlightGraphQLField("chartDescriptions")
    )
    charts: "DashboardHighlightGraphQLField" = DashboardHighlightGraphQLField("charts")
    contact_display_names: "DashboardHighlightGraphQLField" = (
        DashboardHighlightGraphQLField("contactDisplayNames")
    )
    dashboard_id: "DashboardHighlightGraphQLField" = DashboardHighlightGraphQLField(
        "dashboardId"
    )
    description: "DashboardHighlightGraphQLField" = DashboardHighlightGraphQLField(
        "description"
    )
    governed_tags: "DashboardHighlightGraphQLField" = DashboardHighlightGraphQLField(
        "governedTags"
    )
    hashtags: "DashboardHighlightGraphQLField" = DashboardHighlightGraphQLField(
        "hashtags"
    )
    name: "DashboardHighlightGraphQLField" = DashboardHighlightGraphQLField("name")

    def fields(
        self, *subfields: DashboardHighlightGraphQLField
    ) -> "DashboardHighlightFields":
        """Subfields should come from the DashboardHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardHighlightFields":
        self._alias = alias
        return self


class DashboardInfoFields(GraphQLField):
    @classmethod
    def charts(cls) -> "ChartFields":
        return ChartFields("charts")

    created_at: "DashboardInfoGraphQLField" = DashboardInfoGraphQLField("createdAt")
    dashboard_type: "DashboardInfoGraphQLField" = DashboardInfoGraphQLField(
        "dashboardType"
    )
    description: "DashboardInfoGraphQLField" = DashboardInfoGraphQLField("description")
    entity_id: "DashboardInfoGraphQLField" = DashboardInfoGraphQLField("entityId")

    @classmethod
    def power_bi(cls) -> "PowerBiInfoFields":
        return PowerBiInfoFields("power_bi")

    @classmethod
    def thought_spot(cls) -> "ThoughtSpotInfoFields":
        return ThoughtSpotInfoFields("thought_spot")

    title: "DashboardInfoGraphQLField" = DashboardInfoGraphQLField("title")
    view_count: "DashboardInfoGraphQLField" = DashboardInfoGraphQLField("viewCount")

    def fields(
        self,
        *subfields: Union[
            DashboardInfoGraphQLField,
            "ChartFields",
            "PowerBiInfoFields",
            "ThoughtSpotInfoFields",
        ]
    ) -> "DashboardInfoFields":
        """Subfields should come from the DashboardInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardInfoFields":
        self._alias = alias
        return self


class DashboardLogicalIdFields(GraphQLField):
    dashboard_id: "DashboardLogicalIdGraphQLField" = DashboardLogicalIdGraphQLField(
        "dashboardId"
    )
    platform: "DashboardLogicalIdGraphQLField" = DashboardLogicalIdGraphQLField(
        "platform"
    )

    def fields(
        self, *subfields: DashboardLogicalIdGraphQLField
    ) -> "DashboardLogicalIdFields":
        """Subfields should come from the DashboardLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardLogicalIdFields":
        self._alias = alias
        return self


class DashboardSearchDocumentFields(GraphQLField):
    browse_path_hierarchy: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browse_path_segments: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    chart_descriptions: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("chartDescriptions")
    )
    charts: "DashboardSearchDocumentGraphQLField" = DashboardSearchDocumentGraphQLField(
        "charts"
    )
    contact_display_names: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("contactDisplayNames")
    )
    dashboard_id: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("dashboardId")
    )
    dashboard_type: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("dashboardType")
    )
    description: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("description")
    )
    document_id: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("documentId")
    )
    domain_display_names: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("domainDisplayNames")
    )
    domains: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("domains")
    )
    embedded_string_1: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("embeddedString_1")
    )
    embedded_string_2: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("embeddedString_2")
    )
    entity_id: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("entityId")
    )
    governed_tags: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("governedTags")
    )
    has_column_lineage: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("hasColumnLineage")
    )
    has_table_lineage: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("hasTableLineage")
    )
    hashtags: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("hashtags")
    )

    @classmethod
    def highlight(cls) -> "DashboardHighlightFields":
        return DashboardHighlightFields("highlight")

    is_complete: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("isComplete")
    )
    is_deleted: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("isDeleted")
    )
    is_production: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("isProduction")
    )
    knowledge_card_count: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("knowledgeCardCount")
    )
    last_refreshed: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("lastRefreshed")
    )
    model: "DashboardSearchDocumentGraphQLField" = DashboardSearchDocumentGraphQLField(
        "model"
    )
    name: "DashboardSearchDocumentGraphQLField" = DashboardSearchDocumentGraphQLField(
        "name"
    )
    overall_data_quality: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("overallDataQuality")
    )
    pagination_token: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("paginationToken")
    )
    platform: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("platform")
    )
    project: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("project")
    )

    @classmethod
    def score_details(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("score_details")

    thought_spot_dashboard_type: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("thoughtSpotDashboardType")
    )
    view_count: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("viewCount")
    )
    workspace: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("workspace")
    )

    def fields(
        self,
        *subfields: Union[
            DashboardSearchDocumentGraphQLField,
            "BrowsePathFields",
            "DashboardHighlightFields",
            "SearchScoreDetailsFields",
        ]
    ) -> "DashboardSearchDocumentFields":
        """Subfields should come from the DashboardSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardSearchDocumentFields":
        self._alias = alias
        return self


class DashboardSearchInfoFields(GraphQLField):
    chart_descriptions: "DashboardSearchInfoGraphQLField" = (
        DashboardSearchInfoGraphQLField("chartDescriptions")
    )
    charts: "DashboardSearchInfoGraphQLField" = DashboardSearchInfoGraphQLField(
        "charts"
    )
    dashboard_id: "DashboardSearchInfoGraphQLField" = DashboardSearchInfoGraphQLField(
        "dashboardId"
    )

    def fields(
        self, *subfields: DashboardSearchInfoGraphQLField
    ) -> "DashboardSearchInfoFields":
        """Subfields should come from the DashboardSearchInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardSearchInfoFields":
        self._alias = alias
        return self


class DashboardSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "DashboardSearchDocumentFields":
        return DashboardSearchDocumentFields("documents")

    error_message: "DashboardSearchResultGraphQLField" = (
        DashboardSearchResultGraphQLField("errorMessage")
    )
    from_: "DashboardSearchResultGraphQLField" = DashboardSearchResultGraphQLField(
        "from"
    )
    has_more: "DashboardSearchResultGraphQLField" = DashboardSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "DashboardSearchResultGraphQLField" = (
        DashboardSearchResultGraphQLField("paginationToken")
    )
    search_context: "DashboardSearchResultGraphQLField" = (
        DashboardSearchResultGraphQLField("searchContext")
    )
    search_index: "DashboardSearchResultGraphQLField" = (
        DashboardSearchResultGraphQLField("searchIndex")
    )
    size: "DashboardSearchResultGraphQLField" = DashboardSearchResultGraphQLField(
        "size"
    )
    total_count: "DashboardSearchResultGraphQLField" = (
        DashboardSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            DashboardSearchResultGraphQLField,
            "AggregationMetadataFields",
            "DashboardSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "DashboardSearchResultFields":
        """Subfields should come from the DashboardSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardSearchResultFields":
        self._alias = alias
        return self


class DataDocumentFields(GraphQLField):
    content: "DataDocumentGraphQLField" = DataDocumentGraphQLField("content")
    title: "DataDocumentGraphQLField" = DataDocumentGraphQLField("title")

    @classmethod
    def tokenized_content(cls) -> "DataDocumentTokenizedContentFields":
        return DataDocumentTokenizedContentFields("tokenized_content")

    def fields(
        self,
        *subfields: Union[
            DataDocumentGraphQLField, "DataDocumentTokenizedContentFields"
        ]
    ) -> "DataDocumentFields":
        """Subfields should come from the DataDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DataDocumentFields":
        self._alias = alias
        return self


class DataDocumentSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "KnowledgeCardSearchDocumentFields":
        return KnowledgeCardSearchDocumentFields("documents")

    error_message: "DataDocumentSearchResultGraphQLField" = (
        DataDocumentSearchResultGraphQLField("errorMessage")
    )
    from_: "DataDocumentSearchResultGraphQLField" = (
        DataDocumentSearchResultGraphQLField("from")
    )
    has_more: "DataDocumentSearchResultGraphQLField" = (
        DataDocumentSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "DataDocumentSearchResultGraphQLField" = (
        DataDocumentSearchResultGraphQLField("paginationToken")
    )
    search_context: "DataDocumentSearchResultGraphQLField" = (
        DataDocumentSearchResultGraphQLField("searchContext")
    )
    search_index: "DataDocumentSearchResultGraphQLField" = (
        DataDocumentSearchResultGraphQLField("searchIndex")
    )
    size: "DataDocumentSearchResultGraphQLField" = DataDocumentSearchResultGraphQLField(
        "size"
    )
    total_count: "DataDocumentSearchResultGraphQLField" = (
        DataDocumentSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            DataDocumentSearchResultGraphQLField,
            "AggregationMetadataFields",
            "KnowledgeCardSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "DataDocumentSearchResultFields":
        """Subfields should come from the DataDocumentSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DataDocumentSearchResultFields":
        self._alias = alias
        return self


class DataDocumentTokenizedContentFields(GraphQLField):
    content: "DataDocumentTokenizedContentGraphQLField" = (
        DataDocumentTokenizedContentGraphQLField("content")
    )

    def fields(
        self, *subfields: DataDocumentTokenizedContentGraphQLField
    ) -> "DataDocumentTokenizedContentFields":
        """Subfields should come from the DataDocumentTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DataDocumentTokenizedContentFields":
        self._alias = alias
        return self


class DataGroupSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "NamespaceSearchDocumentFields":
        return NamespaceSearchDocumentFields("documents")

    error_message: "DataGroupSearchResultGraphQLField" = (
        DataGroupSearchResultGraphQLField("errorMessage")
    )
    from_: "DataGroupSearchResultGraphQLField" = DataGroupSearchResultGraphQLField(
        "from"
    )
    has_more: "DataGroupSearchResultGraphQLField" = DataGroupSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "DataGroupSearchResultGraphQLField" = (
        DataGroupSearchResultGraphQLField("paginationToken")
    )
    search_context: "DataGroupSearchResultGraphQLField" = (
        DataGroupSearchResultGraphQLField("searchContext")
    )
    search_index: "DataGroupSearchResultGraphQLField" = (
        DataGroupSearchResultGraphQLField("searchIndex")
    )
    size: "DataGroupSearchResultGraphQLField" = DataGroupSearchResultGraphQLField(
        "size"
    )
    total_count: "DataGroupSearchResultGraphQLField" = (
        DataGroupSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            DataGroupSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NamespaceSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "DataGroupSearchResultFields":
        """Subfields should come from the DataGroupSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DataGroupSearchResultFields":
        self._alias = alias
        return self


class DataMonitorFields(GraphQLField):
    description: "DataMonitorGraphQLField" = DataMonitorGraphQLField("description")
    last_run: "DataMonitorGraphQLField" = DataMonitorGraphQLField("lastRun")
    owner: "DataMonitorGraphQLField" = DataMonitorGraphQLField("owner")
    severity: "DataMonitorGraphQLField" = DataMonitorGraphQLField("severity")
    status: "DataMonitorGraphQLField" = DataMonitorGraphQLField("status")

    @classmethod
    def targets(cls) -> "DataMonitorTargetFields":
        return DataMonitorTargetFields("targets")

    title: "DataMonitorGraphQLField" = DataMonitorGraphQLField("title")
    url: "DataMonitorGraphQLField" = DataMonitorGraphQLField("url")
    value: "DataMonitorGraphQLField" = DataMonitorGraphQLField("value")

    def fields(
        self, *subfields: Union[DataMonitorGraphQLField, "DataMonitorTargetFields"]
    ) -> "DataMonitorFields":
        """Subfields should come from the DataMonitorFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DataMonitorFields":
        self._alias = alias
        return self


class DataMonitorTargetFields(GraphQLField):
    column: "DataMonitorTargetGraphQLField" = DataMonitorTargetGraphQLField("column")
    dataset: "DataMonitorTargetGraphQLField" = DataMonitorTargetGraphQLField("dataset")

    def fields(
        self, *subfields: DataMonitorTargetGraphQLField
    ) -> "DataMonitorTargetFields":
        """Subfields should come from the DataMonitorTargetFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DataMonitorTargetFields":
        self._alias = alias
        return self


class DataQualityStatusSourceFields(GraphQLField):
    source_entity: "DataQualityStatusSourceGraphQLField" = (
        DataQualityStatusSourceGraphQLField("sourceEntity")
    )
    status: "DataQualityStatusSourceGraphQLField" = DataQualityStatusSourceGraphQLField(
        "status"
    )

    def fields(
        self, *subfields: DataQualityStatusSourceGraphQLField
    ) -> "DataQualityStatusSourceFields":
        """Subfields should come from the DataQualityStatusSourceFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DataQualityStatusSourceFields":
        self._alias = alias
        return self


class DatasetFields(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def asset_contacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("asset_contacts")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "DatasetGraphQLField" = DatasetGraphQLField("createdAt")

    @classmethod
    def custom_metadata(cls) -> "CustomMetadataFields":
        return CustomMetadataFields("custom_metadata")

    @classmethod
    def data_quality(cls) -> "DatasetDataQualityFields":
        return DatasetDataQualityFields("data_quality")

    deleted_at: "DatasetGraphQLField" = DatasetGraphQLField("deletedAt")

    @classmethod
    def descriptions(cls) -> "DerivedAssetDescriptionsFields":
        return DerivedAssetDescriptionsFields("descriptions")

    display_name: "DatasetGraphQLField" = DatasetGraphQLField("displayName")

    @classmethod
    def documentation(cls) -> "DatasetDocumentationFields":
        return DatasetDocumentationFields("documentation")

    @classmethod
    def downstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineage_for: Optional[LineageFilterInput] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineage_for},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstream_of_type", arguments=cleared_arguments
        )

    entity_type: "DatasetGraphQLField" = DatasetGraphQLField("entityType")

    @classmethod
    def entity_upstream(cls) -> "EntityUpstreamFields":
        return EntityUpstreamFields("entity_upstream")

    @classmethod
    def field_associations(cls) -> "DatasetFieldAssociationsFields":
        return DatasetFieldAssociationsFields("field_associations")

    @classmethod
    def field_statistics(cls) -> "DatasetFieldStatisticsFields":
        return DatasetFieldStatisticsFields("field_statistics")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def force_shown(cls) -> "AuditStampFields":
        return AuditStampFields("force_shown")

    @classmethod
    def governed_tags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governed_tags", arguments=cleared_arguments
        )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "DatasetGraphQLField" = DatasetGraphQLField("id")

    @classmethod
    def interested_parties(cls) -> "InterestedPartyFields":
        return InterestedPartyFields("interested_parties")

    is_complete: "DatasetGraphQLField" = DatasetGraphQLField("isComplete")
    is_deleted: "DatasetGraphQLField" = DatasetGraphQLField("isDeleted")
    is_production: "DatasetGraphQLField" = DatasetGraphQLField("isProduction")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledge_cards(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledge_cards", arguments=cleared_arguments
        )

    @classmethod
    def labels(cls) -> "AnchorEntityLabelFields":
        return AnchorEntityLabelFields("labels")

    last_ingested_at: "DatasetGraphQLField" = DatasetGraphQLField("lastIngestedAt")
    last_modified_at: "DatasetGraphQLField" = DatasetGraphQLField("lastModifiedAt")

    @classmethod
    def logical_id(cls) -> "DatasetLogicalIdFields":
        return DatasetLogicalIdFields("logical_id")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def overall_data_quality(cls) -> "OverallDataQualityFields":
        return OverallDataQualityFields("overall_data_quality")

    overall_data_quality_status: "DatasetGraphQLField" = DatasetGraphQLField(
        "overallDataQualityStatus"
    )

    @classmethod
    def pipeline_info(cls) -> "PipelineInfoFields":
        return PipelineInfoFields("pipeline_info")

    @classmethod
    def query_curators(cls) -> "PersonFields":
        return PersonFields("query_curators")

    @classmethod
    def query_issuers(
        cls, *, days_ago: Optional[float] = None
    ) -> "DatasetGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "daysAgo": {"type": "Float", "value": days_ago}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DatasetGraphQLField("query_issuers", arguments=cleared_arguments)

    @classmethod
    def recent_queries(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        days_ago: Optional[float] = None,
        filters: Optional[QueryInfoConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "QueryInfoConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "daysAgo": {"type": "Float", "value": days_ago},
            "filters": {"type": "QueryInfoConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return QueryInfoConnectionFields("recent_queries", arguments=cleared_arguments)

    @classmethod
    def recent_user_activities(
        cls, *, input: Optional[RecentUserActivitiesFilterInput] = None
    ) -> "RecentUserActivitiesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "RecentUserActivitiesFilterInput", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return RecentUserActivitiesFields(
            "recent_user_activities", arguments=cleared_arguments
        )

    @classmethod
    def recently_viewed_by(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "ViewedByConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewedByConnectionFields(
            "recently_viewed_by", arguments=cleared_arguments
        )

    @classmethod
    def related_asset_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        relation_for: Optional[DatasetRelationInput] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "relationFor": {"type": "DatasetRelationInput", "value": relation_for},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "related_asset_of_type", arguments=cleared_arguments
        )

    @classmethod
    def schema(cls) -> "DatasetSchemaFields":
        return DatasetSchemaFields("schema")

    @classmethod
    def snowflake_stream_info(cls) -> "SnowflakeStreamInfoFields":
        return SnowflakeStreamInfoFields("snowflake_stream_info")

    @classmethod
    def source_info(cls) -> "SourceInfoFields":
        return SourceInfoFields("source_info")

    @classmethod
    def statistics(cls) -> "DatasetStatisticsFields":
        return DatasetStatisticsFields("statistics")

    @classmethod
    def structure(cls) -> "DatasetStructureFields":
        return DatasetStructureFields("structure")

    @classmethod
    def system_contacts(cls) -> "SystemContactsFields":
        return SystemContactsFields("system_contacts")

    @classmethod
    def system_description(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("system_description")

    system_tag_values: "DatasetGraphQLField" = DatasetGraphQLField("systemTagValues")

    @classmethod
    def system_tags(cls) -> "SystemTagsFields":
        return SystemTagsFields("system_tags")

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    @classmethod
    def top_knowledge_card_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(
            "top_knowledge_card_authors", arguments=cleared_arguments
        )

    @classmethod
    def unity_catalog(cls) -> "UnityCatalogFields":
        return UnityCatalogFields("unity_catalog")

    @classmethod
    def upstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineage_for: Optional[LineageFilterInput] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineage_for},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstream_of_type", arguments=cleared_arguments
        )

    @classmethod
    def usage(cls) -> "DatasetUsageFields":
        return DatasetUsageFields("usage")

    viewer_can_assign_asset_contacts: "DatasetGraphQLField" = DatasetGraphQLField(
        "viewerCanAssignAssetContacts"
    )
    viewer_has_pinned: "DatasetGraphQLField" = DatasetGraphQLField("viewerHasPinned")

    def fields(
        self,
        *subfields: Union[
            DatasetGraphQLField,
            "AggregationMetadataFields",
            "AnchorEntityLabelFields",
            "AssetContactsFields",
            "AssetFollowersFields",
            "AuditStampFields",
            "BrowsePathFields",
            "CustomMetadataFields",
            "DatasetDataQualityFields",
            "DatasetDocumentationFields",
            "DatasetFieldAssociationsFields",
            "DatasetFieldStatisticsFields",
            "DatasetLogicalIdFields",
            "DatasetSchemaFields",
            "DatasetStatisticsFields",
            "DatasetStructureFields",
            "DatasetUsageFields",
            "DerivedAssetDescriptionsFields",
            "EntityLineageConnectionFields",
            "EntityUpstreamFields",
            "HashtagFields",
            "InterestedPartyFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "OverallDataQualityFields",
            "PersonConnectionFields",
            "PersonFields",
            "PipelineInfoFields",
            "QueryInfoConnectionFields",
            "RecentUserActivitiesFields",
            "SnowflakeStreamInfoFields",
            "SourceInfoFields",
            "SystemContactsFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
            "UnityCatalogFields",
            "UserDefinedResourceConnectionFields",
            "ViewedByConnectionFields",
        ]
    ) -> "DatasetFields":
        """Subfields should come from the DatasetFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetFields":
        self._alias = alias
        return self


class DatasetColumnsFields(GraphQLField):
    dataset_id: "DatasetColumnsGraphQLField" = DatasetColumnsGraphQLField("datasetId")

    @classmethod
    def dataset_logical_id(cls) -> "DatasetLogicalIdFields":
        return DatasetLogicalIdFields("dataset_logical_id")

    fields: "DatasetColumnsGraphQLField" = DatasetColumnsGraphQLField("fields")

    def fields(
        self, *subfields: Union[DatasetColumnsGraphQLField, "DatasetLogicalIdFields"]
    ) -> "DatasetColumnsFields":
        """Subfields should come from the DatasetColumnsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetColumnsFields":
        self._alias = alias
        return self


class DatasetConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "DatasetEdgeFields":
        return DatasetEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "DatasetConnectionGraphQLField" = DatasetConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            DatasetConnectionGraphQLField, "DatasetEdgeFields", "PageInfoFields"
        ]
    ) -> "DatasetConnectionFields":
        """Subfields should come from the DatasetConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetConnectionFields":
        self._alias = alias
        return self


class DatasetDataQualityFields(GraphQLField):
    created_at: "DatasetDataQualityGraphQLField" = DatasetDataQualityGraphQLField(
        "createdAt"
    )
    entity_id: "DatasetDataQualityGraphQLField" = DatasetDataQualityGraphQLField(
        "entityId"
    )

    @classmethod
    def monitors(cls) -> "DataMonitorFields":
        return DataMonitorFields("monitors")

    provider: "DatasetDataQualityGraphQLField" = DatasetDataQualityGraphQLField(
        "provider"
    )
    url: "DatasetDataQualityGraphQLField" = DatasetDataQualityGraphQLField("url")

    def fields(
        self, *subfields: Union[DatasetDataQualityGraphQLField, "DataMonitorFields"]
    ) -> "DatasetDataQualityFields":
        """Subfields should come from the DatasetDataQualityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetDataQualityFields":
        self._alias = alias
        return self


class DatasetDocumentationFields(GraphQLField):
    created_at: "DatasetDocumentationGraphQLField" = DatasetDocumentationGraphQLField(
        "createdAt"
    )
    dataset_documentations: "DatasetDocumentationGraphQLField" = (
        DatasetDocumentationGraphQLField("datasetDocumentations")
    )
    entity_id: "DatasetDocumentationGraphQLField" = DatasetDocumentationGraphQLField(
        "entityId"
    )

    @classmethod
    def field_documentations(cls) -> "FieldDocumentationFields":
        return FieldDocumentationFields("field_documentations")

    def fields(
        self,
        *subfields: Union[DatasetDocumentationGraphQLField, "FieldDocumentationFields"]
    ) -> "DatasetDocumentationFields":
        """Subfields should come from the DatasetDocumentationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetDocumentationFields":
        self._alias = alias
        return self


class DatasetEdgeFields(GraphQLField):
    cursor: "DatasetEdgeGraphQLField" = DatasetEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "DatasetFields":
        return DatasetFields("node")

    def fields(
        self, *subfields: Union[DatasetEdgeGraphQLField, "DatasetFields"]
    ) -> "DatasetEdgeFields":
        """Subfields should come from the DatasetEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetEdgeFields":
        self._alias = alias
        return self


class DatasetFieldAssociationsFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "DatasetFieldAssociationsGraphQLField" = (
        DatasetFieldAssociationsGraphQLField("createdAt")
    )
    entity_id: "DatasetFieldAssociationsGraphQLField" = (
        DatasetFieldAssociationsGraphQLField("entityId")
    )

    @classmethod
    def governed_tag_fields(cls) -> "FieldTagAssociationsFields":
        return FieldTagAssociationsFields("governed_tag_fields")

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    def fields(
        self,
        *subfields: Union[
            DatasetFieldAssociationsGraphQLField,
            "AuditStampFields",
            "FieldTagAssociationsFields",
        ]
    ) -> "DatasetFieldAssociationsFields":
        """Subfields should come from the DatasetFieldAssociationsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetFieldAssociationsFields":
        self._alias = alias
        return self


class DatasetFieldStatisticsFields(GraphQLField):
    created_at: "DatasetFieldStatisticsGraphQLField" = (
        DatasetFieldStatisticsGraphQLField("createdAt")
    )
    entity_id: "DatasetFieldStatisticsGraphQLField" = (
        DatasetFieldStatisticsGraphQLField("entityId")
    )

    @classmethod
    def field_statistics(cls) -> "FieldStatisticsFields":
        return FieldStatisticsFields("field_statistics")

    def fields(
        self,
        *subfields: Union[DatasetFieldStatisticsGraphQLField, "FieldStatisticsFields"]
    ) -> "DatasetFieldStatisticsFields":
        """Subfields should come from the DatasetFieldStatisticsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetFieldStatisticsFields":
        self._alias = alias
        return self


class DatasetHighlightFields(GraphQLField):
    column_descriptions: "DatasetHighlightGraphQLField" = DatasetHighlightGraphQLField(
        "columnDescriptions"
    )
    column_names: "DatasetHighlightGraphQLField" = DatasetHighlightGraphQLField(
        "columnNames"
    )
    column_tags: "DatasetHighlightGraphQLField" = DatasetHighlightGraphQLField(
        "columnTags"
    )
    contact_display_names: "DatasetHighlightGraphQLField" = (
        DatasetHighlightGraphQLField("contactDisplayNames")
    )
    description: "DatasetHighlightGraphQLField" = DatasetHighlightGraphQLField(
        "description"
    )
    governed_tags: "DatasetHighlightGraphQLField" = DatasetHighlightGraphQLField(
        "governedTags"
    )
    hashtags: "DatasetHighlightGraphQLField" = DatasetHighlightGraphQLField("hashtags")
    name: "DatasetHighlightGraphQLField" = DatasetHighlightGraphQLField("name")

    def fields(
        self, *subfields: DatasetHighlightGraphQLField
    ) -> "DatasetHighlightFields":
        """Subfields should come from the DatasetHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetHighlightFields":
        self._alias = alias
        return self


class DatasetLogicalIdFields(GraphQLField):
    account: "DatasetLogicalIdGraphQLField" = DatasetLogicalIdGraphQLField("account")
    name: "DatasetLogicalIdGraphQLField" = DatasetLogicalIdGraphQLField("name")
    platform: "DatasetLogicalIdGraphQLField" = DatasetLogicalIdGraphQLField("platform")

    def fields(
        self, *subfields: DatasetLogicalIdGraphQLField
    ) -> "DatasetLogicalIdFields":
        """Subfields should come from the DatasetLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetLogicalIdFields":
        self._alias = alias
        return self


class DatasetPatternFields(GraphQLField):
    account: "DatasetPatternGraphQLField" = DatasetPatternGraphQLField("account")
    database: "DatasetPatternGraphQLField" = DatasetPatternGraphQLField("database")
    is_case_sensitive: "DatasetPatternGraphQLField" = DatasetPatternGraphQLField(
        "isCaseSensitive"
    )
    platform: "DatasetPatternGraphQLField" = DatasetPatternGraphQLField("platform")
    schema: "DatasetPatternGraphQLField" = DatasetPatternGraphQLField("schema")
    table: "DatasetPatternGraphQLField" = DatasetPatternGraphQLField("table")

    def fields(self, *subfields: DatasetPatternGraphQLField) -> "DatasetPatternFields":
        """Subfields should come from the DatasetPatternFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetPatternFields":
        self._alias = alias
        return self


class DatasetSchemaFields(GraphQLField):
    @classmethod
    def common_column_attributes(cls) -> "SchemaFieldWithCommonAttributesFields":
        return SchemaFieldWithCommonAttributesFields("common_column_attributes")

    @classmethod
    def common_column_descriptions(cls) -> "SchemaFieldFields":
        return SchemaFieldFields("common_column_descriptions")

    created_at: "DatasetSchemaGraphQLField" = DatasetSchemaGraphQLField("createdAt")

    @classmethod
    def dbt_schema_fields(cls) -> "SchemaFieldFields":
        return SchemaFieldFields("dbt_schema_fields")

    description: "DatasetSchemaGraphQLField" = DatasetSchemaGraphQLField("description")
    entity_id: "DatasetSchemaGraphQLField" = DatasetSchemaGraphQLField("entityId")

    @classmethod
    def fields(cls) -> "SchemaFieldFields":
        return SchemaFieldFields("fields")

    @classmethod
    def flattened_subfields(cls) -> "SchemaFieldFields":
        return SchemaFieldFields("flattened_subfields")

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    raw_schema: "DatasetSchemaGraphQLField" = DatasetSchemaGraphQLField("rawSchema")

    @classmethod
    def schema_field_crowd_sourced_descriptions(
        cls, *, filters: Optional[KnowledgeCardConnectionFilterInput] = None
    ) -> "KnowledgeCardFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardFields(
            "schema_field_crowd_sourced_descriptions", arguments=cleared_arguments
        )

    schema_type: "DatasetSchemaGraphQLField" = DatasetSchemaGraphQLField("schemaType")

    @classmethod
    def sql_schema(cls) -> "SqlSchemaFields":
        return SqlSchemaFields("sql_schema")

    @classmethod
    def viewer_can_add_schema_field_description_for(
        cls, *, field_paths: Optional[str] = None
    ) -> "FieldPathPermissionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "fieldPaths": {"type": "String", "value": field_paths}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FieldPathPermissionFields(
            "viewer_can_add_schema_field_description_for", arguments=cleared_arguments
        )

    def fields(
        self,
        *subfields: Union[
            DatasetSchemaGraphQLField,
            "AuditStampFields",
            "FieldPathPermissionFields",
            "KnowledgeCardFields",
            "SchemaFieldFields",
            "SchemaFieldWithCommonAttributesFields",
            "SqlSchemaFields",
        ]
    ) -> "DatasetSchemaFields":
        """Subfields should come from the DatasetSchemaFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetSchemaFields":
        self._alias = alias
        return self


class DatasetSearchDocumentFields(GraphQLField):
    browse_path_hierarchy: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browse_path_segments: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    column_descriptions: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("columnDescriptions")
    )
    column_names: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("columnNames")
    )
    column_tags: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("columnTags")
    )
    contact_display_names: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("contactDisplayNames")
    )
    created: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "created"
    )
    database: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "database"
    )
    description: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("description")
    )
    document_id: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("documentId")
    )
    domain_display_names: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("domainDisplayNames")
    )
    domains: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "domains"
    )
    embedded_string_1: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("embeddedString_1")
    )
    embedded_string_2: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("embeddedString_2")
    )
    entity_id: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "entityId"
    )
    full_name: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "fullName"
    )
    governed_tags: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("governedTags")
    )
    has_column_lineage: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("hasColumnLineage")
    )
    has_table_lineage: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("hasTableLineage")
    )
    hashtags: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "hashtags"
    )

    @classmethod
    def highlight(cls) -> "DatasetHighlightFields":
        return DatasetHighlightFields("highlight")

    is_complete: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("isComplete")
    )
    is_deleted: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "isDeleted"
    )
    is_production: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("isProduction")
    )
    knowledge_card_count: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("knowledgeCardCount")
    )
    last_queried: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("lastQueried")
    )
    last_refreshed: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("lastRefreshed")
    )
    last_updated: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("lastUpdated")
    )
    materialization_type: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("materializationType")
    )
    name: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "name"
    )
    overall_data_quality: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("overallDataQuality")
    )
    pagination_token: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("paginationToken")
    )
    platform: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "platform"
    )

    @classmethod
    def query_count_percentile(cls) -> "QueryCountPercentileFields":
        return QueryCountPercentileFields("query_count_percentile")

    row_count: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "rowCount"
    )
    schema: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "schema"
    )

    @classmethod
    def score_details(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("score_details")

    size: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "size"
    )
    unity_catalog_dataset_type: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("unityCatalogDatasetType")
    )
    usage_level: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("usageLevel")
    )
    usage_percentile: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("usagePercentile")
    )
    view_count: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "viewCount"
    )

    def fields(
        self,
        *subfields: Union[
            DatasetSearchDocumentGraphQLField,
            "BrowsePathFields",
            "DatasetHighlightFields",
            "QueryCountPercentileFields",
            "SearchScoreDetailsFields",
        ]
    ) -> "DatasetSearchDocumentFields":
        """Subfields should come from the DatasetSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetSearchDocumentFields":
        self._alias = alias
        return self


class DatasetSearchInfoFields(GraphQLField):
    database: "DatasetSearchInfoGraphQLField" = DatasetSearchInfoGraphQLField(
        "database"
    )
    full_name: "DatasetSearchInfoGraphQLField" = DatasetSearchInfoGraphQLField(
        "fullName"
    )

    @classmethod
    def query_count_percentile(cls) -> "QueryCountPercentileFields":
        return QueryCountPercentileFields("query_count_percentile")

    row_count: "DatasetSearchInfoGraphQLField" = DatasetSearchInfoGraphQLField(
        "rowCount"
    )
    schema: "DatasetSearchInfoGraphQLField" = DatasetSearchInfoGraphQLField("schema")
    size: "DatasetSearchInfoGraphQLField" = DatasetSearchInfoGraphQLField("size")
    usage_level: "DatasetSearchInfoGraphQLField" = DatasetSearchInfoGraphQLField(
        "usageLevel"
    )
    usage_percentile: "DatasetSearchInfoGraphQLField" = DatasetSearchInfoGraphQLField(
        "usagePercentile"
    )

    def fields(
        self,
        *subfields: Union[DatasetSearchInfoGraphQLField, "QueryCountPercentileFields"]
    ) -> "DatasetSearchInfoFields":
        """Subfields should come from the DatasetSearchInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetSearchInfoFields":
        self._alias = alias
        return self


class DatasetSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "DatasetSearchDocumentFields":
        return DatasetSearchDocumentFields("documents")

    error_message: "DatasetSearchResultGraphQLField" = DatasetSearchResultGraphQLField(
        "errorMessage"
    )
    from_: "DatasetSearchResultGraphQLField" = DatasetSearchResultGraphQLField("from")
    has_more: "DatasetSearchResultGraphQLField" = DatasetSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "DatasetSearchResultGraphQLField" = (
        DatasetSearchResultGraphQLField("paginationToken")
    )
    search_context: "DatasetSearchResultGraphQLField" = DatasetSearchResultGraphQLField(
        "searchContext"
    )
    search_index: "DatasetSearchResultGraphQLField" = DatasetSearchResultGraphQLField(
        "searchIndex"
    )
    size: "DatasetSearchResultGraphQLField" = DatasetSearchResultGraphQLField("size")
    total_count: "DatasetSearchResultGraphQLField" = DatasetSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            DatasetSearchResultGraphQLField,
            "AggregationMetadataFields",
            "DatasetSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "DatasetSearchResultFields":
        """Subfields should come from the DatasetSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetSearchResultFields":
        self._alias = alias
        return self


class DatasetStatisticsFields(GraphQLField):
    created_at: "DatasetStatisticsGraphQLField" = DatasetStatisticsGraphQLField(
        "createdAt"
    )
    data_size_bytes: "DatasetStatisticsGraphQLField" = DatasetStatisticsGraphQLField(
        "dataSizeBytes"
    )
    entity_id: "DatasetStatisticsGraphQLField" = DatasetStatisticsGraphQLField(
        "entityId"
    )

    @classmethod
    def field_statistics(cls) -> "FieldStatisticsFields":
        return FieldStatisticsFields("field_statistics")

    record_count: "DatasetStatisticsGraphQLField" = DatasetStatisticsGraphQLField(
        "recordCount"
    )

    def fields(
        self, *subfields: Union[DatasetStatisticsGraphQLField, "FieldStatisticsFields"]
    ) -> "DatasetStatisticsFields":
        """Subfields should come from the DatasetStatisticsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetStatisticsFields":
        self._alias = alias
        return self


class DatasetStructureFields(GraphQLField):
    created_at: "DatasetStructureGraphQLField" = DatasetStructureGraphQLField(
        "createdAt"
    )
    database: "DatasetStructureGraphQLField" = DatasetStructureGraphQLField("database")
    entity_id: "DatasetStructureGraphQLField" = DatasetStructureGraphQLField("entityId")
    schema: "DatasetStructureGraphQLField" = DatasetStructureGraphQLField("schema")
    table: "DatasetStructureGraphQLField" = DatasetStructureGraphQLField("table")

    def fields(
        self, *subfields: DatasetStructureGraphQLField
    ) -> "DatasetStructureFields":
        """Subfields should come from the DatasetStructureFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetStructureFields":
        self._alias = alias
        return self


class DatasetUsageFields(GraphQLField):
    created_at: "DatasetUsageGraphQLField" = DatasetUsageGraphQLField("createdAt")
    entity_id: "DatasetUsageGraphQLField" = DatasetUsageGraphQLField("entityId")

    @classmethod
    def field_query_counts(cls) -> "FieldQueryCountsFields":
        return FieldQueryCountsFields("field_query_counts")

    @classmethod
    def query_counts(cls) -> "QueryCountsFields":
        return QueryCountsFields("query_counts")

    @classmethod
    def table_joins(cls) -> "TableJoinsFields":
        return TableJoinsFields("table_joins")

    @classmethod
    def user_query_counts(cls) -> "UserQueryCountsFields":
        return UserQueryCountsFields("user_query_counts")

    def fields(
        self,
        *subfields: Union[
            DatasetUsageGraphQLField,
            "FieldQueryCountsFields",
            "QueryCountsFields",
            "TableJoinsFields",
            "UserQueryCountsFields",
        ]
    ) -> "DatasetUsageFields":
        """Subfields should come from the DatasetUsageFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetUsageFields":
        self._alias = alias
        return self


class DbtMacroFields(GraphQLField):
    @classmethod
    def arguments(cls) -> "DbtMacroArgumentFields":
        return DbtMacroArgumentFields("arguments")

    depends_on_macros: "DbtMacroGraphQLField" = DbtMacroGraphQLField("dependsOnMacros")
    description: "DbtMacroGraphQLField" = DbtMacroGraphQLField("description")
    name: "DbtMacroGraphQLField" = DbtMacroGraphQLField("name")
    package_name: "DbtMacroGraphQLField" = DbtMacroGraphQLField("packageName")
    sql: "DbtMacroGraphQLField" = DbtMacroGraphQLField("sql")
    unique_id: "DbtMacroGraphQLField" = DbtMacroGraphQLField("uniqueId")

    def fields(
        self, *subfields: Union[DbtMacroGraphQLField, "DbtMacroArgumentFields"]
    ) -> "DbtMacroFields":
        """Subfields should come from the DbtMacroFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtMacroFields":
        self._alias = alias
        return self


class DbtMacroArgumentFields(GraphQLField):
    description: "DbtMacroArgumentGraphQLField" = DbtMacroArgumentGraphQLField(
        "description"
    )
    name: "DbtMacroArgumentGraphQLField" = DbtMacroArgumentGraphQLField("name")
    type: "DbtMacroArgumentGraphQLField" = DbtMacroArgumentGraphQLField("type")

    def fields(
        self, *subfields: DbtMacroArgumentGraphQLField
    ) -> "DbtMacroArgumentFields":
        """Subfields should come from the DbtMacroArgumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtMacroArgumentFields":
        self._alias = alias
        return self


class DbtMaterializationFields(GraphQLField):
    target_dataset: "DbtMaterializationGraphQLField" = DbtMaterializationGraphQLField(
        "targetDataset"
    )
    type: "DbtMaterializationGraphQLField" = DbtMaterializationGraphQLField("type")

    def fields(
        self, *subfields: DbtMaterializationGraphQLField
    ) -> "DbtMaterializationFields":
        """Subfields should come from the DbtMaterializationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtMaterializationFields":
        self._alias = alias
        return self


class DbtMetadataItemFields(GraphQLField):
    key: "DbtMetadataItemGraphQLField" = DbtMetadataItemGraphQLField("key")
    value: "DbtMetadataItemGraphQLField" = DbtMetadataItemGraphQLField("value")

    def fields(
        self, *subfields: DbtMetadataItemGraphQLField
    ) -> "DbtMetadataItemFields":
        """Subfields should come from the DbtMetadataItemFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtMetadataItemFields":
        self._alias = alias
        return self


class DbtMetricFields(GraphQLField):
    created_at: "DbtMetricGraphQLField" = DbtMetricGraphQLField("createdAt")
    description: "DbtMetricGraphQLField" = DbtMetricGraphQLField("description")
    dimensions: "DbtMetricGraphQLField" = DbtMetricGraphQLField("dimensions")
    entity_id: "DbtMetricGraphQLField" = DbtMetricGraphQLField("entityId")

    @classmethod
    def filters(cls) -> "MetricFilterFields":
        return MetricFilterFields("filters")

    label: "DbtMetricGraphQLField" = DbtMetricGraphQLField("label")
    package_name: "DbtMetricGraphQLField" = DbtMetricGraphQLField("packageName")
    sql: "DbtMetricGraphQLField" = DbtMetricGraphQLField("sql")
    time_grains: "DbtMetricGraphQLField" = DbtMetricGraphQLField("timeGrains")
    timestamp: "DbtMetricGraphQLField" = DbtMetricGraphQLField("timestamp")
    type: "DbtMetricGraphQLField" = DbtMetricGraphQLField("type")
    url: "DbtMetricGraphQLField" = DbtMetricGraphQLField("url")

    def fields(
        self, *subfields: Union[DbtMetricGraphQLField, "MetricFilterFields"]
    ) -> "DbtMetricFields":
        """Subfields should come from the DbtMetricFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtMetricFields":
        self._alias = alias
        return self


class DbtModelFields(GraphQLField):
    compiled_sql: "DbtModelGraphQLField" = DbtModelGraphQLField("compiledSql")
    created_at: "DbtModelGraphQLField" = DbtModelGraphQLField("createdAt")
    description: "DbtModelGraphQLField" = DbtModelGraphQLField("description")
    docs_url: "DbtModelGraphQLField" = DbtModelGraphQLField("docsUrl")

    @classmethod
    def downstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineage_for: Optional[DbtDownstreamLineageInput] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "DbtDownstreamLineageInput", "value": lineage_for},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstream_of_type", arguments=cleared_arguments
        )

    entity_id: "DbtModelGraphQLField" = DbtModelGraphQLField("entityId")

    @classmethod
    def fields(cls) -> "SchemaFieldFields":
        return SchemaFieldFields("fields")

    @classmethod
    def macros(cls) -> "DbtMacroFields":
        return DbtMacroFields("macros")

    @classmethod
    def materialization(cls) -> "DbtMaterializationFields":
        return DbtMaterializationFields("materialization")

    @classmethod
    def meta(cls) -> "DbtMetadataItemFields":
        return DbtMetadataItemFields("meta")

    @classmethod
    def owners(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("owners", arguments=cleared_arguments)

    package_name: "DbtModelGraphQLField" = DbtModelGraphQLField("packageName")
    raw_sql: "DbtModelGraphQLField" = DbtModelGraphQLField("rawSql")

    @classmethod
    def related_asset_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        relation_for: Optional[DbtModelRelationInput] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "relationFor": {"type": "DbtModelRelationInput", "value": relation_for},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "related_asset_of_type", arguments=cleared_arguments
        )

    @classmethod
    def tests(cls) -> "DbtTestFields":
        return DbtTestFields("tests")

    @classmethod
    def upstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineage_for: Optional[DbtUpstreamLineageInput] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "DbtUpstreamLineageInput", "value": lineage_for},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstream_of_type", arguments=cleared_arguments
        )

    url: "DbtModelGraphQLField" = DbtModelGraphQLField("url")

    def fields(
        self,
        *subfields: Union[
            DbtModelGraphQLField,
            "DbtMacroFields",
            "DbtMaterializationFields",
            "DbtMetadataItemFields",
            "DbtTestFields",
            "EntityLineageConnectionFields",
            "PersonConnectionFields",
            "SchemaFieldFields",
        ]
    ) -> "DbtModelFields":
        """Subfields should come from the DbtModelFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtModelFields":
        self._alias = alias
        return self


class DbtModelSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "VirtualViewSearchDocumentFields":
        return VirtualViewSearchDocumentFields("documents")

    error_message: "DbtModelSearchResultGraphQLField" = (
        DbtModelSearchResultGraphQLField("errorMessage")
    )
    from_: "DbtModelSearchResultGraphQLField" = DbtModelSearchResultGraphQLField("from")
    has_more: "DbtModelSearchResultGraphQLField" = DbtModelSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "DbtModelSearchResultGraphQLField" = (
        DbtModelSearchResultGraphQLField("paginationToken")
    )
    search_context: "DbtModelSearchResultGraphQLField" = (
        DbtModelSearchResultGraphQLField("searchContext")
    )
    search_index: "DbtModelSearchResultGraphQLField" = DbtModelSearchResultGraphQLField(
        "searchIndex"
    )
    size: "DbtModelSearchResultGraphQLField" = DbtModelSearchResultGraphQLField("size")
    total_count: "DbtModelSearchResultGraphQLField" = DbtModelSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            DbtModelSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "VirtualViewSearchDocumentFields",
        ]
    ) -> "DbtModelSearchResultFields":
        """Subfields should come from the DbtModelSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtModelSearchResultFields":
        self._alias = alias
        return self


class DbtTestFields(GraphQLField):
    columns: "DbtTestGraphQLField" = DbtTestGraphQLField("columns")
    depends_on_macros: "DbtTestGraphQLField" = DbtTestGraphQLField("dependsOnMacros")
    name: "DbtTestGraphQLField" = DbtTestGraphQLField("name")
    sql: "DbtTestGraphQLField" = DbtTestGraphQLField("sql")
    unique_id: "DbtTestGraphQLField" = DbtTestGraphQLField("uniqueId")

    def fields(self, *subfields: DbtTestGraphQLField) -> "DbtTestFields":
        """Subfields should come from the DbtTestFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtTestFields":
        self._alias = alias
        return self


class DeleteCrawlersResponseFields(GraphQLField):
    deleted_ids: "DeleteCrawlersResponseGraphQLField" = (
        DeleteCrawlersResponseGraphQLField("deletedIds")
    )

    def fields(
        self, *subfields: DeleteCrawlersResponseGraphQLField
    ) -> "DeleteCrawlersResponseFields":
        """Subfields should come from the DeleteCrawlersResponseFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DeleteCrawlersResponseFields":
        self._alias = alias
        return self


class DeleteWebhookResponseFields(GraphQLField):
    deleted_ids: "DeleteWebhookResponseGraphQLField" = (
        DeleteWebhookResponseGraphQLField("deletedIds")
    )

    def fields(
        self, *subfields: DeleteWebhookResponseGraphQLField
    ) -> "DeleteWebhookResponseFields":
        """Subfields should come from the DeleteWebhookResponseFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DeleteWebhookResponseFields":
        self._alias = alias
        return self


class DeprecationKnowledgeCardFields(GraphQLField):
    detail: "DeprecationKnowledgeCardGraphQLField" = (
        DeprecationKnowledgeCardGraphQLField("detail")
    )
    planned_date: "DeprecationKnowledgeCardGraphQLField" = (
        DeprecationKnowledgeCardGraphQLField("plannedDate")
    )
    title: "DeprecationKnowledgeCardGraphQLField" = (
        DeprecationKnowledgeCardGraphQLField("title")
    )

    @classmethod
    def tokenized_content(cls) -> "DeprecationTokenizedContentFields":
        return DeprecationTokenizedContentFields("tokenized_content")

    def fields(
        self,
        *subfields: Union[
            DeprecationKnowledgeCardGraphQLField, "DeprecationTokenizedContentFields"
        ]
    ) -> "DeprecationKnowledgeCardFields":
        """Subfields should come from the DeprecationKnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DeprecationKnowledgeCardFields":
        self._alias = alias
        return self


class DeprecationTokenizedContentFields(GraphQLField):
    detail: "DeprecationTokenizedContentGraphQLField" = (
        DeprecationTokenizedContentGraphQLField("detail")
    )

    def fields(
        self, *subfields: DeprecationTokenizedContentGraphQLField
    ) -> "DeprecationTokenizedContentFields":
        """Subfields should come from the DeprecationTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DeprecationTokenizedContentFields":
        self._alias = alias
        return self


class DerivedAssetDescriptionsFields(GraphQLField):
    dbt: "DerivedAssetDescriptionsGraphQLField" = DerivedAssetDescriptionsGraphQLField(
        "dbt"
    )
    entity_id: "DerivedAssetDescriptionsGraphQLField" = (
        DerivedAssetDescriptionsGraphQLField("entityId")
    )

    @classmethod
    def user_generated(
        cls, *, filters: Optional[KnowledgeCardConnectionFilterInput] = None
    ) -> "KnowledgeCardFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardFields("user_generated", arguments=cleared_arguments)

    viewer_can_add: "DerivedAssetDescriptionsGraphQLField" = (
        DerivedAssetDescriptionsGraphQLField("viewerCanAdd")
    )

    def fields(
        self,
        *subfields: Union[DerivedAssetDescriptionsGraphQLField, "KnowledgeCardFields"]
    ) -> "DerivedAssetDescriptionsFields":
        """Subfields should come from the DerivedAssetDescriptionsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DerivedAssetDescriptionsFields":
        self._alias = alias
        return self


class DesignatedContactFields(GraphQLField):
    @classmethod
    def designation(cls) -> "UserDefinedResourceFields":
        return UserDefinedResourceFields("designation")

    @classmethod
    def group(cls) -> "GroupFields":
        return GroupFields("group")

    @classmethod
    def person(cls) -> "PersonFields":
        return PersonFields("person")

    value: "DesignatedContactGraphQLField" = DesignatedContactGraphQLField("value")
    value_type: "DesignatedContactGraphQLField" = DesignatedContactGraphQLField(
        "valueType"
    )

    def fields(
        self,
        *subfields: Union[
            DesignatedContactGraphQLField,
            "GroupFields",
            "PersonFields",
            "UserDefinedResourceFields",
        ]
    ) -> "DesignatedContactFields":
        """Subfields should come from the DesignatedContactFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DesignatedContactFields":
        self._alias = alias
        return self


class EntityInterface(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "EntityGraphQLField" = EntityGraphQLField("createdAt")
    deleted_at: "EntityGraphQLField" = EntityGraphQLField("deletedAt")
    display_name: "EntityGraphQLField" = EntityGraphQLField("displayName")
    entity_type: "EntityGraphQLField" = EntityGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "EntityGraphQLField" = EntityGraphQLField("id")
    is_deleted: "EntityGraphQLField" = EntityGraphQLField("isDeleted")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    last_ingested_at: "EntityGraphQLField" = EntityGraphQLField("lastIngestedAt")
    last_modified_at: "EntityGraphQLField" = EntityGraphQLField("lastModifiedAt")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            EntityGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "EntityInterface":
        """Subfields should come from the EntityInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EntityInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "EntityInterface":
        self._inline_fragments[type_name] = subfields
        return self


class EntityConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "EntityEdgeFields":
        return EntityEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "EntityConnectionGraphQLField" = EntityConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            EntityConnectionGraphQLField, "EntityEdgeFields", "PageInfoFields"
        ]
    ) -> "EntityConnectionFields":
        """Subfields should come from the EntityConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EntityConnectionFields":
        self._alias = alias
        return self


class EntityCountFields(GraphQLField):
    count: "EntityCountGraphQLField" = EntityCountGraphQLField("count")
    entity_type: "EntityCountGraphQLField" = EntityCountGraphQLField("entityType")

    def fields(self, *subfields: EntityCountGraphQLField) -> "EntityCountFields":
        """Subfields should come from the EntityCountFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EntityCountFields":
        self._alias = alias
        return self


class EntityEdgeFields(GraphQLField):
    cursor: "EntityEdgeGraphQLField" = EntityEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "EntityInterface":
        return EntityInterface("node")

    def fields(
        self, *subfields: Union[EntityEdgeGraphQLField, "EntityInterface"]
    ) -> "EntityEdgeFields":
        """Subfields should come from the EntityEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EntityEdgeFields":
        self._alias = alias
        return self


class EntityLineageConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "EntityLineageEdgeFields":
        return EntityLineageEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "EntityLineageConnectionGraphQLField" = (
        EntityLineageConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            EntityLineageConnectionGraphQLField,
            "EntityLineageEdgeFields",
            "PageInfoFields",
        ]
    ) -> "EntityLineageConnectionFields":
        """Subfields should come from the EntityLineageConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EntityLineageConnectionFields":
        self._alias = alias
        return self


class EntityLineageEdgeFields(GraphQLField):
    created_at: "EntityLineageEdgeGraphQLField" = EntityLineageEdgeGraphQLField(
        "createdAt"
    )
    cursor: "EntityLineageEdgeGraphQLField" = EntityLineageEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "EntityInterface":
        return EntityInterface("node")

    def fields(
        self, *subfields: Union[EntityLineageEdgeGraphQLField, "EntityInterface"]
    ) -> "EntityLineageEdgeFields":
        """Subfields should come from the EntityLineageEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EntityLineageEdgeFields":
        self._alias = alias
        return self


class EntityUpstreamFields(GraphQLField):
    created_at: "EntityUpstreamGraphQLField" = EntityUpstreamGraphQLField("createdAt")
    entity_id: "EntityUpstreamGraphQLField" = EntityUpstreamGraphQLField("entityId")
    executor_url: "EntityUpstreamGraphQLField" = EntityUpstreamGraphQLField(
        "executorUrl"
    )

    @classmethod
    def field_mappings(cls) -> "FieldMappingFields":
        return FieldMappingFields("field_mappings")

    source_code_url: "EntityUpstreamGraphQLField" = EntityUpstreamGraphQLField(
        "sourceCodeUrl"
    )
    source_entities: "EntityUpstreamGraphQLField" = EntityUpstreamGraphQLField(
        "sourceEntities"
    )
    transformation: "EntityUpstreamGraphQLField" = EntityUpstreamGraphQLField(
        "transformation"
    )

    def fields(
        self, *subfields: Union[EntityUpstreamGraphQLField, "FieldMappingFields"]
    ) -> "EntityUpstreamFields":
        """Subfields should come from the EntityUpstreamFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EntityUpstreamFields":
        self._alias = alias
        return self


class FieldDocumentationFields(GraphQLField):
    documentation: "FieldDocumentationGraphQLField" = FieldDocumentationGraphQLField(
        "documentation"
    )
    field_path: "FieldDocumentationGraphQLField" = FieldDocumentationGraphQLField(
        "fieldPath"
    )
    tests: "FieldDocumentationGraphQLField" = FieldDocumentationGraphQLField("tests")

    def fields(
        self, *subfields: FieldDocumentationGraphQLField
    ) -> "FieldDocumentationFields":
        """Subfields should come from the FieldDocumentationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FieldDocumentationFields":
        self._alias = alias
        return self


class FieldMappingFields(GraphQLField):
    destination: "FieldMappingGraphQLField" = FieldMappingGraphQLField("destination")

    @classmethod
    def sources(cls) -> "SourceFieldFields":
        return SourceFieldFields("sources")

    transformation: "FieldMappingGraphQLField" = FieldMappingGraphQLField(
        "transformation"
    )

    def fields(
        self, *subfields: Union[FieldMappingGraphQLField, "SourceFieldFields"]
    ) -> "FieldMappingFields":
        """Subfields should come from the FieldMappingFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FieldMappingFields":
        self._alias = alias
        return self


class FieldPathPermissionFields(GraphQLField):
    field_path: "FieldPathPermissionGraphQLField" = FieldPathPermissionGraphQLField(
        "fieldPath"
    )
    viewer_can_add: "FieldPathPermissionGraphQLField" = FieldPathPermissionGraphQLField(
        "viewerCanAdd"
    )

    def fields(
        self, *subfields: FieldPathPermissionGraphQLField
    ) -> "FieldPathPermissionFields":
        """Subfields should come from the FieldPathPermissionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FieldPathPermissionFields":
        self._alias = alias
        return self


class FieldQueryCountFields(GraphQLField):
    count: "FieldQueryCountGraphQLField" = FieldQueryCountGraphQLField("count")
    field: "FieldQueryCountGraphQLField" = FieldQueryCountGraphQLField("field")
    level: "FieldQueryCountGraphQLField" = FieldQueryCountGraphQLField("level")
    percentile: "FieldQueryCountGraphQLField" = FieldQueryCountGraphQLField(
        "percentile"
    )

    def fields(
        self, *subfields: FieldQueryCountGraphQLField
    ) -> "FieldQueryCountFields":
        """Subfields should come from the FieldQueryCountFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FieldQueryCountFields":
        self._alias = alias
        return self


class FieldQueryCountsFields(GraphQLField):
    @classmethod
    def last_7_days(cls) -> "FieldQueryCountFields":
        return FieldQueryCountFields("last_7_days")

    @classmethod
    def last_24_hours(cls) -> "FieldQueryCountFields":
        return FieldQueryCountFields("last_24_hours")

    @classmethod
    def last_30_days(cls) -> "FieldQueryCountFields":
        return FieldQueryCountFields("last_30_days")

    @classmethod
    def last_90_days(cls) -> "FieldQueryCountFields":
        return FieldQueryCountFields("last_90_days")

    @classmethod
    def last_365_days(cls) -> "FieldQueryCountFields":
        return FieldQueryCountFields("last_365_days")

    def fields(
        self, *subfields: Union[FieldQueryCountsGraphQLField, "FieldQueryCountFields"]
    ) -> "FieldQueryCountsFields":
        """Subfields should come from the FieldQueryCountsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FieldQueryCountsFields":
        self._alias = alias
        return self


class FieldStatisticsFields(GraphQLField):
    average: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField("average")
    distinct_value_count: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField(
        "distinctValueCount"
    )
    field_path: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField("fieldPath")
    max_value: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField("maxValue")
    min_value: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField("minValue")
    nonnull_value_count: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField(
        "nonnullValueCount"
    )
    null_value_count: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField(
        "nullValueCount"
    )
    std_dev: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField("stdDev")

    def fields(
        self, *subfields: FieldStatisticsGraphQLField
    ) -> "FieldStatisticsFields":
        """Subfields should come from the FieldStatisticsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FieldStatisticsFields":
        self._alias = alias
        return self


class FieldTagAssociationsFields(GraphQLField):
    field_path: "FieldTagAssociationsGraphQLField" = FieldTagAssociationsGraphQLField(
        "fieldPath"
    )

    @classmethod
    def governed_tags(cls) -> "UserDefinedResourceFields":
        return UserDefinedResourceFields("governed_tags")

    def fields(
        self,
        *subfields: Union[FieldTagAssociationsGraphQLField, "UserDefinedResourceFields"]
    ) -> "FieldTagAssociationsFields":
        """Subfields should come from the FieldTagAssociationsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FieldTagAssociationsFields":
        self._alias = alias
        return self


class FiveTranConnectorStatusFields(GraphQLField):
    setup_state: "FiveTranConnectorStatusGraphQLField" = (
        FiveTranConnectorStatusGraphQLField("setupState")
    )
    sync_state: "FiveTranConnectorStatusGraphQLField" = (
        FiveTranConnectorStatusGraphQLField("syncState")
    )
    update_state: "FiveTranConnectorStatusGraphQLField" = (
        FiveTranConnectorStatusGraphQLField("updateState")
    )

    def fields(
        self, *subfields: FiveTranConnectorStatusGraphQLField
    ) -> "FiveTranConnectorStatusFields":
        """Subfields should come from the FiveTranConnectorStatusFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FiveTranConnectorStatusFields":
        self._alias = alias
        return self


class FivetranPipelineFields(GraphQLField):
    config: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField("config")
    connector_logs_url: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "connectorLogsUrl"
    )
    connector_name: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "connectorName"
    )
    connector_type_id: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "connectorTypeId"
    )
    connector_type_name: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "connectorTypeName"
    )
    connector_url: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "connectorUrl"
    )
    created: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField("created")
    creator_email: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "creatorEmail"
    )
    icon_url: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField("iconUrl")
    last_succeeded: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "lastSucceeded"
    )
    paused: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField("paused")
    schema_metadata: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "schemaMetadata"
    )
    sources: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField("sources")

    @classmethod
    def status(cls) -> "FiveTranConnectorStatusFields":
        return FiveTranConnectorStatusFields("status")

    sync_interval_in_minute: "FivetranPipelineGraphQLField" = (
        FivetranPipelineGraphQLField("syncIntervalInMinute")
    )
    targets: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField("targets")

    def fields(
        self,
        *subfields: Union[FivetranPipelineGraphQLField, "FiveTranConnectorStatusFields"]
    ) -> "FivetranPipelineFields":
        """Subfields should come from the FivetranPipelineFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FivetranPipelineFields":
        self._alias = alias
        return self


class FollowOrUnfollowOutputFields(GraphQLField):
    @classmethod
    def followed_or_unfollowed(cls) -> "EntityInterface":
        return EntityInterface("followed_or_unfollowed")

    @classmethod
    def follower(cls) -> "PersonFields":
        return PersonFields("follower")

    def fields(
        self,
        *subfields: Union[
            FollowOrUnfollowOutputGraphQLField, "EntityInterface", "PersonFields"
        ]
    ) -> "FollowOrUnfollowOutputFields":
        """Subfields should come from the FollowOrUnfollowOutputFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FollowOrUnfollowOutputFields":
        self._alias = alias
        return self


class ForeignKeyFields(GraphQLField):
    field_path: "ForeignKeyGraphQLField" = ForeignKeyGraphQLField("fieldPath")

    @classmethod
    def parent(cls) -> "DatasetLogicalIdFields":
        return DatasetLogicalIdFields("parent")

    parent_field: "ForeignKeyGraphQLField" = ForeignKeyGraphQLField("parentField")

    def fields(
        self, *subfields: Union[ForeignKeyGraphQLField, "DatasetLogicalIdFields"]
    ) -> "ForeignKeyFields":
        """Subfields should come from the ForeignKeyFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ForeignKeyFields":
        self._alias = alias
        return self


class GeneratedAssetDescriptionFields(GraphQLField):
    description: "GeneratedAssetDescriptionGraphQLField" = (
        GeneratedAssetDescriptionGraphQLField("description")
    )
    entity_id: "GeneratedAssetDescriptionGraphQLField" = (
        GeneratedAssetDescriptionGraphQLField("entityId")
    )

    @classmethod
    def field_descriptions(cls) -> "GeneratedFieldDescriptionFields":
        return GeneratedFieldDescriptionFields("field_descriptions")

    table: "GeneratedAssetDescriptionGraphQLField" = (
        GeneratedAssetDescriptionGraphQLField("table")
    )

    def fields(
        self,
        *subfields: Union[
            GeneratedAssetDescriptionGraphQLField, "GeneratedFieldDescriptionFields"
        ]
    ) -> "GeneratedAssetDescriptionFields":
        """Subfields should come from the GeneratedAssetDescriptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GeneratedAssetDescriptionFields":
        self._alias = alias
        return self


class GeneratedFieldDescriptionFields(GraphQLField):
    field_description: "GeneratedFieldDescriptionGraphQLField" = (
        GeneratedFieldDescriptionGraphQLField("fieldDescription")
    )
    field_path: "GeneratedFieldDescriptionGraphQLField" = (
        GeneratedFieldDescriptionGraphQLField("fieldPath")
    )

    def fields(
        self, *subfields: GeneratedFieldDescriptionGraphQLField
    ) -> "GeneratedFieldDescriptionFields":
        """Subfields should come from the GeneratedFieldDescriptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GeneratedFieldDescriptionFields":
        self._alias = alias
        return self


class GoogleSocialLoginFields(GraphQLField):
    allowed_email_patterns: "GoogleSocialLoginGraphQLField" = (
        GoogleSocialLoginGraphQLField("allowedEmailPatterns")
    )

    def fields(
        self, *subfields: GoogleSocialLoginGraphQLField
    ) -> "GoogleSocialLoginFields":
        """Subfields should come from the GoogleSocialLoginFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GoogleSocialLoginFields":
        self._alias = alias
        return self


class GoogleWorkspaceSSOFields(GraphQLField):
    metadata_file: "GoogleWorkspaceSSOGraphQLField" = GoogleWorkspaceSSOGraphQLField(
        "metadataFile"
    )

    def fields(
        self, *subfields: GoogleWorkspaceSSOGraphQLField
    ) -> "GoogleWorkspaceSSOFields":
        """Subfields should come from the GoogleWorkspaceSSOFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GoogleWorkspaceSSOFields":
        self._alias = alias
        return self


class GovernedEntityInterface(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField("createdAt")
    deleted_at: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField("deletedAt")
    display_name: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField(
        "displayName"
    )
    entity_type: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField("id")
    is_deleted: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField("isDeleted")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    last_ingested_at: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField(
        "lastIngestedAt"
    )
    last_modified_at: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField(
        "lastModifiedAt"
    )

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            GovernedEntityGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "GovernedEntityInterface":
        """Subfields should come from the GovernedEntityInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GovernedEntityInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "GovernedEntityInterface":
        self._inline_fragments[type_name] = subfields
        return self


class GroupFields(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "GroupGraphQLField" = GroupGraphQLField("createdAt")
    deleted_at: "GroupGraphQLField" = GroupGraphQLField("deletedAt")
    display_name: "GroupGraphQLField" = GroupGraphQLField("displayName")
    entity_type: "GroupGraphQLField" = GroupGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def group_info(cls) -> "GroupInfoFields":
        return GroupInfoFields("group_info")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "GroupGraphQLField" = GroupGraphQLField("id")
    is_deleted: "GroupGraphQLField" = GroupGraphQLField("isDeleted")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    last_ingested_at: "GroupGraphQLField" = GroupGraphQLField("lastIngestedAt")
    last_modified_at: "GroupGraphQLField" = GroupGraphQLField("lastModifiedAt")

    @classmethod
    def logical_id(cls) -> "GroupLogicalIdFields":
        return GroupLogicalIdFields("logical_id")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            GroupGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "GroupInfoFields",
            "GroupLogicalIdFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "GroupFields":
        """Subfields should come from the GroupFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupFields":
        self._alias = alias
        return self


class GroupBaseInterface(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "GroupBaseGraphQLField" = GroupBaseGraphQLField("createdAt")
    deleted_at: "GroupBaseGraphQLField" = GroupBaseGraphQLField("deletedAt")
    display_name: "GroupBaseGraphQLField" = GroupBaseGraphQLField("displayName")
    entity_type: "GroupBaseGraphQLField" = GroupBaseGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "GroupBaseGraphQLField" = GroupBaseGraphQLField("id")
    is_deleted: "GroupBaseGraphQLField" = GroupBaseGraphQLField("isDeleted")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    last_ingested_at: "GroupBaseGraphQLField" = GroupBaseGraphQLField("lastIngestedAt")
    last_modified_at: "GroupBaseGraphQLField" = GroupBaseGraphQLField("lastModifiedAt")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            GroupBaseGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "GroupBaseInterface":
        """Subfields should come from the GroupBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupBaseInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "GroupBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class GroupConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "GroupEdgeFields":
        return GroupEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "GroupConnectionGraphQLField" = GroupConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            GroupConnectionGraphQLField, "GroupEdgeFields", "PageInfoFields"
        ]
    ) -> "GroupConnectionFields":
        """Subfields should come from the GroupConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupConnectionFields":
        self._alias = alias
        return self


class GroupDescriptionFields(GraphQLField):
    text: "GroupDescriptionGraphQLField" = GroupDescriptionGraphQLField("text")
    tokenized_text: "GroupDescriptionGraphQLField" = GroupDescriptionGraphQLField(
        "tokenizedText"
    )

    def fields(
        self, *subfields: GroupDescriptionGraphQLField
    ) -> "GroupDescriptionFields":
        """Subfields should come from the GroupDescriptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupDescriptionFields":
        self._alias = alias
        return self


class GroupEdgeFields(GraphQLField):
    cursor: "GroupEdgeGraphQLField" = GroupEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "GroupFields":
        return GroupFields("node")

    def fields(
        self, *subfields: Union[GroupEdgeGraphQLField, "GroupFields"]
    ) -> "GroupEdgeFields":
        """Subfields should come from the GroupEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupEdgeFields":
        self._alias = alias
        return self


class GroupInfoFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "GroupInfoGraphQLField" = GroupInfoGraphQLField("createdAt")

    @classmethod
    def description(cls) -> "GroupDescriptionFields":
        return GroupDescriptionFields("description")

    email: "GroupInfoGraphQLField" = GroupInfoGraphQLField("email")
    entity_id: "GroupInfoGraphQLField" = GroupInfoGraphQLField("entityId")
    external_id: "GroupInfoGraphQLField" = GroupInfoGraphQLField("externalId")

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    managed_by: "GroupInfoGraphQLField" = GroupInfoGraphQLField("managedBy")
    members: "GroupInfoGraphQLField" = GroupInfoGraphQLField("members")

    @classmethod
    def members_connection(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[PersonConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "PersonConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("members_connection", arguments=cleared_arguments)

    name: "GroupInfoGraphQLField" = GroupInfoGraphQLField("name")
    subgroups: "GroupInfoGraphQLField" = GroupInfoGraphQLField("subgroups")

    def fields(
        self,
        *subfields: Union[
            GroupInfoGraphQLField,
            "AuditStampFields",
            "GroupDescriptionFields",
            "PersonConnectionFields",
        ]
    ) -> "GroupInfoFields":
        """Subfields should come from the GroupInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupInfoFields":
        self._alias = alias
        return self


class GroupInfoBaseInterface(GraphQLField):
    created_at: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("createdAt")

    @classmethod
    def description(cls) -> "GroupDescriptionFields":
        return GroupDescriptionFields("description")

    email: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("email")
    entity_id: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("entityId")
    external_id: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("externalId")
    managed_by: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("managedBy")
    members: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("members")
    name: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("name")
    subgroups: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("subgroups")

    def fields(
        self, *subfields: Union[GroupInfoBaseGraphQLField, "GroupDescriptionFields"]
    ) -> "GroupInfoBaseInterface":
        """Subfields should come from the GroupInfoBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupInfoBaseInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "GroupInfoBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class GroupLogicalIdFields(GraphQLField):
    id: "GroupLogicalIdGraphQLField" = GroupLogicalIdGraphQLField("id")

    def fields(self, *subfields: GroupLogicalIdGraphQLField) -> "GroupLogicalIdFields":
        """Subfields should come from the GroupLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupLogicalIdFields":
        self._alias = alias
        return self


class HashtagFields(GraphQLField):
    value: "HashtagGraphQLField" = HashtagGraphQLField("value")

    def fields(self, *subfields: HashtagGraphQLField) -> "HashtagFields":
        """Subfields should come from the HashtagFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "HashtagFields":
        self._alias = alias
        return self


class HierarchyFields(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def asset_contacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("asset_contacts")

    @classmethod
    def asset_count_by_type(cls) -> "AssetDocumentAggregationBucketFields":
        return AssetDocumentAggregationBucketFields("asset_count_by_type")

    @classmethod
    def assets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetsConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "AssetConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetsConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return AssetConnectionFields("assets", arguments=cleared_arguments)

    associated_entity_type: "HierarchyGraphQLField" = HierarchyGraphQLField(
        "associatedEntityType"
    )
    associated_search_index: "HierarchyGraphQLField" = HierarchyGraphQLField(
        "associatedSearchIndex"
    )

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    @classmethod
    def children(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "HierarchyConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return HierarchyConnectionFields("children", arguments=cleared_arguments)

    created_at: "HierarchyGraphQLField" = HierarchyGraphQLField("createdAt")
    deleted_at: "HierarchyGraphQLField" = HierarchyGraphQLField("deletedAt")

    @classmethod
    def descriptions(cls) -> "DerivedAssetDescriptionsFields":
        return DerivedAssetDescriptionsFields("descriptions")

    display_name: "HierarchyGraphQLField" = HierarchyGraphQLField("displayName")
    entity_type: "HierarchyGraphQLField" = HierarchyGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def governed_tags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governed_tags", arguments=cleared_arguments
        )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    @classmethod
    def hierarchy_info(cls) -> "HierarchyInfoFields":
        return HierarchyInfoFields("hierarchy_info")

    id: "HierarchyGraphQLField" = HierarchyGraphQLField("id")

    @classmethod
    def interested_parties(cls) -> "InterestedPartyFields":
        return InterestedPartyFields("interested_parties")

    is_deleted: "HierarchyGraphQLField" = HierarchyGraphQLField("isDeleted")
    is_hidden: "HierarchyGraphQLField" = HierarchyGraphQLField("isHidden")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledge_cards(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledge_cards", arguments=cleared_arguments
        )

    @classmethod
    def labels(cls) -> "AnchorEntityLabelFields":
        return AnchorEntityLabelFields("labels")

    last_ingested_at: "HierarchyGraphQLField" = HierarchyGraphQLField("lastIngestedAt")
    last_modified_at: "HierarchyGraphQLField" = HierarchyGraphQLField("lastModifiedAt")

    @classmethod
    def logical_id(cls) -> "HierarchyLogicalIdFields":
        return HierarchyLogicalIdFields("logical_id")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def recent_user_activities(
        cls, *, input: Optional[RecentUserActivitiesFilterInput] = None
    ) -> "RecentUserActivitiesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "RecentUserActivitiesFilterInput", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return RecentUserActivitiesFields(
            "recent_user_activities", arguments=cleared_arguments
        )

    @classmethod
    def recently_viewed_by(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "ViewedByConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewedByConnectionFields(
            "recently_viewed_by", arguments=cleared_arguments
        )

    @classmethod
    def system_description(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("system_description")

    @classmethod
    def system_tags(cls) -> "SystemTagsFields":
        return SystemTagsFields("system_tags")

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    @classmethod
    def top_knowledge_card_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(
            "top_knowledge_card_authors", arguments=cleared_arguments
        )

    viewer_can_assign_asset_contacts: "HierarchyGraphQLField" = HierarchyGraphQLField(
        "viewerCanAssignAssetContacts"
    )
    viewer_has_pinned: "HierarchyGraphQLField" = HierarchyGraphQLField(
        "viewerHasPinned"
    )

    def fields(
        self,
        *subfields: Union[
            HierarchyGraphQLField,
            "AggregationMetadataFields",
            "AnchorEntityLabelFields",
            "AssetConnectionFields",
            "AssetContactsFields",
            "AssetDocumentAggregationBucketFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "DerivedAssetDescriptionsFields",
            "HashtagFields",
            "HierarchyConnectionFields",
            "HierarchyInfoFields",
            "HierarchyLogicalIdFields",
            "InterestedPartyFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "RecentUserActivitiesFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
            "UserDefinedResourceConnectionFields",
            "ViewedByConnectionFields",
        ]
    ) -> "HierarchyFields":
        """Subfields should come from the HierarchyFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "HierarchyFields":
        self._alias = alias
        return self


class HierarchyConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "HierarchyEdgeFields":
        return HierarchyEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "HierarchyConnectionGraphQLField" = HierarchyConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            HierarchyConnectionGraphQLField, "HierarchyEdgeFields", "PageInfoFields"
        ]
    ) -> "HierarchyConnectionFields":
        """Subfields should come from the HierarchyConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "HierarchyConnectionFields":
        self._alias = alias
        return self


class HierarchyEdgeFields(GraphQLField):
    cursor: "HierarchyEdgeGraphQLField" = HierarchyEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "HierarchyFields":
        return HierarchyFields("node")

    def fields(
        self, *subfields: Union[HierarchyEdgeGraphQLField, "HierarchyFields"]
    ) -> "HierarchyEdgeFields":
        """Subfields should come from the HierarchyEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "HierarchyEdgeFields":
        self._alias = alias
        return self


class HierarchyInfoFields(GraphQLField):
    created_at: "HierarchyInfoGraphQLField" = HierarchyInfoGraphQLField("createdAt")
    description: "HierarchyInfoGraphQLField" = HierarchyInfoGraphQLField("description")
    entity_id: "HierarchyInfoGraphQLField" = HierarchyInfoGraphQLField("entityId")

    @classmethod
    def metabase_collection(cls) -> "MetabaseCollectionFields":
        return MetabaseCollectionFields("metabase_collection")

    name: "HierarchyInfoGraphQLField" = HierarchyInfoGraphQLField("name")

    @classmethod
    def power_bi_workspace(cls) -> "PowerBiWorkspaceFields":
        return PowerBiWorkspaceFields("power_bi_workspace")

    type: "HierarchyInfoGraphQLField" = HierarchyInfoGraphQLField("type")

    def fields(
        self,
        *subfields: Union[
            HierarchyInfoGraphQLField,
            "MetabaseCollectionFields",
            "PowerBiWorkspaceFields",
        ]
    ) -> "HierarchyInfoFields":
        """Subfields should come from the HierarchyInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "HierarchyInfoFields":
        self._alias = alias
        return self


class HierarchyLogicalIdFields(GraphQLField):
    path: "HierarchyLogicalIdGraphQLField" = HierarchyLogicalIdGraphQLField("path")

    def fields(
        self, *subfields: HierarchyLogicalIdGraphQLField
    ) -> "HierarchyLogicalIdFields":
        """Subfields should come from the HierarchyLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "HierarchyLogicalIdFields":
        self._alias = alias
        return self


class HowToUseTokenizedContentFields(GraphQLField):
    detail: "HowToUseTokenizedContentGraphQLField" = (
        HowToUseTokenizedContentGraphQLField("detail")
    )

    def fields(
        self, *subfields: HowToUseTokenizedContentGraphQLField
    ) -> "HowToUseTokenizedContentFields":
        """Subfields should come from the HowToUseTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "HowToUseTokenizedContentFields":
        self._alias = alias
        return self


class IncidentKnowledgeCardFields(GraphQLField):
    detail: "IncidentKnowledgeCardGraphQLField" = IncidentKnowledgeCardGraphQLField(
        "detail"
    )
    title: "IncidentKnowledgeCardGraphQLField" = IncidentKnowledgeCardGraphQLField(
        "title"
    )

    @classmethod
    def tokenized_content(cls) -> "IncidentTokenizedContentFields":
        return IncidentTokenizedContentFields("tokenized_content")

    def fields(
        self,
        *subfields: Union[
            IncidentKnowledgeCardGraphQLField, "IncidentTokenizedContentFields"
        ]
    ) -> "IncidentKnowledgeCardFields":
        """Subfields should come from the IncidentKnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "IncidentKnowledgeCardFields":
        self._alias = alias
        return self


class IncidentTokenizedContentFields(GraphQLField):
    detail: "IncidentTokenizedContentGraphQLField" = (
        IncidentTokenizedContentGraphQLField("detail")
    )

    def fields(
        self, *subfields: IncidentTokenizedContentGraphQLField
    ) -> "IncidentTokenizedContentFields":
        """Subfields should come from the IncidentTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "IncidentTokenizedContentFields":
        self._alias = alias
        return self


class InformaticaMappingFields(GraphQLField):
    description: "InformaticaMappingGraphQLField" = InformaticaMappingGraphQLField(
        "description"
    )
    name: "InformaticaMappingGraphQLField" = InformaticaMappingGraphQLField("name")

    def fields(
        self, *subfields: InformaticaMappingGraphQLField
    ) -> "InformaticaMappingFields":
        """Subfields should come from the InformaticaMappingFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "InformaticaMappingFields":
        self._alias = alias
        return self


class IntegrationsFields(GraphQLField):
    installed_teams_tenants: "IntegrationsGraphQLField" = IntegrationsGraphQLField(
        "installedTeamsTenants"
    )

    def fields(self, *subfields: IntegrationsGraphQLField) -> "IntegrationsFields":
        """Subfields should come from the IntegrationsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "IntegrationsFields":
        self._alias = alias
        return self


class InterestedPartyFields(GraphQLField):
    external_email: "InterestedPartyGraphQLField" = InterestedPartyGraphQLField(
        "externalEmail"
    )

    @classmethod
    def person(cls) -> "PersonFields":
        return PersonFields("person")

    source: "InterestedPartyGraphQLField" = InterestedPartyGraphQLField("source")

    def fields(
        self, *subfields: Union[InterestedPartyGraphQLField, "PersonFields"]
    ) -> "InterestedPartyFields":
        """Subfields should come from the InterestedPartyFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "InterestedPartyFields":
        self._alias = alias
        return self


class KeyValuePairFields(GraphQLField):
    key: "KeyValuePairGraphQLField" = KeyValuePairGraphQLField("key")
    value: "KeyValuePairGraphQLField" = KeyValuePairGraphQLField("value")

    def fields(self, *subfields: KeyValuePairGraphQLField) -> "KeyValuePairFields":
        """Subfields should come from the KeyValuePairFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KeyValuePairFields":
        self._alias = alias
        return self


class KnowledgeCardFields(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def asset_contacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("asset_contacts")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField("createdAt")
    deleted_at: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField("deletedAt")
    display_name: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField("displayName")
    entity_type: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def governed_tags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governed_tags", arguments=cleared_arguments
        )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField("id")
    is_deleted: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField("isDeleted")
    is_viewer_author: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "isViewerAuthor"
    )

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledge_card_info(cls) -> "KnowledgeCardInfoFields":
        return KnowledgeCardInfoFields("knowledge_card_info")

    @classmethod
    def knowledge_cards(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledge_cards", arguments=cleared_arguments
        )

    last_ingested_at: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "lastIngestedAt"
    )

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    last_modified_at: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "lastModifiedAt"
    )

    @classmethod
    def likes(cls) -> "AssetLikesFields":
        return AssetLikesFields("likes")

    @classmethod
    def logical_id(cls) -> "KnowledgeCardLogicalIdFields":
        return KnowledgeCardLogicalIdFields("logical_id")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def recently_viewed_by(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "ViewedByConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewedByConnectionFields(
            "recently_viewed_by", arguments=cleared_arguments
        )

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    viewer_can_acknowledge: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "viewerCanAcknowledge"
    )
    viewer_can_assign_asset_contacts: "KnowledgeCardGraphQLField" = (
        KnowledgeCardGraphQLField("viewerCanAssignAssetContacts")
    )
    viewer_can_curate_query: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "viewerCanCurateQuery"
    )
    viewer_can_delete: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "viewerCanDelete"
    )
    viewer_can_edit: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "viewerCanEdit"
    )
    viewer_can_like: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "viewerCanLike"
    )
    viewer_can_update_change_request_status: "KnowledgeCardGraphQLField" = (
        KnowledgeCardGraphQLField("viewerCanUpdateChangeRequestStatus")
    )
    viewer_has_pinned: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "viewerHasPinned"
    )

    def fields(
        self,
        *subfields: Union[
            KnowledgeCardGraphQLField,
            "AggregationMetadataFields",
            "AssetContactsFields",
            "AssetFollowersFields",
            "AssetLikesFields",
            "AuditStampFields",
            "BrowsePathFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "KnowledgeCardInfoFields",
            "KnowledgeCardLogicalIdFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "UserDefinedResourceConnectionFields",
            "ViewedByConnectionFields",
        ]
    ) -> "KnowledgeCardFields":
        """Subfields should come from the KnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardFields":
        self._alias = alias
        return self


class KnowledgeCardBaseInterface(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField(
        "createdAt"
    )
    deleted_at: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField(
        "deletedAt"
    )
    display_name: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField(
        "displayName"
    )
    entity_type: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField(
        "entityType"
    )

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField("id")
    is_deleted: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField(
        "isDeleted"
    )

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    last_ingested_at: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField(
        "lastIngestedAt"
    )
    last_modified_at: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField(
        "lastModifiedAt"
    )

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            KnowledgeCardBaseGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "KnowledgeCardBaseInterface":
        """Subfields should come from the KnowledgeCardBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "KnowledgeCardBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class KnowledgeCardConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "KnowledgeCardEdgeFields":
        return KnowledgeCardEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "KnowledgeCardConnectionGraphQLField" = (
        KnowledgeCardConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            KnowledgeCardConnectionGraphQLField,
            "KnowledgeCardEdgeFields",
            "PageInfoFields",
        ]
    ) -> "KnowledgeCardConnectionFields":
        """Subfields should come from the KnowledgeCardConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardConnectionFields":
        self._alias = alias
        return self


class KnowledgeCardDeletePayloadFields(GraphQLField):
    deleted_ids: "KnowledgeCardDeletePayloadGraphQLField" = (
        KnowledgeCardDeletePayloadGraphQLField("deletedIds")
    )
    failed_ids: "KnowledgeCardDeletePayloadGraphQLField" = (
        KnowledgeCardDeletePayloadGraphQLField("failedIds")
    )

    def fields(
        self, *subfields: KnowledgeCardDeletePayloadGraphQLField
    ) -> "KnowledgeCardDeletePayloadFields":
        """Subfields should come from the KnowledgeCardDeletePayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardDeletePayloadFields":
        self._alias = alias
        return self


class KnowledgeCardDetailFields(GraphQLField):
    @classmethod
    def asset_description(cls) -> "AssetDescriptionKnowledgeCardFields":
        return AssetDescriptionKnowledgeCardFields("asset_description")

    @classmethod
    def change_request(cls) -> "ChangeRequestKnowledgeCardFields":
        return ChangeRequestKnowledgeCardFields("change_request")

    @classmethod
    def column_description(cls) -> "ColumnDescriptionKnowledgeCardFields":
        return ColumnDescriptionKnowledgeCardFields("column_description")

    @classmethod
    def comment(cls) -> "CommentFields":
        return CommentFields("comment")

    @classmethod
    def data_document(cls) -> "DataDocumentFields":
        return DataDocumentFields("data_document")

    @classmethod
    def deprecation(cls) -> "DeprecationKnowledgeCardFields":
        return DeprecationKnowledgeCardFields("deprecation")

    @classmethod
    def incident(cls) -> "IncidentKnowledgeCardFields":
        return IncidentKnowledgeCardFields("incident")

    @classmethod
    def query(cls) -> "QueryKnowledgeCardFields":
        return QueryKnowledgeCardFields("query")

    type: "KnowledgeCardDetailGraphQLField" = KnowledgeCardDetailGraphQLField("type")

    @classmethod
    def usage(cls) -> "UsageKnowledgeCardFields":
        return UsageKnowledgeCardFields("usage")

    def fields(
        self,
        *subfields: Union[
            KnowledgeCardDetailGraphQLField,
            "AssetDescriptionKnowledgeCardFields",
            "ChangeRequestKnowledgeCardFields",
            "ColumnDescriptionKnowledgeCardFields",
            "CommentFields",
            "DataDocumentFields",
            "DeprecationKnowledgeCardFields",
            "IncidentKnowledgeCardFields",
            "QueryKnowledgeCardFields",
            "UsageKnowledgeCardFields",
        ]
    ) -> "KnowledgeCardDetailFields":
        """Subfields should come from the KnowledgeCardDetailFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardDetailFields":
        self._alias = alias
        return self


class KnowledgeCardEdgeFields(GraphQLField):
    cursor: "KnowledgeCardEdgeGraphQLField" = KnowledgeCardEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "KnowledgeCardFields":
        return KnowledgeCardFields("node")

    def fields(
        self, *subfields: Union[KnowledgeCardEdgeGraphQLField, "KnowledgeCardFields"]
    ) -> "KnowledgeCardEdgeFields":
        """Subfields should come from the KnowledgeCardEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardEdgeFields":
        self._alias = alias
        return self


class KnowledgeCardHighlightFields(GraphQLField):
    author_display_name: "KnowledgeCardHighlightGraphQLField" = (
        KnowledgeCardHighlightGraphQLField("authorDisplayName")
    )
    contact_display_names: "KnowledgeCardHighlightGraphQLField" = (
        KnowledgeCardHighlightGraphQLField("contactDisplayNames")
    )
    content: "KnowledgeCardHighlightGraphQLField" = KnowledgeCardHighlightGraphQLField(
        "content"
    )
    governed_tags: "KnowledgeCardHighlightGraphQLField" = (
        KnowledgeCardHighlightGraphQLField("governedTags")
    )
    hashtags: "KnowledgeCardHighlightGraphQLField" = KnowledgeCardHighlightGraphQLField(
        "hashtags"
    )
    name: "KnowledgeCardHighlightGraphQLField" = KnowledgeCardHighlightGraphQLField(
        "name"
    )

    def fields(
        self, *subfields: KnowledgeCardHighlightGraphQLField
    ) -> "KnowledgeCardHighlightFields":
        """Subfields should come from the KnowledgeCardHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardHighlightFields":
        self._alias = alias
        return self


class KnowledgeCardInfoFields(GraphQLField):
    @classmethod
    def anchor_entity(cls) -> "EntityInterface":
        return EntityInterface("anchor_entity")

    @classmethod
    def archived(cls) -> "AuditStampFields":
        return AuditStampFields("archived")

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "KnowledgeCardInfoGraphQLField" = KnowledgeCardInfoGraphQLField(
        "createdAt"
    )

    @classmethod
    def detail(cls) -> "KnowledgeCardDetailFields":
        return KnowledgeCardDetailFields("detail")

    entity_id: "KnowledgeCardInfoGraphQLField" = KnowledgeCardInfoGraphQLField(
        "entityId"
    )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    protected: "KnowledgeCardInfoGraphQLField" = KnowledgeCardInfoGraphQLField(
        "protected"
    )

    @classmethod
    def published(cls) -> "AuditStampFields":
        return AuditStampFields("published")

    @classmethod
    def related_assets_of_type(
        cls,
        type: EntityType,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "type": {"type": "EntityType!", "value": type},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields(
            "related_assets_of_type", arguments=cleared_arguments
        )

    related_entity_ids: "KnowledgeCardInfoGraphQLField" = KnowledgeCardInfoGraphQLField(
        "relatedEntityIds"
    )

    @classmethod
    def related_ids_of_type(cls, type: EntityType) -> "KnowledgeCardInfoGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "EntityType!", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardInfoGraphQLField(
            "related_ids_of_type", arguments=cleared_arguments
        )

    status: "KnowledgeCardInfoGraphQLField" = KnowledgeCardInfoGraphQLField("status")

    def fields(
        self,
        *subfields: Union[
            KnowledgeCardInfoGraphQLField,
            "AuditStampFields",
            "EntityConnectionFields",
            "EntityInterface",
            "HashtagFields",
            "KnowledgeCardDetailFields",
        ]
    ) -> "KnowledgeCardInfoFields":
        """Subfields should come from the KnowledgeCardInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardInfoFields":
        self._alias = alias
        return self


class KnowledgeCardInfoBaseInterface(GraphQLField):
    created_at: "KnowledgeCardInfoBaseGraphQLField" = KnowledgeCardInfoBaseGraphQLField(
        "createdAt"
    )
    entity_id: "KnowledgeCardInfoBaseGraphQLField" = KnowledgeCardInfoBaseGraphQLField(
        "entityId"
    )
    related_entity_ids: "KnowledgeCardInfoBaseGraphQLField" = (
        KnowledgeCardInfoBaseGraphQLField("relatedEntityIds")
    )

    def fields(
        self, *subfields: KnowledgeCardInfoBaseGraphQLField
    ) -> "KnowledgeCardInfoBaseInterface":
        """Subfields should come from the KnowledgeCardInfoBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardInfoBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "KnowledgeCardInfoBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class KnowledgeCardInfoOutputInterface(GraphQLField):
    @classmethod
    def archived(cls) -> "AuditStampFields":
        return AuditStampFields("archived")

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "KnowledgeCardInfoOutputGraphQLField" = (
        KnowledgeCardInfoOutputGraphQLField("createdAt")
    )
    entity_id: "KnowledgeCardInfoOutputGraphQLField" = (
        KnowledgeCardInfoOutputGraphQLField("entityId")
    )

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    protected: "KnowledgeCardInfoOutputGraphQLField" = (
        KnowledgeCardInfoOutputGraphQLField("protected")
    )

    @classmethod
    def published(cls) -> "AuditStampFields":
        return AuditStampFields("published")

    related_entity_ids: "KnowledgeCardInfoOutputGraphQLField" = (
        KnowledgeCardInfoOutputGraphQLField("relatedEntityIds")
    )

    @classmethod
    def related_ids_of_type(
        cls, type: EntityType
    ) -> "KnowledgeCardInfoOutputGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "EntityType!", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardInfoOutputGraphQLField(
            "related_ids_of_type", arguments=cleared_arguments
        )

    status: "KnowledgeCardInfoOutputGraphQLField" = KnowledgeCardInfoOutputGraphQLField(
        "status"
    )

    def fields(
        self, *subfields: Union[KnowledgeCardInfoOutputGraphQLField, "AuditStampFields"]
    ) -> "KnowledgeCardInfoOutputInterface":
        """Subfields should come from the KnowledgeCardInfoOutputInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardInfoOutputInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "KnowledgeCardInfoOutputInterface":
        self._inline_fragments[type_name] = subfields
        return self


class KnowledgeCardLogicalIdFields(GraphQLField):
    id: "KnowledgeCardLogicalIdGraphQLField" = KnowledgeCardLogicalIdGraphQLField("id")

    def fields(
        self, *subfields: KnowledgeCardLogicalIdGraphQLField
    ) -> "KnowledgeCardLogicalIdFields":
        """Subfields should come from the KnowledgeCardLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardLogicalIdFields":
        self._alias = alias
        return self


class KnowledgeCardSearchDocumentFields(GraphQLField):
    anchor_entity_id: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("anchorEntityId")
    )
    anchor_entity_type: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("anchorEntityType")
    )
    author: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("author")
    )
    author_display_name: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("authorDisplayName")
    )
    browse_path_hierarchy: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browse_path_segments: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    contact_display_names: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("contactDisplayNames")
    )
    content: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("content")
    )
    created_at: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("createdAt")
    )
    directory: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("directory")
    )
    document_id: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("documentId")
    )
    domain_display_names: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("domainDisplayNames")
    )
    domains: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("domains")
    )
    embedded_string_1: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("embeddedString_1")
    )
    embedded_string_2: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("embeddedString_2")
    )
    entity_id: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("entityId")
    )
    governed_tags: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("governedTags")
    )
    hashtags: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("hashtags")
    )

    @classmethod
    def highlight(cls) -> "KnowledgeCardHighlightFields":
        return KnowledgeCardHighlightFields("highlight")

    is_archived: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("isArchived")
    )
    is_deleted: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("isDeleted")
    )
    is_draft: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("isDraft")
    )
    last_refreshed: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("lastRefreshed")
    )
    name: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("name")
    )
    pagination_token: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("paginationToken")
    )

    @classmethod
    def score_details(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("score_details")

    type: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("type")
    )
    view_count: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("viewCount")
    )

    def fields(
        self,
        *subfields: Union[
            KnowledgeCardSearchDocumentGraphQLField,
            "BrowsePathFields",
            "KnowledgeCardHighlightFields",
            "SearchScoreDetailsFields",
        ]
    ) -> "KnowledgeCardSearchDocumentFields":
        """Subfields should come from the KnowledgeCardSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardSearchDocumentFields":
        self._alias = alias
        return self


class KnowledgeCardSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "KnowledgeCardSearchDocumentFields":
        return KnowledgeCardSearchDocumentFields("documents")

    error_message: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("errorMessage")
    )
    from_: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("from")
    )
    has_more: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("paginationToken")
    )
    search_context: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("searchContext")
    )
    search_index: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("searchIndex")
    )
    size: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("size")
    )
    total_count: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            KnowledgeCardSearchResultGraphQLField,
            "AggregationMetadataFields",
            "KnowledgeCardSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "KnowledgeCardSearchResultFields":
        """Subfields should come from the KnowledgeCardSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardSearchResultFields":
        self._alias = alias
        return self


class LDAPFields(GraphQLField):
    bind_dn: "LDAPGraphQLField" = LDAPGraphQLField("bindDN")
    bind_password: "LDAPGraphQLField" = LDAPGraphQLField("bindPassword")

    @classmethod
    def group_search(cls) -> "LDAPGroupSearchFields":
        return LDAPGroupSearchFields("group_search")

    host: "LDAPGraphQLField" = LDAPGraphQLField("host")

    @classmethod
    def user_search(cls) -> "LDAPUserSearchFields":
        return LDAPUserSearchFields("user_search")

    def fields(
        self,
        *subfields: Union[
            LDAPGraphQLField, "LDAPGroupSearchFields", "LDAPUserSearchFields"
        ]
    ) -> "LDAPFields":
        """Subfields should come from the LDAPFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LDAPFields":
        self._alias = alias
        return self


class LDAPGroupSearchFields(GraphQLField):
    base_dn: "LDAPGroupSearchGraphQLField" = LDAPGroupSearchGraphQLField("baseDN")
    filter: "LDAPGroupSearchGraphQLField" = LDAPGroupSearchGraphQLField("filter")
    name_attr: "LDAPGroupSearchGraphQLField" = LDAPGroupSearchGraphQLField("nameAttr")

    def fields(
        self, *subfields: LDAPGroupSearchGraphQLField
    ) -> "LDAPGroupSearchFields":
        """Subfields should come from the LDAPGroupSearchFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LDAPGroupSearchFields":
        self._alias = alias
        return self


class LDAPUserSearchFields(GraphQLField):
    base_dn: "LDAPUserSearchGraphQLField" = LDAPUserSearchGraphQLField("baseDN")
    email_attr: "LDAPUserSearchGraphQLField" = LDAPUserSearchGraphQLField("emailAttr")
    filter: "LDAPUserSearchGraphQLField" = LDAPUserSearchGraphQLField("filter")
    id_attr: "LDAPUserSearchGraphQLField" = LDAPUserSearchGraphQLField("idAttr")
    name_attr: "LDAPUserSearchGraphQLField" = LDAPUserSearchGraphQLField("nameAttr")
    username: "LDAPUserSearchGraphQLField" = LDAPUserSearchGraphQLField("username")

    def fields(self, *subfields: LDAPUserSearchGraphQLField) -> "LDAPUserSearchFields":
        """Subfields should come from the LDAPUserSearchFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LDAPUserSearchFields":
        self._alias = alias
        return self


class LinkedInSocialLoginFields(GraphQLField):
    auth_0_client_id: "LinkedInSocialLoginGraphQLField" = (
        LinkedInSocialLoginGraphQLField("auth0ClientId")
    )
    auth_0_client_secret: "LinkedInSocialLoginGraphQLField" = (
        LinkedInSocialLoginGraphQLField("auth0ClientSecret")
    )
    auth_0_issuer: "LinkedInSocialLoginGraphQLField" = LinkedInSocialLoginGraphQLField(
        "auth0Issuer"
    )

    def fields(
        self, *subfields: LinkedInSocialLoginGraphQLField
    ) -> "LinkedInSocialLoginFields":
        """Subfields should come from the LinkedInSocialLoginFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LinkedInSocialLoginFields":
        self._alias = alias
        return self


class LookerExploreFields(GraphQLField):
    @classmethod
    def base_view(cls) -> "VirtualViewFields":
        return VirtualViewFields("base_view")

    created_at: "LookerExploreGraphQLField" = LookerExploreGraphQLField("createdAt")
    description: "LookerExploreGraphQLField" = LookerExploreGraphQLField("description")

    @classmethod
    def downstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstream_of_type", arguments=cleared_arguments
        )

    entity_id: "LookerExploreGraphQLField" = LookerExploreGraphQLField("entityId")
    extends: "LookerExploreGraphQLField" = LookerExploreGraphQLField("extends")
    fields: "LookerExploreGraphQLField" = LookerExploreGraphQLField("fields")

    @classmethod
    def filters(cls) -> "LookerExploreFilterFields":
        return LookerExploreFilterFields("filters")

    @classmethod
    def joins(cls) -> "LookerExploreJoinFields":
        return LookerExploreJoinFields("joins")

    label: "LookerExploreGraphQLField" = LookerExploreGraphQLField("label")
    model_name: "LookerExploreGraphQLField" = LookerExploreGraphQLField("modelName")

    @classmethod
    def upstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstream_of_type", arguments=cleared_arguments
        )

    url: "LookerExploreGraphQLField" = LookerExploreGraphQLField("url")

    def fields(
        self,
        *subfields: Union[
            LookerExploreGraphQLField,
            "EntityLineageConnectionFields",
            "LookerExploreFilterFields",
            "LookerExploreJoinFields",
            "VirtualViewFields",
        ]
    ) -> "LookerExploreFields":
        """Subfields should come from the LookerExploreFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerExploreFields":
        self._alias = alias
        return self


class LookerExploreFilterFields(GraphQLField):
    allowed_values: "LookerExploreFilterGraphQLField" = LookerExploreFilterGraphQLField(
        "allowedValues"
    )
    field: "LookerExploreFilterGraphQLField" = LookerExploreFilterGraphQLField("field")

    def fields(
        self, *subfields: LookerExploreFilterGraphQLField
    ) -> "LookerExploreFilterFields":
        """Subfields should come from the LookerExploreFilterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerExploreFilterFields":
        self._alias = alias
        return self


class LookerExploreJoinFields(GraphQLField):
    fields: "LookerExploreJoinGraphQLField" = LookerExploreJoinGraphQLField("fields")
    on_clause: "LookerExploreJoinGraphQLField" = LookerExploreJoinGraphQLField(
        "onClause"
    )
    relationship: "LookerExploreJoinGraphQLField" = LookerExploreJoinGraphQLField(
        "relationship"
    )
    type: "LookerExploreJoinGraphQLField" = LookerExploreJoinGraphQLField("type")

    @classmethod
    def view(cls) -> "VirtualViewFields":
        return VirtualViewFields("view")

    where_clause: "LookerExploreJoinGraphQLField" = LookerExploreJoinGraphQLField(
        "whereClause"
    )

    def fields(
        self, *subfields: Union[LookerExploreJoinGraphQLField, "VirtualViewFields"]
    ) -> "LookerExploreJoinFields":
        """Subfields should come from the LookerExploreJoinFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerExploreJoinFields":
        self._alias = alias
        return self


class LookerExploreSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "VirtualViewSearchDocumentFields":
        return VirtualViewSearchDocumentFields("documents")

    error_message: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("errorMessage")
    )
    from_: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("from")
    )
    has_more: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("paginationToken")
    )
    search_context: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("searchContext")
    )
    search_index: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("searchIndex")
    )
    size: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("size")
    )
    total_count: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            LookerExploreSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "VirtualViewSearchDocumentFields",
        ]
    ) -> "LookerExploreSearchResultFields":
        """Subfields should come from the LookerExploreSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerExploreSearchResultFields":
        self._alias = alias
        return self


class LookerViewFields(GraphQLField):
    created_at: "LookerViewGraphQLField" = LookerViewGraphQLField("createdAt")

    @classmethod
    def dimensions(cls) -> "LookerViewDimensionFields":
        return LookerViewDimensionFields("dimensions")

    @classmethod
    def downstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstream_of_type", arguments=cleared_arguments
        )

    entity_id: "LookerViewGraphQLField" = LookerViewGraphQLField("entityId")
    extends: "LookerViewGraphQLField" = LookerViewGraphQLField("extends")

    @classmethod
    def filters(cls) -> "LookerViewFilterFields":
        return LookerViewFilterFields("filters")

    label: "LookerViewGraphQLField" = LookerViewGraphQLField("label")

    @classmethod
    def measures(cls) -> "LookerViewMeasureFields":
        return LookerViewMeasureFields("measures")

    @classmethod
    def query(cls) -> "LookerViewQueryFields":
        return LookerViewQueryFields("query")

    source_datasets: "LookerViewGraphQLField" = LookerViewGraphQLField("sourceDatasets")

    @classmethod
    def upstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstream_of_type", arguments=cleared_arguments
        )

    url: "LookerViewGraphQLField" = LookerViewGraphQLField("url")

    def fields(
        self,
        *subfields: Union[
            LookerViewGraphQLField,
            "EntityLineageConnectionFields",
            "LookerViewDimensionFields",
            "LookerViewFilterFields",
            "LookerViewMeasureFields",
            "LookerViewQueryFields",
        ]
    ) -> "LookerViewFields":
        """Subfields should come from the LookerViewFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerViewFields":
        self._alias = alias
        return self


class LookerViewDimensionFields(GraphQLField):
    data_type: "LookerViewDimensionGraphQLField" = LookerViewDimensionGraphQLField(
        "dataType"
    )
    field: "LookerViewDimensionGraphQLField" = LookerViewDimensionGraphQLField("field")

    def fields(
        self, *subfields: LookerViewDimensionGraphQLField
    ) -> "LookerViewDimensionFields":
        """Subfields should come from the LookerViewDimensionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerViewDimensionFields":
        self._alias = alias
        return self


class LookerViewFilterFields(GraphQLField):
    field: "LookerViewFilterGraphQLField" = LookerViewFilterGraphQLField("field")
    type: "LookerViewFilterGraphQLField" = LookerViewFilterGraphQLField("type")

    def fields(
        self, *subfields: LookerViewFilterGraphQLField
    ) -> "LookerViewFilterFields":
        """Subfields should come from the LookerViewFilterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerViewFilterFields":
        self._alias = alias
        return self


class LookerViewMeasureFields(GraphQLField):
    field: "LookerViewMeasureGraphQLField" = LookerViewMeasureGraphQLField("field")
    type: "LookerViewMeasureGraphQLField" = LookerViewMeasureGraphQLField("type")

    def fields(
        self, *subfields: LookerViewMeasureGraphQLField
    ) -> "LookerViewMeasureFields":
        """Subfields should come from the LookerViewMeasureFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerViewMeasureFields":
        self._alias = alias
        return self


class LookerViewQueryFields(GraphQLField):
    default_database: "LookerViewQueryGraphQLField" = LookerViewQueryGraphQLField(
        "defaultDatabase"
    )
    default_schema: "LookerViewQueryGraphQLField" = LookerViewQueryGraphQLField(
        "defaultSchema"
    )
    query: "LookerViewQueryGraphQLField" = LookerViewQueryGraphQLField("query")
    source_dataset_account: "LookerViewQueryGraphQLField" = LookerViewQueryGraphQLField(
        "sourceDatasetAccount"
    )
    source_platform: "LookerViewQueryGraphQLField" = LookerViewQueryGraphQLField(
        "sourcePlatform"
    )

    def fields(
        self, *subfields: LookerViewQueryGraphQLField
    ) -> "LookerViewQueryFields":
        """Subfields should come from the LookerViewQueryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerViewQueryFields":
        self._alias = alias
        return self


class LookerViewSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "VirtualViewSearchDocumentFields":
        return VirtualViewSearchDocumentFields("documents")

    error_message: "LookerViewSearchResultGraphQLField" = (
        LookerViewSearchResultGraphQLField("errorMessage")
    )
    from_: "LookerViewSearchResultGraphQLField" = LookerViewSearchResultGraphQLField(
        "from"
    )
    has_more: "LookerViewSearchResultGraphQLField" = LookerViewSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "LookerViewSearchResultGraphQLField" = (
        LookerViewSearchResultGraphQLField("paginationToken")
    )
    search_context: "LookerViewSearchResultGraphQLField" = (
        LookerViewSearchResultGraphQLField("searchContext")
    )
    search_index: "LookerViewSearchResultGraphQLField" = (
        LookerViewSearchResultGraphQLField("searchIndex")
    )
    size: "LookerViewSearchResultGraphQLField" = LookerViewSearchResultGraphQLField(
        "size"
    )
    total_count: "LookerViewSearchResultGraphQLField" = (
        LookerViewSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            LookerViewSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "VirtualViewSearchDocumentFields",
        ]
    ) -> "LookerViewSearchResultFields":
        """Subfields should come from the LookerViewSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerViewSearchResultFields":
        self._alias = alias
        return self


class MetabaseCollectionFields(GraphQLField):
    name: "MetabaseCollectionGraphQLField" = MetabaseCollectionGraphQLField("name")
    url: "MetabaseCollectionGraphQLField" = MetabaseCollectionGraphQLField("url")

    def fields(
        self, *subfields: MetabaseCollectionGraphQLField
    ) -> "MetabaseCollectionFields":
        """Subfields should come from the MetabaseCollectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetabaseCollectionFields":
        self._alias = alias
        return self


class MetricFields(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def asset_contacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("asset_contacts")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "MetricGraphQLField" = MetricGraphQLField("createdAt")

    @classmethod
    def dbt_metric(cls) -> "DbtMetricFields":
        return DbtMetricFields("dbt_metric")

    deleted_at: "MetricGraphQLField" = MetricGraphQLField("deletedAt")

    @classmethod
    def descriptions(cls) -> "DerivedAssetDescriptionsFields":
        return DerivedAssetDescriptionsFields("descriptions")

    display_name: "MetricGraphQLField" = MetricGraphQLField("displayName")

    @classmethod
    def downstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineage_for: Optional[LineageFilterInput] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineage_for},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstream_of_type", arguments=cleared_arguments
        )

    entity_type: "MetricGraphQLField" = MetricGraphQLField("entityType")

    @classmethod
    def entity_upstream(cls) -> "EntityUpstreamFields":
        return EntityUpstreamFields("entity_upstream")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def force_shown(cls) -> "AuditStampFields":
        return AuditStampFields("force_shown")

    @classmethod
    def governed_tags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governed_tags", arguments=cleared_arguments
        )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "MetricGraphQLField" = MetricGraphQLField("id")

    @classmethod
    def interested_parties(cls) -> "InterestedPartyFields":
        return InterestedPartyFields("interested_parties")

    is_complete: "MetricGraphQLField" = MetricGraphQLField("isComplete")
    is_deleted: "MetricGraphQLField" = MetricGraphQLField("isDeleted")
    is_production: "MetricGraphQLField" = MetricGraphQLField("isProduction")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledge_cards(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledge_cards", arguments=cleared_arguments
        )

    @classmethod
    def labels(cls) -> "AnchorEntityLabelFields":
        return AnchorEntityLabelFields("labels")

    last_ingested_at: "MetricGraphQLField" = MetricGraphQLField("lastIngestedAt")
    last_modified_at: "MetricGraphQLField" = MetricGraphQLField("lastModifiedAt")

    @classmethod
    def logical_id(cls) -> "MetricLogicalIdFields":
        return MetricLogicalIdFields("logical_id")

    @classmethod
    def metric_info(cls) -> "MetricInfoFields":
        return MetricInfoFields("metric_info")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def recent_user_activities(
        cls, *, input: Optional[RecentUserActivitiesFilterInput] = None
    ) -> "RecentUserActivitiesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "RecentUserActivitiesFilterInput", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return RecentUserActivitiesFields(
            "recent_user_activities", arguments=cleared_arguments
        )

    @classmethod
    def recently_viewed_by(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "ViewedByConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewedByConnectionFields(
            "recently_viewed_by", arguments=cleared_arguments
        )

    @classmethod
    def system_contacts(cls) -> "SystemContactsFields":
        return SystemContactsFields("system_contacts")

    @classmethod
    def system_description(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("system_description")

    system_tag_values: "MetricGraphQLField" = MetricGraphQLField("systemTagValues")

    @classmethod
    def system_tags(cls) -> "SystemTagsFields":
        return SystemTagsFields("system_tags")

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    @classmethod
    def top_knowledge_card_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(
            "top_knowledge_card_authors", arguments=cleared_arguments
        )

    @classmethod
    def upstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineage_for: Optional[LineageFilterInput] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineage_for},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstream_of_type", arguments=cleared_arguments
        )

    viewer_can_assign_asset_contacts: "MetricGraphQLField" = MetricGraphQLField(
        "viewerCanAssignAssetContacts"
    )
    viewer_has_pinned: "MetricGraphQLField" = MetricGraphQLField("viewerHasPinned")

    def fields(
        self,
        *subfields: Union[
            MetricGraphQLField,
            "AggregationMetadataFields",
            "AnchorEntityLabelFields",
            "AssetContactsFields",
            "AssetFollowersFields",
            "AuditStampFields",
            "BrowsePathFields",
            "DbtMetricFields",
            "DerivedAssetDescriptionsFields",
            "EntityLineageConnectionFields",
            "EntityUpstreamFields",
            "HashtagFields",
            "InterestedPartyFields",
            "KnowledgeCardConnectionFields",
            "MetricInfoFields",
            "MetricLogicalIdFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "RecentUserActivitiesFields",
            "SystemContactsFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
            "UserDefinedResourceConnectionFields",
            "ViewedByConnectionFields",
        ]
    ) -> "MetricFields":
        """Subfields should come from the MetricFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricFields":
        self._alias = alias
        return self


class MetricBaseInterface(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "MetricBaseGraphQLField" = MetricBaseGraphQLField("createdAt")

    @classmethod
    def dbt_metric(cls) -> "DbtMetricFields":
        return DbtMetricFields("dbt_metric")

    deleted_at: "MetricBaseGraphQLField" = MetricBaseGraphQLField("deletedAt")
    display_name: "MetricBaseGraphQLField" = MetricBaseGraphQLField("displayName")
    entity_type: "MetricBaseGraphQLField" = MetricBaseGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def force_shown(cls) -> "AuditStampFields":
        return AuditStampFields("force_shown")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "MetricBaseGraphQLField" = MetricBaseGraphQLField("id")
    is_complete: "MetricBaseGraphQLField" = MetricBaseGraphQLField("isComplete")
    is_deleted: "MetricBaseGraphQLField" = MetricBaseGraphQLField("isDeleted")
    is_production: "MetricBaseGraphQLField" = MetricBaseGraphQLField("isProduction")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    last_ingested_at: "MetricBaseGraphQLField" = MetricBaseGraphQLField(
        "lastIngestedAt"
    )
    last_modified_at: "MetricBaseGraphQLField" = MetricBaseGraphQLField(
        "lastModifiedAt"
    )

    @classmethod
    def logical_id(cls) -> "MetricLogicalIdFields":
        return MetricLogicalIdFields("logical_id")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def system_contacts(cls) -> "SystemContactsFields":
        return SystemContactsFields("system_contacts")

    @classmethod
    def system_description(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("system_description")

    system_tag_values: "MetricBaseGraphQLField" = MetricBaseGraphQLField(
        "systemTagValues"
    )

    @classmethod
    def system_tags(cls) -> "SystemTagsFields":
        return SystemTagsFields("system_tags")

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            MetricBaseGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "AuditStampFields",
            "BrowsePathFields",
            "DbtMetricFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "MetricLogicalIdFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "SystemContactsFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
        ]
    ) -> "MetricBaseInterface":
        """Subfields should come from the MetricBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricBaseInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "MetricBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class MetricConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "MetricEdgeFields":
        return MetricEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "MetricConnectionGraphQLField" = MetricConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            MetricConnectionGraphQLField, "MetricEdgeFields", "PageInfoFields"
        ]
    ) -> "MetricConnectionFields":
        """Subfields should come from the MetricConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricConnectionFields":
        self._alias = alias
        return self


class MetricEdgeFields(GraphQLField):
    cursor: "MetricEdgeGraphQLField" = MetricEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "MetricFields":
        return MetricFields("node")

    def fields(
        self, *subfields: Union[MetricEdgeGraphQLField, "MetricFields"]
    ) -> "MetricEdgeFields":
        """Subfields should come from the MetricEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricEdgeFields":
        self._alias = alias
        return self


class MetricFilterFields(GraphQLField):
    field: "MetricFilterGraphQLField" = MetricFilterGraphQLField("field")
    operator: "MetricFilterGraphQLField" = MetricFilterGraphQLField("operator")
    value: "MetricFilterGraphQLField" = MetricFilterGraphQLField("value")

    def fields(self, *subfields: MetricFilterGraphQLField) -> "MetricFilterFields":
        """Subfields should come from the MetricFilterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricFilterFields":
        self._alias = alias
        return self


class MetricInfoFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "MetricInfoGraphQLField" = MetricInfoGraphQLField("createdAt")
    entity_id: "MetricInfoGraphQLField" = MetricInfoGraphQLField("entityId")

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    @classmethod
    def related_assets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        types: Optional[EntityType] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "types": {"type": "EntityType", "value": types},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("related_assets", arguments=cleared_arguments)

    related_entity_ids: "MetricInfoGraphQLField" = MetricInfoGraphQLField(
        "relatedEntityIds"
    )

    def fields(
        self,
        *subfields: Union[
            MetricInfoGraphQLField, "AuditStampFields", "EntityConnectionFields"
        ]
    ) -> "MetricInfoFields":
        """Subfields should come from the MetricInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricInfoFields":
        self._alias = alias
        return self


class MetricInfoBaseInterface(GraphQLField):
    created_at: "MetricInfoBaseGraphQLField" = MetricInfoBaseGraphQLField("createdAt")
    entity_id: "MetricInfoBaseGraphQLField" = MetricInfoBaseGraphQLField("entityId")

    def fields(
        self, *subfields: MetricInfoBaseGraphQLField
    ) -> "MetricInfoBaseInterface":
        """Subfields should come from the MetricInfoBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricInfoBaseInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "MetricInfoBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class MetricLogicalIdFields(GraphQLField):
    name: "MetricLogicalIdGraphQLField" = MetricLogicalIdGraphQLField("name")
    type: "MetricLogicalIdGraphQLField" = MetricLogicalIdGraphQLField("type")

    def fields(
        self, *subfields: MetricLogicalIdGraphQLField
    ) -> "MetricLogicalIdFields":
        """Subfields should come from the MetricLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricLogicalIdFields":
        self._alias = alias
        return self


class MetricSearchInfoFields(GraphQLField):
    type: "MetricSearchInfoGraphQLField" = MetricSearchInfoGraphQLField("type")

    def fields(
        self, *subfields: MetricSearchInfoGraphQLField
    ) -> "MetricSearchInfoFields":
        """Subfields should come from the MetricSearchInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricSearchInfoFields":
        self._alias = alias
        return self


class MetricSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "AssetSearchDocumentFields":
        return AssetSearchDocumentFields("documents")

    error_message: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField(
        "errorMessage"
    )
    from_: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField("from")
    has_more: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField(
        "paginationToken"
    )
    search_context: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField(
        "searchContext"
    )
    search_index: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField(
        "searchIndex"
    )
    size: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField("size")
    total_count: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            MetricSearchResultGraphQLField,
            "AggregationMetadataFields",
            "AssetSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "MetricSearchResultFields":
        """Subfields should come from the MetricSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricSearchResultFields":
        self._alias = alias
        return self


class MicrosoftSocialLoginFields(GraphQLField):
    allowed_email_patterns: "MicrosoftSocialLoginGraphQLField" = (
        MicrosoftSocialLoginGraphQLField("allowedEmailPatterns")
    )

    def fields(
        self, *subfields: MicrosoftSocialLoginGraphQLField
    ) -> "MicrosoftSocialLoginFields":
        """Subfields should come from the MicrosoftSocialLoginFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MicrosoftSocialLoginFields":
        self._alias = alias
        return self


class NamespaceFields(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def asset_contacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("asset_contacts")

    @classmethod
    def assets_governed_tags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[GovernedTagFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "GovernedTagFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "assets_governed_tags", arguments=cleared_arguments
        )

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    @classmethod
    def child_namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields(
            "child_namespaces", arguments=cleared_arguments
        )

    created_at: "NamespaceGraphQLField" = NamespaceGraphQLField("createdAt")

    @classmethod
    def custom_asset_ordering(
        cls, *, type: Optional[UserDefinedOrderType] = None
    ) -> "OrderedEntryFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "UserDefinedOrderType", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return OrderedEntryFields("custom_asset_ordering", arguments=cleared_arguments)

    deleted_at: "NamespaceGraphQLField" = NamespaceGraphQLField("deletedAt")

    @classmethod
    def descriptions(cls) -> "DerivedAssetDescriptionsFields":
        return DerivedAssetDescriptionsFields("descriptions")

    display_name: "NamespaceGraphQLField" = NamespaceGraphQLField("displayName")
    domain_assets_count: "NamespaceGraphQLField" = NamespaceGraphQLField(
        "domainAssetsCount"
    )
    entity_type: "NamespaceGraphQLField" = NamespaceGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def governed_tags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governed_tags", arguments=cleared_arguments
        )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "NamespaceGraphQLField" = NamespaceGraphQLField("id")
    is_deleted: "NamespaceGraphQLField" = NamespaceGraphQLField("isDeleted")
    is_viewer_author: "NamespaceGraphQLField" = NamespaceGraphQLField("isViewerAuthor")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledge_cards(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledge_cards", arguments=cleared_arguments
        )

    last_ingested_at: "NamespaceGraphQLField" = NamespaceGraphQLField("lastIngestedAt")
    last_modified_at: "NamespaceGraphQLField" = NamespaceGraphQLField("lastModifiedAt")

    @classmethod
    def logical_id(cls) -> "NamespaceLogicalIdFields":
        return NamespaceLogicalIdFields("logical_id")

    @classmethod
    def namespace_assets(cls) -> "NamespaceAssetsFields":
        return NamespaceAssetsFields("namespace_assets")

    @classmethod
    def namespace_info(cls) -> "NamespaceInfoFields":
        return NamespaceInfoFields("namespace_info")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def parent_namespace(cls) -> "NamespaceFields":
        return NamespaceFields("parent_namespace")

    @classmethod
    def recently_viewed_by(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "ViewedByConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewedByConnectionFields(
            "recently_viewed_by", arguments=cleared_arguments
        )

    @classmethod
    def summary(cls) -> "NamespaceSummaryFields":
        return NamespaceSummaryFields("summary")

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    viewer_can_assign: "NamespaceGraphQLField" = NamespaceGraphQLField(
        "viewerCanAssign"
    )
    viewer_can_assign_asset_contacts: "NamespaceGraphQLField" = NamespaceGraphQLField(
        "viewerCanAssignAssetContacts"
    )
    viewer_can_delete: "NamespaceGraphQLField" = NamespaceGraphQLField(
        "viewerCanDelete"
    )
    viewer_can_edit: "NamespaceGraphQLField" = NamespaceGraphQLField("viewerCanEdit")
    viewer_has_pinned: "NamespaceGraphQLField" = NamespaceGraphQLField(
        "viewerHasPinned"
    )

    def fields(
        self,
        *subfields: Union[
            NamespaceGraphQLField,
            "AggregationMetadataFields",
            "AssetContactsFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "DerivedAssetDescriptionsFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceAssetsFields",
            "NamespaceConnectionFields",
            "NamespaceFields",
            "NamespaceInfoFields",
            "NamespaceLogicalIdFields",
            "NamespaceSummaryFields",
            "OrderedEntryFields",
            "PersonConnectionFields",
            "UserDefinedResourceConnectionFields",
            "ViewedByConnectionFields",
        ]
    ) -> "NamespaceFields":
        """Subfields should come from the NamespaceFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceFields":
        self._alias = alias
        return self


class NamespaceAssetsFields(GraphQLField):
    @classmethod
    def assets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("assets", arguments=cleared_arguments)

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "NamespaceAssetsGraphQLField" = NamespaceAssetsGraphQLField("createdAt")
    entity_id: "NamespaceAssetsGraphQLField" = NamespaceAssetsGraphQLField("entityId")

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    @classmethod
    def named_asset_collections(
        cls,
        *,
        id: Optional[str] = None,
        name: Optional[str] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "CustomSortableNamedAssetCollectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "String", "value": id},
            "name": {"type": "String", "value": name},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return CustomSortableNamedAssetCollectionFields(
            "named_asset_collections", arguments=cleared_arguments
        )

    def fields(
        self,
        *subfields: Union[
            NamespaceAssetsGraphQLField,
            "AuditStampFields",
            "CustomSortableNamedAssetCollectionFields",
            "EntityConnectionFields",
        ]
    ) -> "NamespaceAssetsFields":
        """Subfields should come from the NamespaceAssetsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceAssetsFields":
        self._alias = alias
        return self


class NamespaceBaseInterface(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField("createdAt")
    deleted_at: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField("deletedAt")
    display_name: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField("displayName")
    entity_type: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField("id")
    is_deleted: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField("isDeleted")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    last_ingested_at: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField(
        "lastIngestedAt"
    )
    last_modified_at: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField(
        "lastModifiedAt"
    )

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            NamespaceBaseGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "NamespaceBaseInterface":
        """Subfields should come from the NamespaceBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceBaseInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "NamespaceBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class NamespaceConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "NamespaceEdgeFields":
        return NamespaceEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "NamespaceConnectionGraphQLField" = NamespaceConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            NamespaceConnectionGraphQLField, "NamespaceEdgeFields", "PageInfoFields"
        ]
    ) -> "NamespaceConnectionFields":
        """Subfields should come from the NamespaceConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceConnectionFields":
        self._alias = alias
        return self


class NamespaceDeletePayloadFields(GraphQLField):
    deleted_ids: "NamespaceDeletePayloadGraphQLField" = (
        NamespaceDeletePayloadGraphQLField("deletedIds")
    )
    failed_ids: "NamespaceDeletePayloadGraphQLField" = (
        NamespaceDeletePayloadGraphQLField("failedIds")
    )

    def fields(
        self, *subfields: NamespaceDeletePayloadGraphQLField
    ) -> "NamespaceDeletePayloadFields":
        """Subfields should come from the NamespaceDeletePayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceDeletePayloadFields":
        self._alias = alias
        return self


class NamespaceDescriptionFields(GraphQLField):
    text: "NamespaceDescriptionGraphQLField" = NamespaceDescriptionGraphQLField("text")
    tokenized_text: "NamespaceDescriptionGraphQLField" = (
        NamespaceDescriptionGraphQLField("tokenizedText")
    )

    def fields(
        self, *subfields: NamespaceDescriptionGraphQLField
    ) -> "NamespaceDescriptionFields":
        """Subfields should come from the NamespaceDescriptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceDescriptionFields":
        self._alias = alias
        return self


class NamespaceEdgeFields(GraphQLField):
    cursor: "NamespaceEdgeGraphQLField" = NamespaceEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "NamespaceFields":
        return NamespaceFields("node")

    def fields(
        self, *subfields: Union[NamespaceEdgeGraphQLField, "NamespaceFields"]
    ) -> "NamespaceEdgeFields":
        """Subfields should come from the NamespaceEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceEdgeFields":
        self._alias = alias
        return self


class NamespaceHighlightFields(GraphQLField):
    contact_display_names: "NamespaceHighlightGraphQLField" = (
        NamespaceHighlightGraphQLField("contactDisplayNames")
    )
    description: "NamespaceHighlightGraphQLField" = NamespaceHighlightGraphQLField(
        "description"
    )
    governed_tags: "NamespaceHighlightGraphQLField" = NamespaceHighlightGraphQLField(
        "governedTags"
    )
    hashtags: "NamespaceHighlightGraphQLField" = NamespaceHighlightGraphQLField(
        "hashtags"
    )
    name: "NamespaceHighlightGraphQLField" = NamespaceHighlightGraphQLField("name")

    def fields(
        self, *subfields: NamespaceHighlightGraphQLField
    ) -> "NamespaceHighlightFields":
        """Subfields should come from the NamespaceHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceHighlightFields":
        self._alias = alias
        return self


class NamespaceInfoFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "NamespaceInfoGraphQLField" = NamespaceInfoGraphQLField("createdAt")

    @classmethod
    def description(cls) -> "NamespaceDescriptionFields":
        return NamespaceDescriptionFields("description")

    @classmethod
    def detail(cls) -> "NamespaceTypeDetailFields":
        return NamespaceTypeDetailFields("detail")

    entity_id: "NamespaceInfoGraphQLField" = NamespaceInfoGraphQLField("entityId")

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    name: "NamespaceInfoGraphQLField" = NamespaceInfoGraphQLField("name")
    visible_to: "NamespaceInfoGraphQLField" = NamespaceInfoGraphQLField("visibleTo")

    def fields(
        self,
        *subfields: Union[
            NamespaceInfoGraphQLField,
            "AuditStampFields",
            "NamespaceDescriptionFields",
            "NamespaceTypeDetailFields",
        ]
    ) -> "NamespaceInfoFields":
        """Subfields should come from the NamespaceInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceInfoFields":
        self._alias = alias
        return self


class NamespaceInfoBaseInterface(GraphQLField):
    created_at: "NamespaceInfoBaseGraphQLField" = NamespaceInfoBaseGraphQLField(
        "createdAt"
    )

    @classmethod
    def description(cls) -> "NamespaceDescriptionFields":
        return NamespaceDescriptionFields("description")

    entity_id: "NamespaceInfoBaseGraphQLField" = NamespaceInfoBaseGraphQLField(
        "entityId"
    )
    name: "NamespaceInfoBaseGraphQLField" = NamespaceInfoBaseGraphQLField("name")
    visible_to: "NamespaceInfoBaseGraphQLField" = NamespaceInfoBaseGraphQLField(
        "visibleTo"
    )

    def fields(
        self,
        *subfields: Union[NamespaceInfoBaseGraphQLField, "NamespaceDescriptionFields"]
    ) -> "NamespaceInfoBaseInterface":
        """Subfields should come from the NamespaceInfoBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceInfoBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "NamespaceInfoBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class NamespaceLogicalIdFields(GraphQLField):
    id: "NamespaceLogicalIdGraphQLField" = NamespaceLogicalIdGraphQLField("id")

    def fields(
        self, *subfields: NamespaceLogicalIdGraphQLField
    ) -> "NamespaceLogicalIdFields":
        """Subfields should come from the NamespaceLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceLogicalIdFields":
        self._alias = alias
        return self


class NamespaceSearchDocumentFields(GraphQLField):
    author: "NamespaceSearchDocumentGraphQLField" = NamespaceSearchDocumentGraphQLField(
        "author"
    )
    author_display_name: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("authorDisplayName")
    )
    browse_path_hierarchy: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browse_path_segments: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    contact_display_names: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("contactDisplayNames")
    )
    description: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("description")
    )
    document_id: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("documentId")
    )
    domain_display_name: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("domainDisplayName")
    )
    domains: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("domains")
    )
    embedded_string_1: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("embeddedString_1")
    )
    embedded_string_2: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("embeddedString_2")
    )
    entity_id: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("entityId")
    )
    governed_tags: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("governedTags")
    )
    hashtags: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("hashtags")
    )

    @classmethod
    def highlight(cls) -> "NamespaceHighlightFields":
        return NamespaceHighlightFields("highlight")

    is_deleted: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("isDeleted")
    )
    last_refreshed: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("lastRefreshed")
    )
    name: "NamespaceSearchDocumentGraphQLField" = NamespaceSearchDocumentGraphQLField(
        "name"
    )
    pagination_token: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("paginationToken")
    )

    @classmethod
    def score_details(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("score_details")

    type: "NamespaceSearchDocumentGraphQLField" = NamespaceSearchDocumentGraphQLField(
        "type"
    )
    view_count: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("viewCount")
    )

    def fields(
        self,
        *subfields: Union[
            NamespaceSearchDocumentGraphQLField,
            "BrowsePathFields",
            "NamespaceHighlightFields",
            "SearchScoreDetailsFields",
        ]
    ) -> "NamespaceSearchDocumentFields":
        """Subfields should come from the NamespaceSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceSearchDocumentFields":
        self._alias = alias
        return self


class NamespaceSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "NamespaceSearchDocumentFields":
        return NamespaceSearchDocumentFields("documents")

    error_message: "NamespaceSearchResultGraphQLField" = (
        NamespaceSearchResultGraphQLField("errorMessage")
    )
    from_: "NamespaceSearchResultGraphQLField" = NamespaceSearchResultGraphQLField(
        "from"
    )
    has_more: "NamespaceSearchResultGraphQLField" = NamespaceSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "NamespaceSearchResultGraphQLField" = (
        NamespaceSearchResultGraphQLField("paginationToken")
    )
    search_context: "NamespaceSearchResultGraphQLField" = (
        NamespaceSearchResultGraphQLField("searchContext")
    )
    search_index: "NamespaceSearchResultGraphQLField" = (
        NamespaceSearchResultGraphQLField("searchIndex")
    )
    size: "NamespaceSearchResultGraphQLField" = NamespaceSearchResultGraphQLField(
        "size"
    )
    total_count: "NamespaceSearchResultGraphQLField" = (
        NamespaceSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            NamespaceSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NamespaceSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "NamespaceSearchResultFields":
        """Subfields should come from the NamespaceSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceSearchResultFields":
        self._alias = alias
        return self


class NamespaceSummaryFields(GraphQLField):
    @classmethod
    def branch_assets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("branch_assets", arguments=cleared_arguments)

    @classmethod
    def branch_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[PersonConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "PersonConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("branch_authors", arguments=cleared_arguments)

    @classmethod
    def branch_child_namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields(
            "branch_child_namespaces", arguments=cleared_arguments
        )

    id: "NamespaceSummaryGraphQLField" = NamespaceSummaryGraphQLField("id")

    def fields(
        self,
        *subfields: Union[
            NamespaceSummaryGraphQLField,
            "EntityConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "NamespaceSummaryFields":
        """Subfields should come from the NamespaceSummaryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceSummaryFields":
        self._alias = alias
        return self


class NamespaceTypeDetailFields(GraphQLField):
    @classmethod
    def saved_queries(
        cls,
        *,
        namespace_id: Optional[str] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "CustomSortableSavedLiveQueryFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "namespaceId": {"type": "ID", "value": namespace_id},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return CustomSortableSavedLiveQueryFields(
            "saved_queries", arguments=cleared_arguments
        )

    type: "NamespaceTypeDetailGraphQLField" = NamespaceTypeDetailGraphQLField("type")

    def fields(
        self,
        *subfields: Union[
            NamespaceTypeDetailGraphQLField, "CustomSortableSavedLiveQueryFields"
        ]
    ) -> "NamespaceTypeDetailFields":
        """Subfields should come from the NamespaceTypeDetailFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceTypeDetailFields":
        self._alias = alias
        return self


class NamespaceTypeDetailBaseInterface(GraphQLField):
    type: "NamespaceTypeDetailBaseGraphQLField" = NamespaceTypeDetailBaseGraphQLField(
        "type"
    )

    def fields(
        self, *subfields: NamespaceTypeDetailBaseGraphQLField
    ) -> "NamespaceTypeDetailBaseInterface":
        """Subfields should come from the NamespaceTypeDetailBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceTypeDetailBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "NamespaceTypeDetailBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class NodeInterface(GraphQLField):
    id: "NodeGraphQLField" = NodeGraphQLField("id")

    def fields(self, *subfields: NodeGraphQLField) -> "NodeInterface":
        """Subfields should come from the NodeInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NodeInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "NodeInterface":
        self._inline_fragments[type_name] = subfields
        return self


class NonProdFields(GraphQLField):
    @classmethod
    def dataset_patterns(cls) -> "DatasetPatternFields":
        return DatasetPatternFields("dataset_patterns")

    def fields(
        self, *subfields: Union[NonProdGraphQLField, "DatasetPatternFields"]
    ) -> "NonProdFields":
        """Subfields should come from the NonProdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NonProdFields":
        self._alias = alias
        return self


class OktaSSOFields(GraphQLField):
    client_id: "OktaSSOGraphQLField" = OktaSSOGraphQLField("clientId")
    client_secret: "OktaSSOGraphQLField" = OktaSSOGraphQLField("clientSecret")
    issuer: "OktaSSOGraphQLField" = OktaSSOGraphQLField("issuer")

    def fields(self, *subfields: OktaSSOGraphQLField) -> "OktaSSOFields":
        """Subfields should come from the OktaSSOFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OktaSSOFields":
        self._alias = alias
        return self


class OnboardingEmailFields(GraphQLField):
    email_type: "OnboardingEmailGraphQLField" = OnboardingEmailGraphQLField("emailType")
    has_been_sent: "OnboardingEmailGraphQLField" = OnboardingEmailGraphQLField(
        "hasBeenSent"
    )

    def fields(
        self, *subfields: OnboardingEmailGraphQLField
    ) -> "OnboardingEmailFields":
        """Subfields should come from the OnboardingEmailFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OnboardingEmailFields":
        self._alias = alias
        return self


class OnboardingExperienceFields(GraphQLField):
    get_started_step_completions: "OnboardingExperienceGraphQLField" = (
        OnboardingExperienceGraphQLField("getStartedStepCompletions")
    )
    has_dismissed_get_started_steps: "OnboardingExperienceGraphQLField" = (
        OnboardingExperienceGraphQLField("hasDismissedGetStartedSteps")
    )
    has_dismissed_profile_completion: "OnboardingExperienceGraphQLField" = (
        OnboardingExperienceGraphQLField("hasDismissedProfileCompletion")
    )

    @classmethod
    def onboarding_emails(cls) -> "OnboardingEmailFields":
        return OnboardingEmailFields("onboarding_emails")

    profile_completion_steps: "OnboardingExperienceGraphQLField" = (
        OnboardingExperienceGraphQLField("profileCompletionSteps")
    )

    def fields(
        self,
        *subfields: Union[OnboardingExperienceGraphQLField, "OnboardingEmailFields"]
    ) -> "OnboardingExperienceFields":
        """Subfields should come from the OnboardingExperienceFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OnboardingExperienceFields":
        self._alias = alias
        return self


class OrderedEntryFields(GraphQLField):
    id: "OrderedEntryGraphQLField" = OrderedEntryGraphQLField("id")

    @classmethod
    def ordered_entries(cls) -> "OrderedEntryFields":
        return OrderedEntryFields("ordered_entries")

    def fields(
        self, *subfields: Union[OrderedEntryGraphQLField, "OrderedEntryFields"]
    ) -> "OrderedEntryFields":
        """Subfields should come from the OrderedEntryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OrderedEntryFields":
        self._alias = alias
        return self


class OrganizationFields(GraphQLField):
    about: "OrganizationGraphQLField" = OrganizationGraphQLField("about")
    logo_url: "OrganizationGraphQLField" = OrganizationGraphQLField("logoUrl")
    name: "OrganizationGraphQLField" = OrganizationGraphQLField("name")

    def fields(self, *subfields: OrganizationGraphQLField) -> "OrganizationFields":
        """Subfields should come from the OrganizationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OrganizationFields":
        self._alias = alias
        return self


class OverallDataQualityFields(GraphQLField):
    computed_at: "OverallDataQualityGraphQLField" = OverallDataQualityGraphQLField(
        "computedAt"
    )
    created_at: "OverallDataQualityGraphQLField" = OverallDataQualityGraphQLField(
        "createdAt"
    )
    entity_id: "OverallDataQualityGraphQLField" = OverallDataQualityGraphQLField(
        "entityId"
    )
    status: "OverallDataQualityGraphQLField" = OverallDataQualityGraphQLField("status")

    @classmethod
    def status_sources(cls) -> "DataQualityStatusSourceFields":
        return DataQualityStatusSourceFields("status_sources")

    def fields(
        self,
        *subfields: Union[
            OverallDataQualityGraphQLField, "DataQualityStatusSourceFields"
        ]
    ) -> "OverallDataQualityFields":
        """Subfields should come from the OverallDataQualityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OverallDataQualityFields":
        self._alias = alias
        return self


class PageInfoFields(GraphQLField):
    end_cursor: "PageInfoGraphQLField" = PageInfoGraphQLField("endCursor")
    has_next_page: "PageInfoGraphQLField" = PageInfoGraphQLField("hasNextPage")
    has_previous_page: "PageInfoGraphQLField" = PageInfoGraphQLField("hasPreviousPage")
    start_cursor: "PageInfoGraphQLField" = PageInfoGraphQLField("startCursor")

    def fields(self, *subfields: PageInfoGraphQLField) -> "PageInfoFields":
        """Subfields should come from the PageInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PageInfoFields":
        self._alias = alias
        return self


class PersonFields(GraphQLField):
    @classmethod
    def activity(cls) -> "PersonActivityFields":
        return PersonActivityFields("activity")

    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "PersonGraphQLField" = PersonGraphQLField("createdAt")
    deleted_at: "PersonGraphQLField" = PersonGraphQLField("deletedAt")
    display_name: "PersonGraphQLField" = PersonGraphQLField("displayName")

    @classmethod
    def entities_with_authored_knowledge_cards(
        cls,
        entity_types: EntityType,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "entityTypes": {"type": "EntityType!", "value": entity_types},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields(
            "entities_with_authored_knowledge_cards", arguments=cleared_arguments
        )

    entity_type: "PersonGraphQLField" = PersonGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def following(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        followed_entities: Optional[EntityType] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "followedEntities": {"type": "EntityType", "value": followed_entities},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("following", arguments=cleared_arguments)

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    @classmethod
    def hashtags_used(cls) -> "HashtagFields":
        return HashtagFields("hashtags_used")

    id: "PersonGraphQLField" = PersonGraphQLField("id")
    is_deleted: "PersonGraphQLField" = PersonGraphQLField("isDeleted")
    is_viewer: "PersonGraphQLField" = PersonGraphQLField("isViewer")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledge_cards_authored(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledge_cards_authored", arguments=cleared_arguments
        )

    last_ingested_at: "PersonGraphQLField" = PersonGraphQLField("lastIngestedAt")
    last_modified_at: "PersonGraphQLField" = PersonGraphQLField("lastModifiedAt")

    @classmethod
    def logical_id(cls) -> "PersonLogicalIdFields":
        return PersonLogicalIdFields("logical_id")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def organization(cls) -> "PersonOrganizationFields":
        return PersonOrganizationFields("organization")

    @classmethod
    def personalization(cls) -> "PersonalizationOptionsFields":
        return PersonalizationOptionsFields("personalization")

    @classmethod
    def pinned_assets(cls) -> "PersonPinsFields":
        return PersonPinsFields("pinned_assets")

    @classmethod
    def properties(cls) -> "PersonPropertiesFields":
        return PersonPropertiesFields("properties")

    @classmethod
    def queried_datasets(cls) -> "DatasetFields":
        return DatasetFields("queried_datasets")

    @classmethod
    def recent_queries(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[QueryInfoConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "QueryInfoConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "QueryInfoConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return QueryInfoConnectionFields("recent_queries", arguments=cleared_arguments)

    @classmethod
    def saved_queries(cls) -> "SavedLiveQueryFields":
        return SavedLiveQueryFields("saved_queries")

    @classmethod
    def slack_profile(cls) -> "PersonSlackProfileFields":
        return PersonSlackProfileFields("slack_profile")

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    viewer_can_send_invite: "PersonGraphQLField" = PersonGraphQLField(
        "viewerCanSendInvite"
    )

    def fields(
        self,
        *subfields: Union[
            PersonGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "DatasetFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonActivityFields",
            "PersonConnectionFields",
            "PersonLogicalIdFields",
            "PersonOrganizationFields",
            "PersonPinsFields",
            "PersonPropertiesFields",
            "PersonSlackProfileFields",
            "PersonalizationOptionsFields",
            "QueryInfoConnectionFields",
            "SavedLiveQueryFields",
        ]
    ) -> "PersonFields":
        """Subfields should come from the PersonFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonFields":
        self._alias = alias
        return self


class PersonActivityFields(GraphQLField):
    @classmethod
    def recent_ai_searches(cls) -> "AISearchQueryFields":
        return AISearchQueryFields("recent_ai_searches")

    @classmethod
    def recent_searches(cls) -> "SearchQueryFields":
        return SearchQueryFields("recent_searches")

    @classmethod
    def recently_viewed(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        view_context: Optional[SearchContext] = None
    ) -> "ViewActivityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "viewContext": {"type": "SearchContext", "value": view_context},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewActivityConnectionFields(
            "recently_viewed", arguments=cleared_arguments
        )

    def fields(
        self,
        *subfields: Union[
            PersonActivityGraphQLField,
            "AISearchQueryFields",
            "SearchQueryFields",
            "ViewActivityConnectionFields",
        ]
    ) -> "PersonActivityFields":
        """Subfields should come from the PersonActivityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonActivityFields":
        self._alias = alias
        return self


class PersonConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "PersonEdgeFields":
        return PersonEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "PersonConnectionGraphQLField" = PersonConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            PersonConnectionGraphQLField, "PageInfoFields", "PersonEdgeFields"
        ]
    ) -> "PersonConnectionFields":
        """Subfields should come from the PersonConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonConnectionFields":
        self._alias = alias
        return self


class PersonDetailsInterfaceInterface(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "PersonDetailsInterfaceGraphQLField" = (
        PersonDetailsInterfaceGraphQLField("createdAt")
    )
    deleted_at: "PersonDetailsInterfaceGraphQLField" = (
        PersonDetailsInterfaceGraphQLField("deletedAt")
    )
    display_name: "PersonDetailsInterfaceGraphQLField" = (
        PersonDetailsInterfaceGraphQLField("displayName")
    )
    entity_type: "PersonDetailsInterfaceGraphQLField" = (
        PersonDetailsInterfaceGraphQLField("entityType")
    )

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "PersonDetailsInterfaceGraphQLField" = PersonDetailsInterfaceGraphQLField("id")
    is_deleted: "PersonDetailsInterfaceGraphQLField" = (
        PersonDetailsInterfaceGraphQLField("isDeleted")
    )

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    last_ingested_at: "PersonDetailsInterfaceGraphQLField" = (
        PersonDetailsInterfaceGraphQLField("lastIngestedAt")
    )
    last_modified_at: "PersonDetailsInterfaceGraphQLField" = (
        PersonDetailsInterfaceGraphQLField("lastModifiedAt")
    )

    @classmethod
    def logical_id(cls) -> "PersonLogicalIdFields":
        return PersonLogicalIdFields("logical_id")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def organization(cls) -> "PersonOrganizationFields":
        return PersonOrganizationFields("organization")

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            PersonDetailsInterfaceGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "PersonLogicalIdFields",
            "PersonOrganizationFields",
        ]
    ) -> "PersonDetailsInterfaceInterface":
        """Subfields should come from the PersonDetailsInterfaceInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonDetailsInterfaceInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "PersonDetailsInterfaceInterface":
        self._inline_fragments[type_name] = subfields
        return self


class PersonEdgeFields(GraphQLField):
    cursor: "PersonEdgeGraphQLField" = PersonEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "PersonFields":
        return PersonFields("node")

    def fields(
        self, *subfields: Union[PersonEdgeGraphQLField, "PersonFields"]
    ) -> "PersonEdgeFields":
        """Subfields should come from the PersonEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonEdgeFields":
        self._alias = alias
        return self


class PersonHighlightFields(GraphQLField):
    contact_display_names: "PersonHighlightGraphQLField" = PersonHighlightGraphQLField(
        "contactDisplayNames"
    )
    email: "PersonHighlightGraphQLField" = PersonHighlightGraphQLField("email")
    governed_tags: "PersonHighlightGraphQLField" = PersonHighlightGraphQLField(
        "governedTags"
    )
    hashtags: "PersonHighlightGraphQLField" = PersonHighlightGraphQLField("hashtags")
    name: "PersonHighlightGraphQLField" = PersonHighlightGraphQLField("name")

    def fields(
        self, *subfields: PersonHighlightGraphQLField
    ) -> "PersonHighlightFields":
        """Subfields should come from the PersonHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonHighlightFields":
        self._alias = alias
        return self


class PersonLogicalIdFields(GraphQLField):
    email: "PersonLogicalIdGraphQLField" = PersonLogicalIdGraphQLField("email")

    def fields(
        self, *subfields: PersonLogicalIdGraphQLField
    ) -> "PersonLogicalIdFields":
        """Subfields should come from the PersonLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonLogicalIdFields":
        self._alias = alias
        return self


class PersonOrganizationFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField(
        "createdAt"
    )
    department: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField(
        "department"
    )
    division: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField(
        "division"
    )
    employee_number: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField(
        "employeeNumber"
    )
    entity_id: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField(
        "entityId"
    )
    groups: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField("groups")

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    manager: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField(
        "manager"
    )
    name: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField("name")
    title: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField("title")

    def fields(
        self, *subfields: Union[PersonOrganizationGraphQLField, "AuditStampFields"]
    ) -> "PersonOrganizationFields":
        """Subfields should come from the PersonOrganizationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonOrganizationFields":
        self._alias = alias
        return self


class PersonPinsFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "PersonPinsGraphQLField" = PersonPinsGraphQLField("createdAt")
    entity_id: "PersonPinsGraphQLField" = PersonPinsGraphQLField("entityId")

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    @classmethod
    def pins(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[PinsConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        types: Optional[EntityType] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "PinsConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "types": {"type": "EntityType", "value": types},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("pins", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            PersonPinsGraphQLField, "AuditStampFields", "EntityConnectionFields"
        ]
    ) -> "PersonPinsFields":
        """Subfields should come from the PersonPinsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonPinsFields":
        self._alias = alias
        return self


class PersonPinsPinningOutputFields(GraphQLField):
    @classmethod
    def pinned_or_unpinned(cls) -> "EntityInterface":
        return EntityInterface("pinned_or_unpinned")

    @classmethod
    def pinner(cls) -> "PersonFields":
        return PersonFields("pinner")

    def fields(
        self,
        *subfields: Union[
            PersonPinsPinningOutputGraphQLField, "EntityInterface", "PersonFields"
        ]
    ) -> "PersonPinsPinningOutputFields":
        """Subfields should come from the PersonPinsPinningOutputFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonPinsPinningOutputFields":
        self._alias = alias
        return self


class PersonPropertiesFields(GraphQLField):
    about_me: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField("aboutMe")
    avatar_url: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "avatarUrl"
    )

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "createdAt"
    )
    display_name: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "displayName"
    )
    entity_id: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField("entityId")
    first_name: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "firstName"
    )
    full_name: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField("fullName")
    issuer: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField("issuer")
    last_active: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "lastActive"
    )
    last_logged_in: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "lastLoggedIn"
    )

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    last_name: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField("lastName")
    mobile_phone: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "mobilePhone"
    )
    occupation: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "occupation"
    )
    primary_phone: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "primaryPhone"
    )
    provider_name: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "providerName"
    )
    role: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField("role")
    status: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField("status")

    def fields(
        self, *subfields: Union[PersonPropertiesGraphQLField, "AuditStampFields"]
    ) -> "PersonPropertiesFields":
        """Subfields should come from the PersonPropertiesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonPropertiesFields":
        self._alias = alias
        return self


class PersonSearchDocumentFields(GraphQLField):
    browse_path_hierarchy: "PersonSearchDocumentGraphQLField" = (
        PersonSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browse_path_segments: "PersonSearchDocumentGraphQLField" = (
        PersonSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    contact_display_names: "PersonSearchDocumentGraphQLField" = (
        PersonSearchDocumentGraphQLField("contactDisplayNames")
    )
    department: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "department"
    )
    document_id: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "documentId"
    )
    email: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "email"
    )
    embedded_string_1: "PersonSearchDocumentGraphQLField" = (
        PersonSearchDocumentGraphQLField("embeddedString_1")
    )
    embedded_string_2: "PersonSearchDocumentGraphQLField" = (
        PersonSearchDocumentGraphQLField("embeddedString_2")
    )
    entity_id: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "entityId"
    )
    governed_tags: "PersonSearchDocumentGraphQLField" = (
        PersonSearchDocumentGraphQLField("governedTags")
    )
    hashtags: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "hashtags"
    )

    @classmethod
    def highlight(cls) -> "PersonHighlightFields":
        return PersonHighlightFields("highlight")

    is_deleted: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "isDeleted"
    )
    last_refreshed: "PersonSearchDocumentGraphQLField" = (
        PersonSearchDocumentGraphQLField("lastRefreshed")
    )
    name: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField("name")
    pagination_token: "PersonSearchDocumentGraphQLField" = (
        PersonSearchDocumentGraphQLField("paginationToken")
    )

    @classmethod
    def score_details(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("score_details")

    skills: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "skills"
    )
    title: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "title"
    )
    view_count: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "viewCount"
    )

    def fields(
        self,
        *subfields: Union[
            PersonSearchDocumentGraphQLField,
            "BrowsePathFields",
            "PersonHighlightFields",
            "SearchScoreDetailsFields",
        ]
    ) -> "PersonSearchDocumentFields":
        """Subfields should come from the PersonSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonSearchDocumentFields":
        self._alias = alias
        return self


class PersonSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "PersonSearchDocumentFields":
        return PersonSearchDocumentFields("documents")

    error_message: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField(
        "errorMessage"
    )
    from_: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField("from")
    has_more: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField(
        "paginationToken"
    )
    search_context: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField(
        "searchContext"
    )
    search_index: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField(
        "searchIndex"
    )
    size: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField("size")
    total_count: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            PersonSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "PersonSearchDocumentFields",
        ]
    ) -> "PersonSearchResultFields":
        """Subfields should come from the PersonSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonSearchResultFields":
        self._alias = alias
        return self


class PersonSlackProfileFields(GraphQLField):
    created_at: "PersonSlackProfileGraphQLField" = PersonSlackProfileGraphQLField(
        "createdAt"
    )
    deleted: "PersonSlackProfileGraphQLField" = PersonSlackProfileGraphQLField(
        "deleted"
    )
    entity_id: "PersonSlackProfileGraphQLField" = PersonSlackProfileGraphQLField(
        "entityId"
    )
    real_name: "PersonSlackProfileGraphQLField" = PersonSlackProfileGraphQLField(
        "realName"
    )
    slack_id: "PersonSlackProfileGraphQLField" = PersonSlackProfileGraphQLField(
        "slackId"
    )
    team_id: "PersonSlackProfileGraphQLField" = PersonSlackProfileGraphQLField("teamId")
    username: "PersonSlackProfileGraphQLField" = PersonSlackProfileGraphQLField(
        "username"
    )

    def fields(
        self, *subfields: PersonSlackProfileGraphQLField
    ) -> "PersonSlackProfileFields":
        """Subfields should come from the PersonSlackProfileFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonSlackProfileFields":
        self._alias = alias
        return self


class PersonalizationOptionsFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "PersonalizationOptionsGraphQLField" = (
        PersonalizationOptionsGraphQLField("createdAt")
    )
    entity_id: "PersonalizationOptionsGraphQLField" = (
        PersonalizationOptionsGraphQLField("entityId")
    )

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    @classmethod
    def onboarding(cls) -> "OnboardingExperienceFields":
        return OnboardingExperienceFields("onboarding")

    persona: "PersonalizationOptionsGraphQLField" = PersonalizationOptionsGraphQLField(
        "persona"
    )

    def fields(
        self,
        *subfields: Union[
            PersonalizationOptionsGraphQLField,
            "AuditStampFields",
            "OnboardingExperienceFields",
        ]
    ) -> "PersonalizationOptionsFields":
        """Subfields should come from the PersonalizationOptionsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonalizationOptionsFields":
        self._alias = alias
        return self


class PersonalizationOptionsBaseInterface(GraphQLField):
    created_at: "PersonalizationOptionsBaseGraphQLField" = (
        PersonalizationOptionsBaseGraphQLField("createdAt")
    )
    entity_id: "PersonalizationOptionsBaseGraphQLField" = (
        PersonalizationOptionsBaseGraphQLField("entityId")
    )

    def fields(
        self, *subfields: PersonalizationOptionsBaseGraphQLField
    ) -> "PersonalizationOptionsBaseInterface":
        """Subfields should come from the PersonalizationOptionsBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonalizationOptionsBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "PersonalizationOptionsBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class PersonalizationTraitInterface(GraphQLField):
    @classmethod
    def activity(cls) -> "PersonActivityFields":
        return PersonActivityFields("activity")

    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "PersonalizationTraitGraphQLField" = PersonalizationTraitGraphQLField(
        "createdAt"
    )
    deleted_at: "PersonalizationTraitGraphQLField" = PersonalizationTraitGraphQLField(
        "deletedAt"
    )
    display_name: "PersonalizationTraitGraphQLField" = PersonalizationTraitGraphQLField(
        "displayName"
    )
    entity_type: "PersonalizationTraitGraphQLField" = PersonalizationTraitGraphQLField(
        "entityType"
    )

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "PersonalizationTraitGraphQLField" = PersonalizationTraitGraphQLField("id")
    is_deleted: "PersonalizationTraitGraphQLField" = PersonalizationTraitGraphQLField(
        "isDeleted"
    )

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    last_ingested_at: "PersonalizationTraitGraphQLField" = (
        PersonalizationTraitGraphQLField("lastIngestedAt")
    )
    last_modified_at: "PersonalizationTraitGraphQLField" = (
        PersonalizationTraitGraphQLField("lastModifiedAt")
    )

    @classmethod
    def logical_id(cls) -> "PersonLogicalIdFields":
        return PersonLogicalIdFields("logical_id")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def organization(cls) -> "PersonOrganizationFields":
        return PersonOrganizationFields("organization")

    @classmethod
    def personalization(cls) -> "PersonalizationOptionsFields":
        return PersonalizationOptionsFields("personalization")

    @classmethod
    def properties(cls) -> "PersonPropertiesFields":
        return PersonPropertiesFields("properties")

    @classmethod
    def saved_queries(cls) -> "SavedLiveQueryFields":
        return SavedLiveQueryFields("saved_queries")

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            PersonalizationTraitGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonActivityFields",
            "PersonConnectionFields",
            "PersonLogicalIdFields",
            "PersonOrganizationFields",
            "PersonPropertiesFields",
            "PersonalizationOptionsFields",
            "SavedLiveQueryFields",
        ]
    ) -> "PersonalizationTraitInterface":
        """Subfields should come from the PersonalizationTraitInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonalizationTraitInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "PersonalizationTraitInterface":
        self._inline_fragments[type_name] = subfields
        return self


class PipelineFields(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def azure_data_factory_pipeline(cls) -> "AzureDataFactoryPipelineFields":
        return AzureDataFactoryPipelineFields("azure_data_factory_pipeline")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "PipelineGraphQLField" = PipelineGraphQLField("createdAt")
    deleted_at: "PipelineGraphQLField" = PipelineGraphQLField("deletedAt")
    display_name: "PipelineGraphQLField" = PipelineGraphQLField("displayName")
    entity_type: "PipelineGraphQLField" = PipelineGraphQLField("entityType")

    @classmethod
    def fivetran(cls) -> "FivetranPipelineFields":
        return FivetranPipelineFields("fivetran")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def force_shown(cls) -> "AuditStampFields":
        return AuditStampFields("force_shown")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "PipelineGraphQLField" = PipelineGraphQLField("id")

    @classmethod
    def informatica_mapping(cls) -> "InformaticaMappingFields":
        return InformaticaMappingFields("informatica_mapping")

    is_complete: "PipelineGraphQLField" = PipelineGraphQLField("isComplete")
    is_deleted: "PipelineGraphQLField" = PipelineGraphQLField("isDeleted")
    is_production: "PipelineGraphQLField" = PipelineGraphQLField("isProduction")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    last_ingested_at: "PipelineGraphQLField" = PipelineGraphQLField("lastIngestedAt")
    last_modified_at: "PipelineGraphQLField" = PipelineGraphQLField("lastModifiedAt")

    @classmethod
    def logical_id(cls) -> "PipelineLogicalIdFields":
        return PipelineLogicalIdFields("logical_id")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def power_bi_dataflow(cls) -> "PowerBIDataflowFields":
        return PowerBIDataflowFields("power_bi_dataflow")

    @classmethod
    def source_info(cls) -> "SourceInfoFields":
        return SourceInfoFields("source_info")

    @classmethod
    def spark(cls) -> "SparkJobFields":
        return SparkJobFields("spark")

    @classmethod
    def structure(cls) -> "AssetStructureFields":
        return AssetStructureFields("structure")

    @classmethod
    def system_contacts(cls) -> "SystemContactsFields":
        return SystemContactsFields("system_contacts")

    @classmethod
    def system_description(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("system_description")

    system_tag_values: "PipelineGraphQLField" = PipelineGraphQLField("systemTagValues")

    @classmethod
    def system_tags(cls) -> "SystemTagsFields":
        return SystemTagsFields("system_tags")

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            PipelineGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "AssetStructureFields",
            "AuditStampFields",
            "AzureDataFactoryPipelineFields",
            "BrowsePathFields",
            "FivetranPipelineFields",
            "HashtagFields",
            "InformaticaMappingFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "PipelineLogicalIdFields",
            "PowerBIDataflowFields",
            "SourceInfoFields",
            "SparkJobFields",
            "SystemContactsFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
        ]
    ) -> "PipelineFields":
        """Subfields should come from the PipelineFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineFields":
        self._alias = alias
        return self


class PipelineHighlightFields(GraphQLField):
    contact_display_names: "PipelineHighlightGraphQLField" = (
        PipelineHighlightGraphQLField("contactDisplayNames")
    )
    description: "PipelineHighlightGraphQLField" = PipelineHighlightGraphQLField(
        "description"
    )
    governed_tags: "PipelineHighlightGraphQLField" = PipelineHighlightGraphQLField(
        "governedTags"
    )
    hashtags: "PipelineHighlightGraphQLField" = PipelineHighlightGraphQLField(
        "hashtags"
    )
    name: "PipelineHighlightGraphQLField" = PipelineHighlightGraphQLField("name")
    pipeline_id: "PipelineHighlightGraphQLField" = PipelineHighlightGraphQLField(
        "pipelineId"
    )

    def fields(
        self, *subfields: PipelineHighlightGraphQLField
    ) -> "PipelineHighlightFields":
        """Subfields should come from the PipelineHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineHighlightFields":
        self._alias = alias
        return self


class PipelineInfoFields(GraphQLField):
    created_at: "PipelineInfoGraphQLField" = PipelineInfoGraphQLField("createdAt")
    entity_id: "PipelineInfoGraphQLField" = PipelineInfoGraphQLField("entityId")

    @classmethod
    def pipeline_mapping(cls) -> "PipelineMappingFields":
        return PipelineMappingFields("pipeline_mapping")

    def fields(
        self, *subfields: Union[PipelineInfoGraphQLField, "PipelineMappingFields"]
    ) -> "PipelineInfoFields":
        """Subfields should come from the PipelineInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineInfoFields":
        self._alias = alias
        return self


class PipelineLogicalIdFields(GraphQLField):
    name: "PipelineLogicalIdGraphQLField" = PipelineLogicalIdGraphQLField("name")
    type: "PipelineLogicalIdGraphQLField" = PipelineLogicalIdGraphQLField("type")

    def fields(
        self, *subfields: PipelineLogicalIdGraphQLField
    ) -> "PipelineLogicalIdFields":
        """Subfields should come from the PipelineLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineLogicalIdFields":
        self._alias = alias
        return self


class PipelineMappingFields(GraphQLField):
    is_virtual: "PipelineMappingGraphQLField" = PipelineMappingGraphQLField("isVirtual")

    @classmethod
    def pipeline(cls) -> "PipelineFields":
        return PipelineFields("pipeline")

    pipeline_entity_id: "PipelineMappingGraphQLField" = PipelineMappingGraphQLField(
        "pipelineEntityId"
    )
    source_entity_id: "PipelineMappingGraphQLField" = PipelineMappingGraphQLField(
        "sourceEntityId"
    )

    def fields(
        self, *subfields: Union[PipelineMappingGraphQLField, "PipelineFields"]
    ) -> "PipelineMappingFields":
        """Subfields should come from the PipelineMappingFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineMappingFields":
        self._alias = alias
        return self


class PipelineSearchDocumentFields(GraphQLField):
    browse_path_hierarchy: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browse_path_segments: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    contact_display_names: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("contactDisplayNames")
    )
    description: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("description")
    )
    document_id: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("documentId")
    )
    domain_display_names: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("domainDisplayNames")
    )
    domains: "PipelineSearchDocumentGraphQLField" = PipelineSearchDocumentGraphQLField(
        "domains"
    )
    embedded_string_1: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("embeddedString_1")
    )
    embedded_string_2: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("embeddedString_2")
    )
    entity_id: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("entityId")
    )
    governed_tags: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("governedTags")
    )
    has_column_lineage: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("hasColumnLineage")
    )
    has_table_lineage: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("hasTableLineage")
    )
    hashtags: "PipelineSearchDocumentGraphQLField" = PipelineSearchDocumentGraphQLField(
        "hashtags"
    )

    @classmethod
    def highlight(cls) -> "PipelineHighlightFields":
        return PipelineHighlightFields("highlight")

    is_complete: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("isComplete")
    )
    is_deleted: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("isDeleted")
    )
    is_production: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("isProduction")
    )
    knowledge_card_count: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("knowledgeCardCount")
    )
    last_refreshed: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("lastRefreshed")
    )
    name: "PipelineSearchDocumentGraphQLField" = PipelineSearchDocumentGraphQLField(
        "name"
    )
    overall_data_quality: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("overallDataQuality")
    )
    pagination_token: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("paginationToken")
    )
    pipeline_id: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("pipelineId")
    )

    @classmethod
    def score_details(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("score_details")

    type: "PipelineSearchDocumentGraphQLField" = PipelineSearchDocumentGraphQLField(
        "type"
    )
    view_count: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("viewCount")
    )

    def fields(
        self,
        *subfields: Union[
            PipelineSearchDocumentGraphQLField,
            "BrowsePathFields",
            "PipelineHighlightFields",
            "SearchScoreDetailsFields",
        ]
    ) -> "PipelineSearchDocumentFields":
        """Subfields should come from the PipelineSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineSearchDocumentFields":
        self._alias = alias
        return self


class PipelineSearchInfoFields(GraphQLField):
    pipeline_id: "PipelineSearchInfoGraphQLField" = PipelineSearchInfoGraphQLField(
        "pipelineId"
    )

    def fields(
        self, *subfields: PipelineSearchInfoGraphQLField
    ) -> "PipelineSearchInfoFields":
        """Subfields should come from the PipelineSearchInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineSearchInfoFields":
        self._alias = alias
        return self


class PipelineSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "PipelineSearchDocumentFields":
        return PipelineSearchDocumentFields("documents")

    error_message: "PipelineSearchResultGraphQLField" = (
        PipelineSearchResultGraphQLField("errorMessage")
    )
    from_: "PipelineSearchResultGraphQLField" = PipelineSearchResultGraphQLField("from")
    has_more: "PipelineSearchResultGraphQLField" = PipelineSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "PipelineSearchResultGraphQLField" = (
        PipelineSearchResultGraphQLField("paginationToken")
    )
    search_context: "PipelineSearchResultGraphQLField" = (
        PipelineSearchResultGraphQLField("searchContext")
    )
    search_index: "PipelineSearchResultGraphQLField" = PipelineSearchResultGraphQLField(
        "searchIndex"
    )
    size: "PipelineSearchResultGraphQLField" = PipelineSearchResultGraphQLField("size")
    total_count: "PipelineSearchResultGraphQLField" = PipelineSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            PipelineSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "PipelineSearchDocumentFields",
        ]
    ) -> "PipelineSearchResultFields":
        """Subfields should come from the PipelineSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineSearchResultFields":
        self._alias = alias
        return self


class PowerBIColumnFields(GraphQLField):
    field: "PowerBIColumnGraphQLField" = PowerBIColumnGraphQLField("field")
    type: "PowerBIColumnGraphQLField" = PowerBIColumnGraphQLField("type")

    def fields(self, *subfields: PowerBIColumnGraphQLField) -> "PowerBIColumnFields":
        """Subfields should come from the PowerBIColumnFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIColumnFields":
        self._alias = alias
        return self


class PowerBIDataflowFields(GraphQLField):
    configured_by: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField(
        "configuredBy"
    )
    dataflow_url: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField(
        "dataflowUrl"
    )
    description: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField(
        "description"
    )
    document: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField("document")
    last_refreshed: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField(
        "lastRefreshed"
    )
    modified_by: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField(
        "modifiedBy"
    )
    modified_date_time: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField(
        "modifiedDateTime"
    )
    name: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField("name")

    @classmethod
    def refresh_schedule(cls) -> "PowerBIRefreshScheduleFields":
        return PowerBIRefreshScheduleFields("refresh_schedule")

    def fields(
        self,
        *subfields: Union[PowerBIDataflowGraphQLField, "PowerBIRefreshScheduleFields"]
    ) -> "PowerBIDataflowFields":
        """Subfields should come from the PowerBIDataflowFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIDataflowFields":
        self._alias = alias
        return self


class PowerBIDatasetFields(GraphQLField):
    configured_by: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField(
        "configuredBy"
    )
    created_at: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField("createdAt")
    created_date: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField(
        "createdDate"
    )
    description: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField(
        "description"
    )

    @classmethod
    def downstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstream_of_type", arguments=cleared_arguments
        )

    @classmethod
    def endorsement(cls) -> "PowerBiEndorsementFields":
        return PowerBiEndorsementFields("endorsement")

    entity_id: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField("entityId")

    @classmethod
    def field_crowd_sourced_descriptions(
        cls, *, filters: Optional[KnowledgeCardConnectionFilterInput] = None
    ) -> "KnowledgeCardFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardFields(
            "field_crowd_sourced_descriptions", arguments=cleared_arguments
        )

    last_refreshed: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField(
        "lastRefreshed"
    )
    name: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField("name")

    @classmethod
    def parameters(cls) -> "PowerBIDatasetParameterFields":
        return PowerBIDatasetParameterFields("parameters")

    @classmethod
    def refresh_schedule(cls) -> "PowerBIRefreshScheduleFields":
        return PowerBIRefreshScheduleFields("refresh_schedule")

    @classmethod
    def sensitivity_label(cls) -> "PowerBiSensitivityLabelFields":
        return PowerBiSensitivityLabelFields("sensitivity_label")

    source_datasets: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField(
        "sourceDatasets"
    )

    @classmethod
    def tables(cls) -> "PowerBIDatasetTableFields":
        return PowerBIDatasetTableFields("tables")

    @classmethod
    def upstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstream_of_type", arguments=cleared_arguments
        )

    url: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField("url")

    @classmethod
    def viewer_can_add_field_description_for(
        cls, table_name: str, *, field_paths: Optional[str] = None
    ) -> "FieldPathPermissionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "fieldPaths": {"type": "String", "value": field_paths},
            "tableName": {"type": "String!", "value": table_name},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FieldPathPermissionFields(
            "viewer_can_add_field_description_for", arguments=cleared_arguments
        )

    @classmethod
    def workspace(cls) -> "PowerBiWorkspaceFields":
        return PowerBiWorkspaceFields("workspace")

    def fields(
        self,
        *subfields: Union[
            PowerBIDatasetGraphQLField,
            "EntityLineageConnectionFields",
            "FieldPathPermissionFields",
            "KnowledgeCardFields",
            "PowerBIDatasetParameterFields",
            "PowerBIDatasetTableFields",
            "PowerBIRefreshScheduleFields",
            "PowerBiEndorsementFields",
            "PowerBiSensitivityLabelFields",
            "PowerBiWorkspaceFields",
        ]
    ) -> "PowerBIDatasetFields":
        """Subfields should come from the PowerBIDatasetFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIDatasetFields":
        self._alias = alias
        return self


class PowerBIDatasetParameterFields(GraphQLField):
    is_required: "PowerBIDatasetParameterGraphQLField" = (
        PowerBIDatasetParameterGraphQLField("isRequired")
    )
    name: "PowerBIDatasetParameterGraphQLField" = PowerBIDatasetParameterGraphQLField(
        "name"
    )
    type: "PowerBIDatasetParameterGraphQLField" = PowerBIDatasetParameterGraphQLField(
        "type"
    )
    value: "PowerBIDatasetParameterGraphQLField" = PowerBIDatasetParameterGraphQLField(
        "value"
    )

    def fields(
        self, *subfields: PowerBIDatasetParameterGraphQLField
    ) -> "PowerBIDatasetParameterFields":
        """Subfields should come from the PowerBIDatasetParameterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIDatasetParameterFields":
        self._alias = alias
        return self


class PowerBIDatasetSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "VirtualViewSearchDocumentFields":
        return VirtualViewSearchDocumentFields("documents")

    error_message: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("errorMessage")
    )
    from_: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("from")
    )
    has_more: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("paginationToken")
    )
    search_context: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("searchContext")
    )
    search_index: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("searchIndex")
    )
    size: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("size")
    )
    total_count: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            PowerBIDatasetSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "VirtualViewSearchDocumentFields",
        ]
    ) -> "PowerBIDatasetSearchResultFields":
        """Subfields should come from the PowerBIDatasetSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIDatasetSearchResultFields":
        self._alias = alias
        return self


class PowerBIDatasetTableFields(GraphQLField):
    @classmethod
    def columns(cls) -> "PowerBIColumnFields":
        return PowerBIColumnFields("columns")

    expression: "PowerBIDatasetTableGraphQLField" = PowerBIDatasetTableGraphQLField(
        "expression"
    )

    @classmethod
    def measures(cls) -> "PowerBIMeasureFields":
        return PowerBIMeasureFields("measures")

    name: "PowerBIDatasetTableGraphQLField" = PowerBIDatasetTableGraphQLField("name")
    sources: "PowerBIDatasetTableGraphQLField" = PowerBIDatasetTableGraphQLField(
        "sources"
    )

    def fields(
        self,
        *subfields: Union[
            PowerBIDatasetTableGraphQLField,
            "PowerBIColumnFields",
            "PowerBIMeasureFields",
        ]
    ) -> "PowerBIDatasetTableFields":
        """Subfields should come from the PowerBIDatasetTableFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIDatasetTableFields":
        self._alias = alias
        return self


class PowerBIMeasureFields(GraphQLField):
    description: "PowerBIMeasureGraphQLField" = PowerBIMeasureGraphQLField(
        "description"
    )
    expression: "PowerBIMeasureGraphQLField" = PowerBIMeasureGraphQLField("expression")
    field: "PowerBIMeasureGraphQLField" = PowerBIMeasureGraphQLField("field")

    def fields(self, *subfields: PowerBIMeasureGraphQLField) -> "PowerBIMeasureFields":
        """Subfields should come from the PowerBIMeasureFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIMeasureFields":
        self._alias = alias
        return self


class PowerBIRefreshScheduleFields(GraphQLField):
    days: "PowerBIRefreshScheduleGraphQLField" = PowerBIRefreshScheduleGraphQLField(
        "days"
    )
    enabled: "PowerBIRefreshScheduleGraphQLField" = PowerBIRefreshScheduleGraphQLField(
        "enabled"
    )
    frequency_in_minutes: "PowerBIRefreshScheduleGraphQLField" = (
        PowerBIRefreshScheduleGraphQLField("frequencyInMinutes")
    )
    local_time_zone_id: "PowerBIRefreshScheduleGraphQLField" = (
        PowerBIRefreshScheduleGraphQLField("localTimeZoneId")
    )
    notify_option: "PowerBIRefreshScheduleGraphQLField" = (
        PowerBIRefreshScheduleGraphQLField("notifyOption")
    )
    times: "PowerBIRefreshScheduleGraphQLField" = PowerBIRefreshScheduleGraphQLField(
        "times"
    )

    def fields(
        self, *subfields: PowerBIRefreshScheduleGraphQLField
    ) -> "PowerBIRefreshScheduleFields":
        """Subfields should come from the PowerBIRefreshScheduleFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIRefreshScheduleFields":
        self._alias = alias
        return self


class PowerBiAppFields(GraphQLField):
    id: "PowerBiAppGraphQLField" = PowerBiAppGraphQLField("id")
    name: "PowerBiAppGraphQLField" = PowerBiAppGraphQLField("name")

    def fields(self, *subfields: PowerBiAppGraphQLField) -> "PowerBiAppFields":
        """Subfields should come from the PowerBiAppFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiAppFields":
        self._alias = alias
        return self


class PowerBiEndorsementFields(GraphQLField):
    certified_by: "PowerBiEndorsementGraphQLField" = PowerBiEndorsementGraphQLField(
        "certifiedBy"
    )
    endorsement: "PowerBiEndorsementGraphQLField" = PowerBiEndorsementGraphQLField(
        "endorsement"
    )

    def fields(
        self, *subfields: PowerBiEndorsementGraphQLField
    ) -> "PowerBiEndorsementFields":
        """Subfields should come from the PowerBiEndorsementFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiEndorsementFields":
        self._alias = alias
        return self


class PowerBiInfoFields(GraphQLField):
    @classmethod
    def app(cls) -> "PowerBiAppFields":
        return PowerBiAppFields("app")

    created_by: "PowerBiInfoGraphQLField" = PowerBiInfoGraphQLField("createdBy")
    created_date_time: "PowerBiInfoGraphQLField" = PowerBiInfoGraphQLField(
        "createdDateTime"
    )

    @classmethod
    def endorsement(cls) -> "PowerBiEndorsementFields":
        return PowerBiEndorsementFields("endorsement")

    modified_by: "PowerBiInfoGraphQLField" = PowerBiInfoGraphQLField("modifiedBy")
    modified_date_time: "PowerBiInfoGraphQLField" = PowerBiInfoGraphQLField(
        "modifiedDateTime"
    )
    power_bi_dashboard_type: "PowerBiInfoGraphQLField" = PowerBiInfoGraphQLField(
        "powerBiDashboardType"
    )

    @classmethod
    def sensitivity_label(cls) -> "PowerBiSensitivityLabelFields":
        return PowerBiSensitivityLabelFields("sensitivity_label")

    @classmethod
    def subscriptions(cls) -> "PowerBiSubscriptionFields":
        return PowerBiSubscriptionFields("subscriptions")

    @classmethod
    def workspace(cls) -> "PowerBiWorkspaceFields":
        return PowerBiWorkspaceFields("workspace")

    def fields(
        self,
        *subfields: Union[
            PowerBiInfoGraphQLField,
            "PowerBiAppFields",
            "PowerBiEndorsementFields",
            "PowerBiSensitivityLabelFields",
            "PowerBiSubscriptionFields",
            "PowerBiWorkspaceFields",
        ]
    ) -> "PowerBiInfoFields":
        """Subfields should come from the PowerBiInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiInfoFields":
        self._alias = alias
        return self


class PowerBiSensitivityLabelFields(GraphQLField):
    description: "PowerBiSensitivityLabelGraphQLField" = (
        PowerBiSensitivityLabelGraphQLField("description")
    )
    id: "PowerBiSensitivityLabelGraphQLField" = PowerBiSensitivityLabelGraphQLField(
        "id"
    )
    name: "PowerBiSensitivityLabelGraphQLField" = PowerBiSensitivityLabelGraphQLField(
        "name"
    )

    def fields(
        self, *subfields: PowerBiSensitivityLabelGraphQLField
    ) -> "PowerBiSensitivityLabelFields":
        """Subfields should come from the PowerBiSensitivityLabelFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiSensitivityLabelFields":
        self._alias = alias
        return self


class PowerBiSubscriptionFields(GraphQLField):
    artifact_display_name: "PowerBiSubscriptionGraphQLField" = (
        PowerBiSubscriptionGraphQLField("artifactDisplayName")
    )
    end_date: "PowerBiSubscriptionGraphQLField" = PowerBiSubscriptionGraphQLField(
        "endDate"
    )
    frequency: "PowerBiSubscriptionGraphQLField" = PowerBiSubscriptionGraphQLField(
        "frequency"
    )
    id: "PowerBiSubscriptionGraphQLField" = PowerBiSubscriptionGraphQLField("id")
    start_date: "PowerBiSubscriptionGraphQLField" = PowerBiSubscriptionGraphQLField(
        "startDate"
    )
    sub_artifact_display_name: "PowerBiSubscriptionGraphQLField" = (
        PowerBiSubscriptionGraphQLField("subArtifactDisplayName")
    )
    title: "PowerBiSubscriptionGraphQLField" = PowerBiSubscriptionGraphQLField("title")

    @classmethod
    def users(cls) -> "PowerBiSubscriptionUserFields":
        return PowerBiSubscriptionUserFields("users")

    def fields(
        self,
        *subfields: Union[
            PowerBiSubscriptionGraphQLField, "PowerBiSubscriptionUserFields"
        ]
    ) -> "PowerBiSubscriptionFields":
        """Subfields should come from the PowerBiSubscriptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiSubscriptionFields":
        self._alias = alias
        return self


class PowerBiSubscriptionUserFields(GraphQLField):
    display_name: "PowerBiSubscriptionUserGraphQLField" = (
        PowerBiSubscriptionUserGraphQLField("displayName")
    )
    email_address: "PowerBiSubscriptionUserGraphQLField" = (
        PowerBiSubscriptionUserGraphQLField("emailAddress")
    )

    def fields(
        self, *subfields: PowerBiSubscriptionUserGraphQLField
    ) -> "PowerBiSubscriptionUserFields":
        """Subfields should come from the PowerBiSubscriptionUserFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiSubscriptionUserFields":
        self._alias = alias
        return self


class PowerBiUserInterface(GraphQLField):
    display_name: "PowerBiUserGraphQLField" = PowerBiUserGraphQLField("displayName")
    email_address: "PowerBiUserGraphQLField" = PowerBiUserGraphQLField("emailAddress")

    def fields(self, *subfields: PowerBiUserGraphQLField) -> "PowerBiUserInterface":
        """Subfields should come from the PowerBiUserInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiUserInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "PowerBiUserInterface":
        self._inline_fragments[type_name] = subfields
        return self


class PowerBiWorkspaceFields(GraphQLField):
    name: "PowerBiWorkspaceGraphQLField" = PowerBiWorkspaceGraphQLField("name")
    url: "PowerBiWorkspaceGraphQLField" = PowerBiWorkspaceGraphQLField("url")

    @classmethod
    def users(cls) -> "PowerBiWorkspaceUserFields":
        return PowerBiWorkspaceUserFields("users")

    def fields(
        self,
        *subfields: Union[PowerBiWorkspaceGraphQLField, "PowerBiWorkspaceUserFields"]
    ) -> "PowerBiWorkspaceFields":
        """Subfields should come from the PowerBiWorkspaceFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiWorkspaceFields":
        self._alias = alias
        return self


class PowerBiWorkspaceUserFields(GraphQLField):
    display_name: "PowerBiWorkspaceUserGraphQLField" = PowerBiWorkspaceUserGraphQLField(
        "displayName"
    )
    email_address: "PowerBiWorkspaceUserGraphQLField" = (
        PowerBiWorkspaceUserGraphQLField("emailAddress")
    )
    group_user_access_right: "PowerBiWorkspaceUserGraphQLField" = (
        PowerBiWorkspaceUserGraphQLField("groupUserAccessRight")
    )

    def fields(
        self, *subfields: PowerBiWorkspaceUserGraphQLField
    ) -> "PowerBiWorkspaceUserFields":
        """Subfields should come from the PowerBiWorkspaceUserFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiWorkspaceUserFields":
        self._alias = alias
        return self


class QueryCountFields(GraphQLField):
    count: "QueryCountGraphQLField" = QueryCountGraphQLField("count")
    level: "QueryCountGraphQLField" = QueryCountGraphQLField("level")
    percentile: "QueryCountGraphQLField" = QueryCountGraphQLField("percentile")

    def fields(self, *subfields: QueryCountGraphQLField) -> "QueryCountFields":
        """Subfields should come from the QueryCountFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryCountFields":
        self._alias = alias
        return self


class QueryCountPercentileFields(GraphQLField):
    last_7_days: "QueryCountPercentileGraphQLField" = QueryCountPercentileGraphQLField(
        "last7Days"
    )
    last_24_hours: "QueryCountPercentileGraphQLField" = (
        QueryCountPercentileGraphQLField("last24Hours")
    )
    last_30_days: "QueryCountPercentileGraphQLField" = QueryCountPercentileGraphQLField(
        "last30Days"
    )
    last_90_days: "QueryCountPercentileGraphQLField" = QueryCountPercentileGraphQLField(
        "last90Days"
    )
    last_365_days: "QueryCountPercentileGraphQLField" = (
        QueryCountPercentileGraphQLField("last365Days")
    )

    def fields(
        self, *subfields: QueryCountPercentileGraphQLField
    ) -> "QueryCountPercentileFields":
        """Subfields should come from the QueryCountPercentileFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryCountPercentileFields":
        self._alias = alias
        return self


class QueryCountsFields(GraphQLField):
    @classmethod
    def last_7_days(cls) -> "QueryCountFields":
        return QueryCountFields("last_7_days")

    @classmethod
    def last_24_hours(cls) -> "QueryCountFields":
        return QueryCountFields("last_24_hours")

    @classmethod
    def last_30_days(cls) -> "QueryCountFields":
        return QueryCountFields("last_30_days")

    @classmethod
    def last_90_days(cls) -> "QueryCountFields":
        return QueryCountFields("last_90_days")

    @classmethod
    def last_365_days(cls) -> "QueryCountFields":
        return QueryCountFields("last_365_days")

    def fields(
        self, *subfields: Union[QueryCountsGraphQLField, "QueryCountFields"]
    ) -> "QueryCountsFields":
        """Subfields should come from the QueryCountsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryCountsFields":
        self._alias = alias
        return self


class QueryExplainerFields(GraphQLField):
    explanation: "QueryExplainerGraphQLField" = QueryExplainerGraphQLField(
        "explanation"
    )
    explanation_id: "QueryExplainerGraphQLField" = QueryExplainerGraphQLField(
        "explanationId"
    )

    @classmethod
    def tokenized_content(cls) -> "QueryExplainerTokenizedContentFields":
        return QueryExplainerTokenizedContentFields("tokenized_content")

    type: "QueryExplainerGraphQLField" = QueryExplainerGraphQLField("type")

    def fields(
        self,
        *subfields: Union[
            QueryExplainerGraphQLField, "QueryExplainerTokenizedContentFields"
        ]
    ) -> "QueryExplainerFields":
        """Subfields should come from the QueryExplainerFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryExplainerFields":
        self._alias = alias
        return self


class QueryExplainerTokenizedContentFields(GraphQLField):
    explanation: "QueryExplainerTokenizedContentGraphQLField" = (
        QueryExplainerTokenizedContentGraphQLField("explanation")
    )

    def fields(
        self, *subfields: QueryExplainerTokenizedContentGraphQLField
    ) -> "QueryExplainerTokenizedContentFields":
        """Subfields should come from the QueryExplainerTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryExplainerTokenizedContentFields":
        self._alias = alias
        return self


class QueryInfoFields(GraphQLField):
    bytes_read: "QueryInfoGraphQLField" = QueryInfoGraphQLField("bytesRead")
    bytes_written: "QueryInfoGraphQLField" = QueryInfoGraphQLField("bytesWritten")
    cost: "QueryInfoGraphQLField" = QueryInfoGraphQLField("cost")
    elapsed_time: "QueryInfoGraphQLField" = QueryInfoGraphQLField("elapsedTime")
    entity_ids: "QueryInfoGraphQLField" = QueryInfoGraphQLField("entityIds")
    id: "QueryInfoGraphQLField" = QueryInfoGraphQLField("id")
    issued_at: "QueryInfoGraphQLField" = QueryInfoGraphQLField("issuedAt")
    issued_by: "QueryInfoGraphQLField" = QueryInfoGraphQLField("issuedBy")
    issued_by_email: "QueryInfoGraphQLField" = QueryInfoGraphQLField("issuedByEmail")

    @classmethod
    def issued_to_assets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("issued_to_assets", arguments=cleared_arguments)

    platform: "QueryInfoGraphQLField" = QueryInfoGraphQLField("platform")
    query: "QueryInfoGraphQLField" = QueryInfoGraphQLField("query")

    @classmethod
    def query_description(cls) -> "KnowledgeCardFields":
        return KnowledgeCardFields("query_description")

    @classmethod
    def query_descriptions(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "query_descriptions", arguments=cleared_arguments
        )

    rows_read: "QueryInfoGraphQLField" = QueryInfoGraphQLField("rowsRead")
    rows_written: "QueryInfoGraphQLField" = QueryInfoGraphQLField("rowsWritten")

    def fields(
        self,
        *subfields: Union[
            QueryInfoGraphQLField,
            "EntityConnectionFields",
            "KnowledgeCardConnectionFields",
            "KnowledgeCardFields",
        ]
    ) -> "QueryInfoFields":
        """Subfields should come from the QueryInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryInfoFields":
        self._alias = alias
        return self


class QueryInfoConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "QueryInfoEdgeFields":
        return QueryInfoEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "QueryInfoConnectionGraphQLField" = QueryInfoConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            QueryInfoConnectionGraphQLField, "PageInfoFields", "QueryInfoEdgeFields"
        ]
    ) -> "QueryInfoConnectionFields":
        """Subfields should come from the QueryInfoConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryInfoConnectionFields":
        self._alias = alias
        return self


class QueryInfoEdgeFields(GraphQLField):
    cursor: "QueryInfoEdgeGraphQLField" = QueryInfoEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "QueryInfoFields":
        return QueryInfoFields("node")

    def fields(
        self, *subfields: Union[QueryInfoEdgeGraphQLField, "QueryInfoFields"]
    ) -> "QueryInfoEdgeFields":
        """Subfields should come from the QueryInfoEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryInfoEdgeFields":
        self._alias = alias
        return self


class QueryKnowledgeCardFields(GraphQLField):
    @classmethod
    def explanations(cls) -> "QueryExplainerFields":
        return QueryExplainerFields("explanations")

    is_generated: "QueryKnowledgeCardGraphQLField" = QueryKnowledgeCardGraphQLField(
        "isGenerated"
    )
    is_marked_as_curated: "QueryKnowledgeCardGraphQLField" = (
        QueryKnowledgeCardGraphQLField("isMarkedAsCurated")
    )
    is_same_as_original_query: "QueryKnowledgeCardGraphQLField" = (
        QueryKnowledgeCardGraphQLField("isSameAsOriginalQuery")
    )
    parsed_statement: "QueryKnowledgeCardGraphQLField" = QueryKnowledgeCardGraphQLField(
        "parsedStatement"
    )
    query: "QueryKnowledgeCardGraphQLField" = QueryKnowledgeCardGraphQLField("query")
    query_id: "QueryKnowledgeCardGraphQLField" = QueryKnowledgeCardGraphQLField(
        "queryId"
    )

    @classmethod
    def query_info(cls) -> "QueryInfoFields":
        return QueryInfoFields("query_info")

    @classmethod
    def query_info_copy(cls) -> "QueryInfoFields":
        return QueryInfoFields("query_info_copy")

    title: "QueryKnowledgeCardGraphQLField" = QueryKnowledgeCardGraphQLField("title")

    def fields(
        self,
        *subfields: Union[
            QueryKnowledgeCardGraphQLField, "QueryExplainerFields", "QueryInfoFields"
        ]
    ) -> "QueryKnowledgeCardFields":
        """Subfields should come from the QueryKnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryKnowledgeCardFields":
        self._alias = alias
        return self


class QueryResultFields(GraphQLField):
    columns: "QueryResultGraphQLField" = QueryResultGraphQLField("columns")
    has_more: "QueryResultGraphQLField" = QueryResultGraphQLField("hasMore")

    @classmethod
    def rows(cls) -> "ResultRowFields":
        return ResultRowFields("rows")

    def fields(
        self, *subfields: Union[QueryResultGraphQLField, "ResultRowFields"]
    ) -> "QueryResultFields":
        """Subfields should come from the QueryResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryResultFields":
        self._alias = alias
        return self


class RecentUserActivitiesFields(GraphQLField):
    @classmethod
    def actors(cls) -> "UserActivityActorInfoFields":
        return UserActivityActorInfoFields("actors")

    @classmethod
    def aggregated_activities(cls) -> "UserActivityFields":
        return UserActivityFields("aggregated_activities")

    def fields(
        self,
        *subfields: Union[
            RecentUserActivitiesGraphQLField,
            "UserActivityActorInfoFields",
            "UserActivityFields",
        ]
    ) -> "RecentUserActivitiesFields":
        """Subfields should come from the RecentUserActivitiesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "RecentUserActivitiesFields":
        self._alias = alias
        return self


class ResultRowFields(GraphQLField):
    row_id: "ResultRowGraphQLField" = ResultRowGraphQLField("rowId")
    values: "ResultRowGraphQLField" = ResultRowGraphQLField("values")

    def fields(self, *subfields: ResultRowGraphQLField) -> "ResultRowFields":
        """Subfields should come from the ResultRowFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ResultRowFields":
        self._alias = alias
        return self


class RunCrawlerResponseFields(GraphQLField):
    error_message: "RunCrawlerResponseGraphQLField" = RunCrawlerResponseGraphQLField(
        "errorMessage"
    )
    success: "RunCrawlerResponseGraphQLField" = RunCrawlerResponseGraphQLField(
        "success"
    )

    def fields(
        self, *subfields: RunCrawlerResponseGraphQLField
    ) -> "RunCrawlerResponseFields":
        """Subfields should come from the RunCrawlerResponseFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "RunCrawlerResponseFields":
        self._alias = alias
        return self


class SQLExplainerResultFields(GraphQLField):
    business_summary: "SQLExplainerResultGraphQLField" = SQLExplainerResultGraphQLField(
        "businessSummary"
    )
    technical_summary: "SQLExplainerResultGraphQLField" = (
        SQLExplainerResultGraphQLField("technicalSummary")
    )
    title: "SQLExplainerResultGraphQLField" = SQLExplainerResultGraphQLField("title")

    def fields(
        self, *subfields: SQLExplainerResultGraphQLField
    ) -> "SQLExplainerResultFields":
        """Subfields should come from the SQLExplainerResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SQLExplainerResultFields":
        self._alias = alias
        return self


class SSOFields(GraphQLField):
    @classmethod
    def azure_ad(cls) -> "AzureAdSSOFields":
        return AzureAdSSOFields("azure_ad")

    @classmethod
    def google_workspace(cls) -> "GoogleWorkspaceSSOFields":
        return GoogleWorkspaceSSOFields("google_workspace")

    @classmethod
    def ldap(cls) -> "LDAPFields":
        return LDAPFields("ldap")

    @classmethod
    def okta(cls) -> "OktaSSOFields":
        return OktaSSOFields("okta")

    def fields(
        self,
        *subfields: Union[
            SSOGraphQLField,
            "AzureAdSSOFields",
            "GoogleWorkspaceSSOFields",
            "LDAPFields",
            "OktaSSOFields",
        ]
    ) -> "SSOFields":
        """Subfields should come from the SSOFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SSOFields":
        self._alias = alias
        return self


class SampleSearchQuestionFields(GraphQLField):
    question: "SampleSearchQuestionGraphQLField" = SampleSearchQuestionGraphQLField(
        "question"
    )
    response: "SampleSearchQuestionGraphQLField" = SampleSearchQuestionGraphQLField(
        "response"
    )

    @classmethod
    def source_assets(cls) -> "EntityConnectionFields":
        return EntityConnectionFields("source_assets")

    def fields(
        self,
        *subfields: Union[SampleSearchQuestionGraphQLField, "EntityConnectionFields"]
    ) -> "SampleSearchQuestionFields":
        """Subfields should come from the SampleSearchQuestionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SampleSearchQuestionFields":
        self._alias = alias
        return self


class SavedLiveQueryFields(GraphQLField):
    context: "SavedLiveQueryGraphQLField" = SavedLiveQueryGraphQLField("context")

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    facets_json: "SavedLiveQueryGraphQLField" = SavedLiveQueryGraphQLField("facetsJSON")
    id: "SavedLiveQueryGraphQLField" = SavedLiveQueryGraphQLField("id")
    keyword: "SavedLiveQueryGraphQLField" = SavedLiveQueryGraphQLField("keyword")

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    name: "SavedLiveQueryGraphQLField" = SavedLiveQueryGraphQLField("name")

    def fields(
        self, *subfields: Union[SavedLiveQueryGraphQLField, "AuditStampFields"]
    ) -> "SavedLiveQueryFields":
        """Subfields should come from the SavedLiveQueryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SavedLiveQueryFields":
        self._alias = alias
        return self


class SchemaFieldFields(GraphQLField):
    description: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("description")
    field_name: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("fieldName")
    field_path: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("fieldPath")
    is_unique: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("isUnique")
    max_length: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("maxLength")
    native_type: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("nativeType")
    nullable: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("nullable")
    precision: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("precision")

    @classmethod
    def subfields(cls) -> "SchemaFieldFields":
        return SchemaFieldFields("subfields")

    tags: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("tags")

    def fields(
        self, *subfields: Union[SchemaFieldGraphQLField, "SchemaFieldFields"]
    ) -> "SchemaFieldFields":
        """Subfields should come from the SchemaFieldFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SchemaFieldFields":
        self._alias = alias
        return self


class SchemaFieldWithCommonAttributesFields(GraphQLField):
    @classmethod
    def asset_contacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("asset_contacts")

    @classmethod
    def description(cls) -> "UserDefinedResourceDescriptionFields":
        return UserDefinedResourceDescriptionFields("description")

    field_path: "SchemaFieldWithCommonAttributesGraphQLField" = (
        SchemaFieldWithCommonAttributesGraphQLField("fieldPath")
    )

    @classmethod
    def governed_tags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governed_tags", arguments=cleared_arguments
        )

    def fields(
        self,
        *subfields: Union[
            SchemaFieldWithCommonAttributesGraphQLField,
            "AssetContactsFields",
            "UserDefinedResourceConnectionFields",
            "UserDefinedResourceDescriptionFields",
        ]
    ) -> "SchemaFieldWithCommonAttributesFields":
        """Subfields should come from the SchemaFieldWithCommonAttributesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SchemaFieldWithCommonAttributesFields":
        self._alias = alias
        return self


class SearchQueryFields(GraphQLField):
    context: "SearchQueryGraphQLField" = SearchQueryGraphQLField("context")
    facets_json: "SearchQueryGraphQLField" = SearchQueryGraphQLField("facetsJSON")
    id: "SearchQueryGraphQLField" = SearchQueryGraphQLField("id")
    keyword: "SearchQueryGraphQLField" = SearchQueryGraphQLField("keyword")
    name: "SearchQueryGraphQLField" = SearchQueryGraphQLField("name")

    def fields(self, *subfields: SearchQueryGraphQLField) -> "SearchQueryFields":
        """Subfields should come from the SearchQueryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SearchQueryFields":
        self._alias = alias
        return self


class SearchScoreDetailsFields(GraphQLField):
    description: "SearchScoreDetailsGraphQLField" = SearchScoreDetailsGraphQLField(
        "description"
    )

    @classmethod
    def details(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("details")

    value: "SearchScoreDetailsGraphQLField" = SearchScoreDetailsGraphQLField("value")

    def fields(
        self,
        *subfields: Union[SearchScoreDetailsGraphQLField, "SearchScoreDetailsFields"]
    ) -> "SearchScoreDetailsFields":
        """Subfields should come from the SearchScoreDetailsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SearchScoreDetailsFields":
        self._alias = alias
        return self


class SearchStatisticsResultFields(GraphQLField):
    error_message: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("errorMessage")
    )
    has_column_lineage: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("hasColumnLineage")
    )
    has_contact: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("hasContact")
    )
    has_description: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("hasDescription")
    )
    has_governed_tag: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("hasGovernedTag")
    )
    has_table_lineage: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("hasTableLineage")
    )
    search_context: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("searchContext")
    )
    search_index: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("searchIndex")
    )
    total_count: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("totalCount")
    )

    def fields(
        self, *subfields: SearchStatisticsResultGraphQLField
    ) -> "SearchStatisticsResultFields":
        """Subfields should come from the SearchStatisticsResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SearchStatisticsResultFields":
        self._alias = alias
        return self


class SettingsFields(GraphQLField):
    @classmethod
    def authorization(cls) -> "AuthorizationFields":
        return AuthorizationFields("authorization")

    @classmethod
    def custom_metadata_config(cls) -> "CustomMetadataConfigFields":
        return CustomMetadataConfigFields("custom_metadata_config")

    @classmethod
    def custom_user_defined_order_hierarchy(cls) -> "UserSpecifiedOrderingFields":
        return UserSpecifiedOrderingFields("custom_user_defined_order_hierarchy")

    @classmethod
    def non_prod(cls) -> "NonProdFields":
        return NonProdFields("non_prod")

    @classmethod
    def organization(cls) -> "OrganizationFields":
        return OrganizationFields("organization")

    service_accounts: "SettingsGraphQLField" = SettingsGraphQLField("serviceAccounts")

    @classmethod
    def social_login(cls) -> "SocialLoginFields":
        return SocialLoginFields("social_login")

    @classmethod
    def soft_deletion(cls) -> "SoftDeletionFields":
        return SoftDeletionFields("soft_deletion")

    @classmethod
    def sso(cls) -> "SSOFields":
        return SSOFields("sso")

    def fields(
        self,
        *subfields: Union[
            SettingsGraphQLField,
            "AuthorizationFields",
            "CustomMetadataConfigFields",
            "NonProdFields",
            "OrganizationFields",
            "SSOFields",
            "SocialLoginFields",
            "SoftDeletionFields",
            "UserSpecifiedOrderingFields",
        ]
    ) -> "SettingsFields":
        """Subfields should come from the SettingsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SettingsFields":
        self._alias = alias
        return self


class SnowflakeStreamInfoFields(GraphQLField):
    created_at: "SnowflakeStreamInfoGraphQLField" = SnowflakeStreamInfoGraphQLField(
        "createdAt"
    )
    entity_id: "SnowflakeStreamInfoGraphQLField" = SnowflakeStreamInfoGraphQLField(
        "entityId"
    )
    source_type: "SnowflakeStreamInfoGraphQLField" = SnowflakeStreamInfoGraphQLField(
        "sourceType"
    )
    stale: "SnowflakeStreamInfoGraphQLField" = SnowflakeStreamInfoGraphQLField("stale")
    stale_after: "SnowflakeStreamInfoGraphQLField" = SnowflakeStreamInfoGraphQLField(
        "staleAfter"
    )
    stream_type: "SnowflakeStreamInfoGraphQLField" = SnowflakeStreamInfoGraphQLField(
        "streamType"
    )

    def fields(
        self, *subfields: SnowflakeStreamInfoGraphQLField
    ) -> "SnowflakeStreamInfoFields":
        """Subfields should come from the SnowflakeStreamInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SnowflakeStreamInfoFields":
        self._alias = alias
        return self


class SocialLoginFields(GraphQLField):
    @classmethod
    def google(cls) -> "GoogleSocialLoginFields":
        return GoogleSocialLoginFields("google")

    @classmethod
    def linked_in(cls) -> "LinkedInSocialLoginFields":
        return LinkedInSocialLoginFields("linked_in")

    @classmethod
    def microsoft(cls) -> "MicrosoftSocialLoginFields":
        return MicrosoftSocialLoginFields("microsoft")

    def fields(
        self,
        *subfields: Union[
            SocialLoginGraphQLField,
            "GoogleSocialLoginFields",
            "LinkedInSocialLoginFields",
            "MicrosoftSocialLoginFields",
        ]
    ) -> "SocialLoginFields":
        """Subfields should come from the SocialLoginFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SocialLoginFields":
        self._alias = alias
        return self


class SoftDeletionFields(GraphQLField):
    enabled: "SoftDeletionGraphQLField" = SoftDeletionGraphQLField("enabled")
    threshold_hours: "SoftDeletionGraphQLField" = SoftDeletionGraphQLField(
        "thresholdHours"
    )

    def fields(self, *subfields: SoftDeletionGraphQLField) -> "SoftDeletionFields":
        """Subfields should come from the SoftDeletionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SoftDeletionFields":
        self._alias = alias
        return self


class SourceFieldFields(GraphQLField):
    @classmethod
    def dataset(cls) -> "DatasetLogicalIdFields":
        return DatasetLogicalIdFields("dataset")

    field: "SourceFieldGraphQLField" = SourceFieldGraphQLField("field")
    source_entity_id: "SourceFieldGraphQLField" = SourceFieldGraphQLField(
        "sourceEntityId"
    )

    def fields(
        self, *subfields: Union[SourceFieldGraphQLField, "DatasetLogicalIdFields"]
    ) -> "SourceFieldFields":
        """Subfields should come from the SourceFieldFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SourceFieldFields":
        self._alias = alias
        return self


class SourceInfoFields(GraphQLField):
    created_at: "SourceInfoGraphQLField" = SourceInfoGraphQLField("createdAt")
    created_at_source: "SourceInfoGraphQLField" = SourceInfoGraphQLField(
        "createdAtSource"
    )
    created_by: "SourceInfoGraphQLField" = SourceInfoGraphQLField("createdBy")
    entity_id: "SourceInfoGraphQLField" = SourceInfoGraphQLField("entityId")
    last_updated: "SourceInfoGraphQLField" = SourceInfoGraphQLField("lastUpdated")
    main_url: "SourceInfoGraphQLField" = SourceInfoGraphQLField("mainUrl")
    updated_by: "SourceInfoGraphQLField" = SourceInfoGraphQLField("updatedBy")

    def fields(self, *subfields: SourceInfoGraphQLField) -> "SourceInfoFields":
        """Subfields should come from the SourceInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SourceInfoFields":
        self._alias = alias
        return self


class SparkJobFields(GraphQLField):
    description: "SparkJobGraphQLField" = SparkJobGraphQLField("description")
    source_code_url: "SparkJobGraphQLField" = SparkJobGraphQLField("sourceCodeUrl")
    sql: "SparkJobGraphQLField" = SparkJobGraphQLField("sql")

    def fields(self, *subfields: SparkJobGraphQLField) -> "SparkJobFields":
        """Subfields should come from the SparkJobFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SparkJobFields":
        self._alias = alias
        return self


class SqlSchemaFields(GraphQLField):
    @classmethod
    def foreign_key(cls) -> "ForeignKeyFields":
        return ForeignKeyFields("foreign_key")

    materialization: "SqlSchemaGraphQLField" = SqlSchemaGraphQLField("materialization")
    primary_key: "SqlSchemaGraphQLField" = SqlSchemaGraphQLField("primaryKey")
    snapshot_time: "SqlSchemaGraphQLField" = SqlSchemaGraphQLField("snapshotTime")
    table_schema: "SqlSchemaGraphQLField" = SqlSchemaGraphQLField("tableSchema")

    def fields(
        self, *subfields: Union[SqlSchemaGraphQLField, "ForeignKeyFields"]
    ) -> "SqlSchemaFields":
        """Subfields should come from the SqlSchemaFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SqlSchemaFields":
        self._alias = alias
        return self


class StatusFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    status: "StatusGraphQLField" = StatusGraphQLField("status")

    def fields(
        self, *subfields: Union[StatusGraphQLField, "AuditStampFields"]
    ) -> "StatusFields":
        """Subfields should come from the StatusFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StatusFields":
        self._alias = alias
        return self


class SuggestItemFields(GraphQLField):
    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    entity_id: "SuggestItemGraphQLField" = SuggestItemGraphQLField("entityId")
    entity_type: "SuggestItemGraphQLField" = SuggestItemGraphQLField("entityType")
    index: "SuggestItemGraphQLField" = SuggestItemGraphQLField("index")
    logical_id: "LogicalIdUnion" = LogicalIdUnion("logicalId")
    native_type: "SuggestItemGraphQLField" = SuggestItemGraphQLField("nativeType")
    score: "SuggestItemGraphQLField" = SuggestItemGraphQLField("score")
    search_context: "SuggestItemGraphQLField" = SuggestItemGraphQLField("searchContext")
    text: "SuggestItemGraphQLField" = SuggestItemGraphQLField("text")

    def fields(
        self,
        *subfields: Union[SuggestItemGraphQLField, "BrowsePathFields", "LogicalIdUnion"]
    ) -> "SuggestItemFields":
        """Subfields should come from the SuggestItemFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SuggestItemFields":
        self._alias = alias
        return self


class SuggestResultFields(GraphQLField):
    @classmethod
    def results(cls) -> "SuggestItemFields":
        return SuggestItemFields("results")

    total_count: "SuggestResultGraphQLField" = SuggestResultGraphQLField("totalCount")

    def fields(
        self, *subfields: Union[SuggestResultGraphQLField, "SuggestItemFields"]
    ) -> "SuggestResultFields":
        """Subfields should come from the SuggestResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SuggestResultFields":
        self._alias = alias
        return self


class SystemContactFields(GraphQLField):
    email: "SystemContactGraphQLField" = SystemContactGraphQLField("email")
    system_contact_source: "SystemContactGraphQLField" = SystemContactGraphQLField(
        "systemContactSource"
    )

    def fields(self, *subfields: SystemContactGraphQLField) -> "SystemContactFields":
        """Subfields should come from the SystemContactFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemContactFields":
        self._alias = alias
        return self


class SystemContactsFields(GraphQLField):
    @classmethod
    def contacts(cls) -> "SystemContactFields":
        return SystemContactFields("contacts")

    created_at: "SystemContactsGraphQLField" = SystemContactsGraphQLField("createdAt")
    entity_id: "SystemContactsGraphQLField" = SystemContactsGraphQLField("entityId")

    def fields(
        self, *subfields: Union[SystemContactsGraphQLField, "SystemContactFields"]
    ) -> "SystemContactsFields":
        """Subfields should come from the SystemContactsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemContactsFields":
        self._alias = alias
        return self


class SystemDescriptionFields(GraphQLField):
    created_at: "SystemDescriptionGraphQLField" = SystemDescriptionGraphQLField(
        "createdAt"
    )
    description: "SystemDescriptionGraphQLField" = SystemDescriptionGraphQLField(
        "description"
    )
    entity_id: "SystemDescriptionGraphQLField" = SystemDescriptionGraphQLField(
        "entityId"
    )
    platform: "SystemDescriptionGraphQLField" = SystemDescriptionGraphQLField(
        "platform"
    )

    def fields(
        self, *subfields: SystemDescriptionGraphQLField
    ) -> "SystemDescriptionFields":
        """Subfields should come from the SystemDescriptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemDescriptionFields":
        self._alias = alias
        return self


class SystemTagFields(GraphQLField):
    key: "SystemTagGraphQLField" = SystemTagGraphQLField("key")
    system_tag_source: "SystemTagGraphQLField" = SystemTagGraphQLField(
        "systemTagSource"
    )
    value: "SystemTagGraphQLField" = SystemTagGraphQLField("value")

    def fields(self, *subfields: SystemTagGraphQLField) -> "SystemTagFields":
        """Subfields should come from the SystemTagFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemTagFields":
        self._alias = alias
        return self


class SystemTagCountsFields(GraphQLField):
    description: "SystemTagCountsGraphQLField" = SystemTagCountsGraphQLField(
        "description"
    )

    @classmethod
    def entity_counts(cls) -> "EntityCountFields":
        return EntityCountFields("entity_counts")

    id: "SystemTagCountsGraphQLField" = SystemTagCountsGraphQLField("id")
    key: "SystemTagCountsGraphQLField" = SystemTagCountsGraphQLField("key")
    source: "SystemTagCountsGraphQLField" = SystemTagCountsGraphQLField("source")
    value: "SystemTagCountsGraphQLField" = SystemTagCountsGraphQLField("value")

    def fields(
        self, *subfields: Union[SystemTagCountsGraphQLField, "EntityCountFields"]
    ) -> "SystemTagCountsFields":
        """Subfields should come from the SystemTagCountsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemTagCountsFields":
        self._alias = alias
        return self


class SystemTagCountsConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "SystemTagCountsEdgeFields":
        return SystemTagCountsEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "SystemTagCountsConnectionGraphQLField" = (
        SystemTagCountsConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            SystemTagCountsConnectionGraphQLField,
            "PageInfoFields",
            "SystemTagCountsEdgeFields",
        ]
    ) -> "SystemTagCountsConnectionFields":
        """Subfields should come from the SystemTagCountsConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemTagCountsConnectionFields":
        self._alias = alias
        return self


class SystemTagCountsEdgeFields(GraphQLField):
    cursor: "SystemTagCountsEdgeGraphQLField" = SystemTagCountsEdgeGraphQLField(
        "cursor"
    )

    @classmethod
    def node(cls) -> "SystemTagCountsFields":
        return SystemTagCountsFields("node")

    def fields(
        self,
        *subfields: Union[SystemTagCountsEdgeGraphQLField, "SystemTagCountsFields"]
    ) -> "SystemTagCountsEdgeFields":
        """Subfields should come from the SystemTagCountsEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemTagCountsEdgeFields":
        self._alias = alias
        return self


class SystemTagSourcesFields(GraphQLField):
    sources: "SystemTagSourcesGraphQLField" = SystemTagSourcesGraphQLField("sources")

    def fields(
        self, *subfields: SystemTagSourcesGraphQLField
    ) -> "SystemTagSourcesFields":
        """Subfields should come from the SystemTagSourcesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemTagSourcesFields":
        self._alias = alias
        return self


class SystemTagsFields(GraphQLField):
    created_at: "SystemTagsGraphQLField" = SystemTagsGraphQLField("createdAt")
    entity_id: "SystemTagsGraphQLField" = SystemTagsGraphQLField("entityId")

    @classmethod
    def tags(cls) -> "SystemTagFields":
        return SystemTagFields("tags")

    def fields(
        self, *subfields: Union[SystemTagsGraphQLField, "SystemTagFields"]
    ) -> "SystemTagsFields":
        """Subfields should come from the SystemTagsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemTagsFields":
        self._alias = alias
        return self


class TableColumnsUsageFields(GraphQLField):
    columns: "TableColumnsUsageGraphQLField" = TableColumnsUsageGraphQLField("columns")
    count: "TableColumnsUsageGraphQLField" = TableColumnsUsageGraphQLField("count")

    def fields(
        self, *subfields: TableColumnsUsageGraphQLField
    ) -> "TableColumnsUsageFields":
        """Subfields should come from the TableColumnsUsageFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TableColumnsUsageFields":
        self._alias = alias
        return self


class TableJoinFields(GraphQLField):
    @classmethod
    def scenarios(cls) -> "TableJoinScenarioFields":
        return TableJoinScenarioFields("scenarios")

    total_join_count: "TableJoinGraphQLField" = TableJoinGraphQLField("totalJoinCount")

    def fields(
        self, *subfields: Union[TableJoinGraphQLField, "TableJoinScenarioFields"]
    ) -> "TableJoinFields":
        """Subfields should come from the TableJoinFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TableJoinFields":
        self._alias = alias
        return self


class TableJoinScenarioFields(GraphQLField):
    count: "TableJoinScenarioGraphQLField" = TableJoinScenarioGraphQLField("count")
    datasets: "TableJoinScenarioGraphQLField" = TableJoinScenarioGraphQLField(
        "datasets"
    )

    @classmethod
    def filtering_columns(cls) -> "TableColumnsUsageFields":
        return TableColumnsUsageFields("filtering_columns")

    @classmethod
    def joining_columns(cls) -> "TableColumnsUsageFields":
        return TableColumnsUsageFields("joining_columns")

    def fields(
        self,
        *subfields: Union[TableJoinScenarioGraphQLField, "TableColumnsUsageFields"]
    ) -> "TableJoinScenarioFields":
        """Subfields should come from the TableJoinScenarioFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TableJoinScenarioFields":
        self._alias = alias
        return self


class TableJoinsFields(GraphQLField):
    @classmethod
    def last_7_days(cls) -> "TableJoinFields":
        return TableJoinFields("last_7_days")

    @classmethod
    def last_24_hours(cls) -> "TableJoinFields":
        return TableJoinFields("last_24_hours")

    @classmethod
    def last_30_days(cls) -> "TableJoinFields":
        return TableJoinFields("last_30_days")

    @classmethod
    def last_90_days(cls) -> "TableJoinFields":
        return TableJoinFields("last_90_days")

    @classmethod
    def last_365_days(cls) -> "TableJoinFields":
        return TableJoinFields("last_365_days")

    def fields(
        self, *subfields: Union[TableJoinsGraphQLField, "TableJoinFields"]
    ) -> "TableJoinsFields":
        """Subfields should come from the TableJoinsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TableJoinsFields":
        self._alias = alias
        return self


class TableauDatasourceFields(GraphQLField):
    created_at: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField(
        "createdAt"
    )
    description: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField(
        "description"
    )

    @classmethod
    def downstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineage_for: Optional[TableauDatasourceDownstreamLineageInput] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {
                "type": "TableauDatasourceDownstreamLineageInput",
                "value": lineage_for,
            },
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstream_of_type", arguments=cleared_arguments
        )

    embedded: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField(
        "embedded"
    )
    entity_id: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField(
        "entityId"
    )

    @classmethod
    def fields(cls) -> "TableauFieldFields":
        return TableauFieldFields("fields")

    name: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField("name")
    query: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField("query")
    source_datasets: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField(
        "sourceDatasets"
    )
    source_virtual_views: "TableauDatasourceGraphQLField" = (
        TableauDatasourceGraphQLField("sourceVirtualViews")
    )
    source_dataset_account: "TableauDatasourceGraphQLField" = (
        TableauDatasourceGraphQLField("source_dataset_account")
    )
    source_platform: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField(
        "source_platform"
    )

    @classmethod
    def upstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineage_for: Optional[TableauDatasourceUpstreamLineageInput] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {
                "type": "TableauDatasourceUpstreamLineageInput",
                "value": lineage_for,
            },
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstream_of_type", arguments=cleared_arguments
        )

    url: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField("url")

    def fields(
        self,
        *subfields: Union[
            TableauDatasourceGraphQLField,
            "EntityLineageConnectionFields",
            "TableauFieldFields",
        ]
    ) -> "TableauDatasourceFields":
        """Subfields should come from the TableauDatasourceFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TableauDatasourceFields":
        self._alias = alias
        return self


class TableauDatasourceSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "VirtualViewSearchDocumentFields":
        return VirtualViewSearchDocumentFields("documents")

    error_message: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("errorMessage")
    )
    from_: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("from")
    )
    has_more: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("paginationToken")
    )
    search_context: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("searchContext")
    )
    search_index: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("searchIndex")
    )
    size: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("size")
    )
    total_count: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            TableauDatasourceSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "VirtualViewSearchDocumentFields",
        ]
    ) -> "TableauDatasourceSearchResultFields":
        """Subfields should come from the TableauDatasourceSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TableauDatasourceSearchResultFields":
        self._alias = alias
        return self


class TableauFieldFields(GraphQLField):
    description: "TableauFieldGraphQLField" = TableauFieldGraphQLField("description")
    field: "TableauFieldGraphQLField" = TableauFieldGraphQLField("field")

    def fields(self, *subfields: TableauFieldGraphQLField) -> "TableauFieldFields":
        """Subfields should come from the TableauFieldFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TableauFieldFields":
        self._alias = alias
        return self


class TenantInfoFields(GraphQLField):
    id: "TenantInfoGraphQLField" = TenantInfoGraphQLField("id")
    name: "TenantInfoGraphQLField" = TenantInfoGraphQLField("name")
    status: "TenantInfoGraphQLField" = TenantInfoGraphQLField("status")

    def fields(self, *subfields: TenantInfoGraphQLField) -> "TenantInfoFields":
        """Subfields should come from the TenantInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TenantInfoFields":
        self._alias = alias
        return self


class ThoughtSpotColumnFields(GraphQLField):
    description: "ThoughtSpotColumnGraphQLField" = ThoughtSpotColumnGraphQLField(
        "description"
    )
    field: "ThoughtSpotColumnGraphQLField" = ThoughtSpotColumnGraphQLField("field")
    formula: "ThoughtSpotColumnGraphQLField" = ThoughtSpotColumnGraphQLField("formula")
    name: "ThoughtSpotColumnGraphQLField" = ThoughtSpotColumnGraphQLField("name")
    optional_type: "ThoughtSpotColumnGraphQLField" = ThoughtSpotColumnGraphQLField(
        "optionalType"
    )
    type: "ThoughtSpotColumnGraphQLField" = ThoughtSpotColumnGraphQLField("type")

    def fields(
        self, *subfields: ThoughtSpotColumnGraphQLField
    ) -> "ThoughtSpotColumnFields":
        """Subfields should come from the ThoughtSpotColumnFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThoughtSpotColumnFields":
        self._alias = alias
        return self


class ThoughtSpotDataObjectFields(GraphQLField):
    @classmethod
    def columns(cls) -> "ThoughtSpotColumnFields":
        return ThoughtSpotColumnFields("columns")

    created_at: "ThoughtSpotDataObjectGraphQLField" = ThoughtSpotDataObjectGraphQLField(
        "createdAt"
    )
    description: "ThoughtSpotDataObjectGraphQLField" = (
        ThoughtSpotDataObjectGraphQLField("description")
    )

    @classmethod
    def downstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineage_for: Optional[ThoughtSpotDataObjectDownstreamLineageInput] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {
                "type": "ThoughtSpotDataObjectDownstreamLineageInput",
                "value": lineage_for,
            },
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstream_of_type", arguments=cleared_arguments
        )

    entity_id: "ThoughtSpotDataObjectGraphQLField" = ThoughtSpotDataObjectGraphQLField(
        "entityId"
    )
    name: "ThoughtSpotDataObjectGraphQLField" = ThoughtSpotDataObjectGraphQLField(
        "name"
    )
    source_datasets: "ThoughtSpotDataObjectGraphQLField" = (
        ThoughtSpotDataObjectGraphQLField("sourceDatasets")
    )
    source_virtual_views: "ThoughtSpotDataObjectGraphQLField" = (
        ThoughtSpotDataObjectGraphQLField("sourceVirtualViews")
    )
    type: "ThoughtSpotDataObjectGraphQLField" = ThoughtSpotDataObjectGraphQLField(
        "type"
    )

    @classmethod
    def upstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineage_for: Optional[ThoughtSpotDataObjectUpstreamLineageInput] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {
                "type": "ThoughtSpotDataObjectUpstreamLineageInput",
                "value": lineage_for,
            },
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstream_of_type", arguments=cleared_arguments
        )

    url: "ThoughtSpotDataObjectGraphQLField" = ThoughtSpotDataObjectGraphQLField("url")

    def fields(
        self,
        *subfields: Union[
            ThoughtSpotDataObjectGraphQLField,
            "EntityLineageConnectionFields",
            "ThoughtSpotColumnFields",
        ]
    ) -> "ThoughtSpotDataObjectFields":
        """Subfields should come from the ThoughtSpotDataObjectFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThoughtSpotDataObjectFields":
        self._alias = alias
        return self


class ThoughtSpotDataObjectSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "VirtualViewSearchDocumentFields":
        return VirtualViewSearchDocumentFields("documents")

    error_message: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("errorMessage")
    )
    from_: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("from")
    )
    has_more: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("paginationToken")
    )
    search_context: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("searchContext")
    )
    search_index: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("searchIndex")
    )
    size: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("size")
    )
    total_count: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            ThoughtSpotDataObjectSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "VirtualViewSearchDocumentFields",
        ]
    ) -> "ThoughtSpotDataObjectSearchResultFields":
        """Subfields should come from the ThoughtSpotDataObjectSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThoughtSpotDataObjectSearchResultFields":
        self._alias = alias
        return self


class ThoughtSpotInfoFields(GraphQLField):
    embed_url: "ThoughtSpotInfoGraphQLField" = ThoughtSpotInfoGraphQLField("embedUrl")
    type: "ThoughtSpotInfoGraphQLField" = ThoughtSpotInfoGraphQLField("type")

    def fields(
        self, *subfields: ThoughtSpotInfoGraphQLField
    ) -> "ThoughtSpotInfoFields":
        """Subfields should come from the ThoughtSpotInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThoughtSpotInfoFields":
        self._alias = alias
        return self


class UnityCatalogFields(GraphQLField):
    created_at: "UnityCatalogGraphQLField" = UnityCatalogGraphQLField("createdAt")
    dataset_type: "UnityCatalogGraphQLField" = UnityCatalogGraphQLField("datasetType")
    entity_id: "UnityCatalogGraphQLField" = UnityCatalogGraphQLField("entityId")

    @classmethod
    def table_info(cls) -> "UnityCatalogTableInfoFields":
        return UnityCatalogTableInfoFields("table_info")

    volume_entity_id: "UnityCatalogGraphQLField" = UnityCatalogGraphQLField(
        "volumeEntityId"
    )

    @classmethod
    def volume_info(cls) -> "UnityCatalogVolumeInfoFields":
        return UnityCatalogVolumeInfoFields("volume_info")

    def fields(
        self,
        *subfields: Union[
            UnityCatalogGraphQLField,
            "UnityCatalogTableInfoFields",
            "UnityCatalogVolumeInfoFields",
        ]
    ) -> "UnityCatalogFields":
        """Subfields should come from the UnityCatalogFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UnityCatalogFields":
        self._alias = alias
        return self


class UnityCatalogTableInfoFields(GraphQLField):
    data_source_format: "UnityCatalogTableInfoGraphQLField" = (
        UnityCatalogTableInfoGraphQLField("dataSourceFormat")
    )
    owner: "UnityCatalogTableInfoGraphQLField" = UnityCatalogTableInfoGraphQLField(
        "owner"
    )

    @classmethod
    def properties(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("properties")

    storage_location: "UnityCatalogTableInfoGraphQLField" = (
        UnityCatalogTableInfoGraphQLField("storageLocation")
    )
    type: "UnityCatalogTableInfoGraphQLField" = UnityCatalogTableInfoGraphQLField(
        "type"
    )

    def fields(
        self, *subfields: Union[UnityCatalogTableInfoGraphQLField, "KeyValuePairFields"]
    ) -> "UnityCatalogTableInfoFields":
        """Subfields should come from the UnityCatalogTableInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UnityCatalogTableInfoFields":
        self._alias = alias
        return self


class UnityCatalogVolumeInfoFields(GraphQLField):
    storage_location: "UnityCatalogVolumeInfoGraphQLField" = (
        UnityCatalogVolumeInfoGraphQLField("storageLocation")
    )
    type: "UnityCatalogVolumeInfoGraphQLField" = UnityCatalogVolumeInfoGraphQLField(
        "type"
    )

    @classmethod
    def volume_files(cls) -> "VolumeFileFields":
        return VolumeFileFields("volume_files")

    def fields(
        self, *subfields: Union[UnityCatalogVolumeInfoGraphQLField, "VolumeFileFields"]
    ) -> "UnityCatalogVolumeInfoFields":
        """Subfields should come from the UnityCatalogVolumeInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UnityCatalogVolumeInfoFields":
        self._alias = alias
        return self


class UniversalSearchResultFields(GraphQLField):
    response: "UniversalSearchResultGraphQLField" = UniversalSearchResultGraphQLField(
        "response"
    )
    search_failed: "UniversalSearchResultGraphQLField" = (
        UniversalSearchResultGraphQLField("searchFailed")
    )

    @classmethod
    def source_assets(cls) -> "EntityConnectionFields":
        return EntityConnectionFields("source_assets")

    def fields(
        self,
        *subfields: Union[UniversalSearchResultGraphQLField, "EntityConnectionFields"]
    ) -> "UniversalSearchResultFields":
        """Subfields should come from the UniversalSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UniversalSearchResultFields":
        self._alias = alias
        return self


class UpdateCrawlerScheduleInterface(GraphQLField):
    description: "UpdateCrawlerScheduleGraphQLField" = (
        UpdateCrawlerScheduleGraphQLField("description")
    )
    enabled: "UpdateCrawlerScheduleGraphQLField" = UpdateCrawlerScheduleGraphQLField(
        "enabled"
    )
    is_daily: "UpdateCrawlerScheduleGraphQLField" = UpdateCrawlerScheduleGraphQLField(
        "isDaily"
    )
    schedule: "UpdateCrawlerScheduleGraphQLField" = UpdateCrawlerScheduleGraphQLField(
        "schedule"
    )

    def fields(
        self, *subfields: UpdateCrawlerScheduleGraphQLField
    ) -> "UpdateCrawlerScheduleInterface":
        """Subfields should come from the UpdateCrawlerScheduleInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UpdateCrawlerScheduleInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "UpdateCrawlerScheduleInterface":
        self._inline_fragments[type_name] = subfields
        return self


class UsageKnowledgeCardFields(GraphQLField):
    detail: "UsageKnowledgeCardGraphQLField" = UsageKnowledgeCardGraphQLField("detail")
    example: "UsageKnowledgeCardGraphQLField" = UsageKnowledgeCardGraphQLField(
        "example"
    )
    title: "UsageKnowledgeCardGraphQLField" = UsageKnowledgeCardGraphQLField("title")

    @classmethod
    def tokenized_content(cls) -> "HowToUseTokenizedContentFields":
        return HowToUseTokenizedContentFields("tokenized_content")

    def fields(
        self,
        *subfields: Union[
            UsageKnowledgeCardGraphQLField, "HowToUseTokenizedContentFields"
        ]
    ) -> "UsageKnowledgeCardFields":
        """Subfields should come from the UsageKnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UsageKnowledgeCardFields":
        self._alias = alias
        return self


class UserActivityFields(GraphQLField):
    activity_type: "UserActivityGraphQLField" = UserActivityGraphQLField("activityType")

    @classmethod
    def actor_info(cls) -> "UserActivityActorInfoFields":
        return UserActivityActorInfoFields("actor_info")

    duration_in_seconds: "UserActivityGraphQLField" = UserActivityGraphQLField(
        "durationInSeconds"
    )
    measure: "UserActivityGraphQLField" = UserActivityGraphQLField("measure")
    source: "UserActivityGraphQLField" = UserActivityGraphQLField("source")
    timestamp: "UserActivityGraphQLField" = UserActivityGraphQLField("timestamp")

    def fields(
        self, *subfields: Union[UserActivityGraphQLField, "UserActivityActorInfoFields"]
    ) -> "UserActivityFields":
        """Subfields should come from the UserActivityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserActivityFields":
        self._alias = alias
        return self


class UserActivityActorInfoFields(GraphQLField):
    email: "UserActivityActorInfoGraphQLField" = UserActivityActorInfoGraphQLField(
        "email"
    )

    def fields(
        self, *subfields: UserActivityActorInfoGraphQLField
    ) -> "UserActivityActorInfoFields":
        """Subfields should come from the UserActivityActorInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserActivityActorInfoFields":
        self._alias = alias
        return self


class UserDefinedResourceFields(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def assets_linked_to_resource(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssociatedAssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "AssociatedAssetConnectionFilterInput",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields(
            "assets_linked_to_resource", arguments=cleared_arguments
        )

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    @classmethod
    def child_resources(
        cls,
        filters: ResourceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "ResourceInfoConnectionFilterInput!", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "child_resources", arguments=cleared_arguments
        )

    @classmethod
    def common_column_attributes(cls) -> "CommonColumnAttributesFields":
        return CommonColumnAttributesFields("common_column_attributes")

    @classmethod
    def common_column_description_exclusion(
        cls,
    ) -> "CommonColumnDescriptionExclusionFields":
        return CommonColumnDescriptionExclusionFields(
            "common_column_description_exclusion"
        )

    count_matching_columns: "UserDefinedResourceGraphQLField" = (
        UserDefinedResourceGraphQLField("countMatchingColumns")
    )
    created_at: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField(
        "createdAt"
    )
    deleted_at: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField(
        "deletedAt"
    )
    display_name: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField(
        "displayName"
    )
    entity_type: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField(
        "entityType"
    )

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField("id")
    is_deleted: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField(
        "isDeleted"
    )
    is_viewer_author: "UserDefinedResourceGraphQLField" = (
        UserDefinedResourceGraphQLField("isViewerAuthor")
    )

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    last_ingested_at: "UserDefinedResourceGraphQLField" = (
        UserDefinedResourceGraphQLField("lastIngestedAt")
    )
    last_modified_at: "UserDefinedResourceGraphQLField" = (
        UserDefinedResourceGraphQLField("lastModifiedAt")
    )

    @classmethod
    def logical_id(cls) -> "UserDefinedResourceLogicalIdFields":
        return UserDefinedResourceLogicalIdFields("logical_id")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def parent_resource(cls) -> "UserDefinedResourceFields":
        return UserDefinedResourceFields("parent_resource")

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    @classmethod
    def user_defined_resource_info(cls) -> "UserDefinedResourceInfoFields":
        return UserDefinedResourceInfoFields("user_defined_resource_info")

    viewer_can_assign: "UserDefinedResourceGraphQLField" = (
        UserDefinedResourceGraphQLField("viewerCanAssign")
    )
    viewer_can_delete: "UserDefinedResourceGraphQLField" = (
        UserDefinedResourceGraphQLField("viewerCanDelete")
    )
    viewer_can_edit: "UserDefinedResourceGraphQLField" = (
        UserDefinedResourceGraphQLField("viewerCanEdit")
    )

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "CommonColumnAttributesFields",
            "CommonColumnDescriptionExclusionFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "UserDefinedResourceConnectionFields",
            "UserDefinedResourceFields",
            "UserDefinedResourceInfoFields",
            "UserDefinedResourceLogicalIdFields",
        ]
    ) -> "UserDefinedResourceFields":
        """Subfields should come from the UserDefinedResourceFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceFields":
        self._alias = alias
        return self


class UserDefinedResourceBaseInterface(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "UserDefinedResourceBaseGraphQLField" = (
        UserDefinedResourceBaseGraphQLField("createdAt")
    )
    deleted_at: "UserDefinedResourceBaseGraphQLField" = (
        UserDefinedResourceBaseGraphQLField("deletedAt")
    )
    display_name: "UserDefinedResourceBaseGraphQLField" = (
        UserDefinedResourceBaseGraphQLField("displayName")
    )
    entity_type: "UserDefinedResourceBaseGraphQLField" = (
        UserDefinedResourceBaseGraphQLField("entityType")
    )

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "UserDefinedResourceBaseGraphQLField" = UserDefinedResourceBaseGraphQLField(
        "id"
    )
    is_deleted: "UserDefinedResourceBaseGraphQLField" = (
        UserDefinedResourceBaseGraphQLField("isDeleted")
    )

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    last_ingested_at: "UserDefinedResourceBaseGraphQLField" = (
        UserDefinedResourceBaseGraphQLField("lastIngestedAt")
    )
    last_modified_at: "UserDefinedResourceBaseGraphQLField" = (
        UserDefinedResourceBaseGraphQLField("lastModifiedAt")
    )

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceBaseGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "UserDefinedResourceBaseInterface":
        """Subfields should come from the UserDefinedResourceBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "UserDefinedResourceBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class UserDefinedResourceConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "UserDefinedResourceEdgeFields":
        return UserDefinedResourceEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "UserDefinedResourceConnectionGraphQLField" = (
        UserDefinedResourceConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceConnectionGraphQLField,
            "PageInfoFields",
            "UserDefinedResourceEdgeFields",
        ]
    ) -> "UserDefinedResourceConnectionFields":
        """Subfields should come from the UserDefinedResourceConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceConnectionFields":
        self._alias = alias
        return self


class UserDefinedResourceDeletePayloadFields(GraphQLField):
    deleted_ids: "UserDefinedResourceDeletePayloadGraphQLField" = (
        UserDefinedResourceDeletePayloadGraphQLField("deletedIds")
    )
    failed_ids: "UserDefinedResourceDeletePayloadGraphQLField" = (
        UserDefinedResourceDeletePayloadGraphQLField("failedIds")
    )

    def fields(
        self, *subfields: UserDefinedResourceDeletePayloadGraphQLField
    ) -> "UserDefinedResourceDeletePayloadFields":
        """Subfields should come from the UserDefinedResourceDeletePayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceDeletePayloadFields":
        self._alias = alias
        return self


class UserDefinedResourceDescriptionFields(GraphQLField):
    text: "UserDefinedResourceDescriptionGraphQLField" = (
        UserDefinedResourceDescriptionGraphQLField("text")
    )
    tokenized_text: "UserDefinedResourceDescriptionGraphQLField" = (
        UserDefinedResourceDescriptionGraphQLField("tokenizedText")
    )

    def fields(
        self, *subfields: UserDefinedResourceDescriptionGraphQLField
    ) -> "UserDefinedResourceDescriptionFields":
        """Subfields should come from the UserDefinedResourceDescriptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceDescriptionFields":
        self._alias = alias
        return self


class UserDefinedResourceEdgeFields(GraphQLField):
    cursor: "UserDefinedResourceEdgeGraphQLField" = UserDefinedResourceEdgeGraphQLField(
        "cursor"
    )

    @classmethod
    def node(cls) -> "UserDefinedResourceFields":
        return UserDefinedResourceFields("node")

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceEdgeGraphQLField, "UserDefinedResourceFields"
        ]
    ) -> "UserDefinedResourceEdgeFields":
        """Subfields should come from the UserDefinedResourceEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceEdgeFields":
        self._alias = alias
        return self


class UserDefinedResourceHighlightFields(GraphQLField):
    contact_display_names: "UserDefinedResourceHighlightGraphQLField" = (
        UserDefinedResourceHighlightGraphQLField("contactDisplayNames")
    )
    description: "UserDefinedResourceHighlightGraphQLField" = (
        UserDefinedResourceHighlightGraphQLField("description")
    )
    governed_tags: "UserDefinedResourceHighlightGraphQLField" = (
        UserDefinedResourceHighlightGraphQLField("governedTags")
    )
    hashtags: "UserDefinedResourceHighlightGraphQLField" = (
        UserDefinedResourceHighlightGraphQLField("hashtags")
    )
    name: "UserDefinedResourceHighlightGraphQLField" = (
        UserDefinedResourceHighlightGraphQLField("name")
    )

    def fields(
        self, *subfields: UserDefinedResourceHighlightGraphQLField
    ) -> "UserDefinedResourceHighlightFields":
        """Subfields should come from the UserDefinedResourceHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceHighlightFields":
        self._alias = alias
        return self


class UserDefinedResourceInfoFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    created_at: "UserDefinedResourceInfoGraphQLField" = (
        UserDefinedResourceInfoGraphQLField("createdAt")
    )

    @classmethod
    def custom_tag_attributes(cls) -> "CustomTagAttributesFields":
        return CustomTagAttributesFields("custom_tag_attributes")

    @classmethod
    def description(cls) -> "UserDefinedResourceDescriptionFields":
        return UserDefinedResourceDescriptionFields("description")

    entity_id: "UserDefinedResourceInfoGraphQLField" = (
        UserDefinedResourceInfoGraphQLField("entityId")
    )

    @classmethod
    def last_modified(cls) -> "AuditStampFields":
        return AuditStampFields("last_modified")

    name: "UserDefinedResourceInfoGraphQLField" = UserDefinedResourceInfoGraphQLField(
        "name"
    )
    type: "UserDefinedResourceInfoGraphQLField" = UserDefinedResourceInfoGraphQLField(
        "type"
    )

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceInfoGraphQLField,
            "AuditStampFields",
            "CustomTagAttributesFields",
            "UserDefinedResourceDescriptionFields",
        ]
    ) -> "UserDefinedResourceInfoFields":
        """Subfields should come from the UserDefinedResourceInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceInfoFields":
        self._alias = alias
        return self


class UserDefinedResourceInfoBaseInterface(GraphQLField):
    created_at: "UserDefinedResourceInfoBaseGraphQLField" = (
        UserDefinedResourceInfoBaseGraphQLField("createdAt")
    )

    @classmethod
    def custom_tag_attributes(cls) -> "CustomTagAttributesFields":
        return CustomTagAttributesFields("custom_tag_attributes")

    @classmethod
    def description(cls) -> "UserDefinedResourceDescriptionFields":
        return UserDefinedResourceDescriptionFields("description")

    entity_id: "UserDefinedResourceInfoBaseGraphQLField" = (
        UserDefinedResourceInfoBaseGraphQLField("entityId")
    )
    name: "UserDefinedResourceInfoBaseGraphQLField" = (
        UserDefinedResourceInfoBaseGraphQLField("name")
    )
    type: "UserDefinedResourceInfoBaseGraphQLField" = (
        UserDefinedResourceInfoBaseGraphQLField("type")
    )

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceInfoBaseGraphQLField,
            "CustomTagAttributesFields",
            "UserDefinedResourceDescriptionFields",
        ]
    ) -> "UserDefinedResourceInfoBaseInterface":
        """Subfields should come from the UserDefinedResourceInfoBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceInfoBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "UserDefinedResourceInfoBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class UserDefinedResourceLogicalIdFields(GraphQLField):
    id: "UserDefinedResourceLogicalIdGraphQLField" = (
        UserDefinedResourceLogicalIdGraphQLField("id")
    )

    def fields(
        self, *subfields: UserDefinedResourceLogicalIdGraphQLField
    ) -> "UserDefinedResourceLogicalIdFields":
        """Subfields should come from the UserDefinedResourceLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceLogicalIdFields":
        self._alias = alias
        return self


class UserDefinedResourceSearchDocumentFields(GraphQLField):
    author: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("author")
    )
    author_display_name: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("authorDisplayName")
    )
    browse_path_hierarchy: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browse_path_segments: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    contact_display_names: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("contactDisplayNames")
    )
    description: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("description")
    )
    document_id: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("documentId")
    )
    embedded_string_1: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("embeddedString_1")
    )
    embedded_string_2: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("embeddedString_2")
    )
    entity_id: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("entityId")
    )
    governed_tags: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("governedTags")
    )
    hashtags: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("hashtags")
    )

    @classmethod
    def highlight(cls) -> "UserDefinedResourceHighlightFields":
        return UserDefinedResourceHighlightFields("highlight")

    is_deleted: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("isDeleted")
    )
    last_refreshed: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("lastRefreshed")
    )
    name: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("name")
    )
    pagination_token: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("paginationToken")
    )

    @classmethod
    def score_details(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("score_details")

    type: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("type")
    )
    view_count: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("viewCount")
    )

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceSearchDocumentGraphQLField,
            "BrowsePathFields",
            "SearchScoreDetailsFields",
            "UserDefinedResourceHighlightFields",
        ]
    ) -> "UserDefinedResourceSearchDocumentFields":
        """Subfields should come from the UserDefinedResourceSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceSearchDocumentFields":
        self._alias = alias
        return self


class UserDefinedResourceSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "UserDefinedResourceSearchDocumentFields":
        return UserDefinedResourceSearchDocumentFields("documents")

    error_message: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("errorMessage")
    )
    from_: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("from")
    )
    has_more: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    pagination_token: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("paginationToken")
    )
    search_context: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("searchContext")
    )
    search_index: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("searchIndex")
    )
    size: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("size")
    )
    total_count: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceSearchResultGraphQLField,
            "AggregationMetadataFields",
            "UserDefinedResourceSearchDocumentFields",
        ]
    ) -> "UserDefinedResourceSearchResultFields":
        """Subfields should come from the UserDefinedResourceSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceSearchResultFields":
        self._alias = alias
        return self


class UserQueryCountFields(GraphQLField):
    count: "UserQueryCountGraphQLField" = UserQueryCountGraphQLField("count")
    user: "UserQueryCountGraphQLField" = UserQueryCountGraphQLField("user")

    def fields(self, *subfields: UserQueryCountGraphQLField) -> "UserQueryCountFields":
        """Subfields should come from the UserQueryCountFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserQueryCountFields":
        self._alias = alias
        return self


class UserQueryCountsFields(GraphQLField):
    @classmethod
    def last_7_days(cls) -> "UserQueryCountFields":
        return UserQueryCountFields("last_7_days")

    last_7_days_queried_by_count: "UserQueryCountsGraphQLField" = (
        UserQueryCountsGraphQLField("last7DaysQueriedByCount")
    )

    @classmethod
    def last_24_hours(cls) -> "UserQueryCountFields":
        return UserQueryCountFields("last_24_hours")

    last_24_hours_queried_by_count: "UserQueryCountsGraphQLField" = (
        UserQueryCountsGraphQLField("last24HoursQueriedByCount")
    )

    @classmethod
    def last_30_days(cls) -> "UserQueryCountFields":
        return UserQueryCountFields("last_30_days")

    last_30_days_queried_by_count: "UserQueryCountsGraphQLField" = (
        UserQueryCountsGraphQLField("last30DaysQueriedByCount")
    )

    @classmethod
    def last_90_days(cls) -> "UserQueryCountFields":
        return UserQueryCountFields("last_90_days")

    last_90_days_queried_by_count: "UserQueryCountsGraphQLField" = (
        UserQueryCountsGraphQLField("last90DaysQueriedByCount")
    )

    @classmethod
    def last_365_days(cls) -> "UserQueryCountFields":
        return UserQueryCountFields("last_365_days")

    last_365_days_queried_by_count: "UserQueryCountsGraphQLField" = (
        UserQueryCountsGraphQLField("last365DaysQueriedByCount")
    )

    def fields(
        self, *subfields: Union[UserQueryCountsGraphQLField, "UserQueryCountFields"]
    ) -> "UserQueryCountsFields":
        """Subfields should come from the UserQueryCountsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserQueryCountsFields":
        self._alias = alias
        return self


class UserSpecifiedOrderingFields(GraphQLField):
    @classmethod
    def ordered_entries(cls) -> "OrderedEntryFields":
        return OrderedEntryFields("ordered_entries")

    type: "UserSpecifiedOrderingGraphQLField" = UserSpecifiedOrderingGraphQLField(
        "type"
    )

    def fields(
        self, *subfields: Union[UserSpecifiedOrderingGraphQLField, "OrderedEntryFields"]
    ) -> "UserSpecifiedOrderingFields":
        """Subfields should come from the UserSpecifiedOrderingFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserSpecifiedOrderingFields":
        self._alias = alias
        return self


class VersionHistoryFields(GraphQLField):
    @classmethod
    def after(cls) -> "EntityInterface":
        return EntityInterface("after")

    @classmethod
    def before(cls) -> "EntityInterface":
        return EntityInterface("before")

    date: "VersionHistoryGraphQLField" = VersionHistoryGraphQLField("date")

    @classmethod
    def entity(cls) -> "EntityInterface":
        return EntityInterface("entity")

    updated: "VersionHistoryGraphQLField" = VersionHistoryGraphQLField("updated")
    version_id: "VersionHistoryGraphQLField" = VersionHistoryGraphQLField("versionId")

    def fields(
        self, *subfields: Union[VersionHistoryGraphQLField, "EntityInterface"]
    ) -> "VersionHistoryFields":
        """Subfields should come from the VersionHistoryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VersionHistoryFields":
        self._alias = alias
        return self


class VersionHistoryConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "VersionHistoryEdgeFields":
        return VersionHistoryEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "VersionHistoryConnectionGraphQLField" = (
        VersionHistoryConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            VersionHistoryConnectionGraphQLField,
            "PageInfoFields",
            "VersionHistoryEdgeFields",
        ]
    ) -> "VersionHistoryConnectionFields":
        """Subfields should come from the VersionHistoryConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VersionHistoryConnectionFields":
        self._alias = alias
        return self


class VersionHistoryEdgeFields(GraphQLField):
    cursor: "VersionHistoryEdgeGraphQLField" = VersionHistoryEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "VersionHistoryFields":
        return VersionHistoryFields("node")

    def fields(
        self, *subfields: Union[VersionHistoryEdgeGraphQLField, "VersionHistoryFields"]
    ) -> "VersionHistoryEdgeFields":
        """Subfields should come from the VersionHistoryEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VersionHistoryEdgeFields":
        self._alias = alias
        return self


class ViewActivityConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "ViewActivityEdgeFields":
        return ViewActivityEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "ViewActivityConnectionGraphQLField" = (
        ViewActivityConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            ViewActivityConnectionGraphQLField,
            "PageInfoFields",
            "ViewActivityEdgeFields",
        ]
    ) -> "ViewActivityConnectionFields":
        """Subfields should come from the ViewActivityConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ViewActivityConnectionFields":
        self._alias = alias
        return self


class ViewActivityEdgeFields(GraphQLField):
    cursor: "ViewActivityEdgeGraphQLField" = ViewActivityEdgeGraphQLField("cursor")
    last_viewed_at: "ViewActivityEdgeGraphQLField" = ViewActivityEdgeGraphQLField(
        "lastViewedAt"
    )

    @classmethod
    def node(cls) -> "EntityInterface":
        return EntityInterface("node")

    view_context: "ViewActivityEdgeGraphQLField" = ViewActivityEdgeGraphQLField(
        "viewContext"
    )

    def fields(
        self, *subfields: Union[ViewActivityEdgeGraphQLField, "EntityInterface"]
    ) -> "ViewActivityEdgeFields":
        """Subfields should come from the ViewActivityEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ViewActivityEdgeFields":
        self._alias = alias
        return self


class ViewedByConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "ViewedByEdgeFields":
        return ViewedByEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "ViewedByConnectionGraphQLField" = ViewedByConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            ViewedByConnectionGraphQLField, "PageInfoFields", "ViewedByEdgeFields"
        ]
    ) -> "ViewedByConnectionFields":
        """Subfields should come from the ViewedByConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ViewedByConnectionFields":
        self._alias = alias
        return self


class ViewedByEdgeFields(GraphQLField):
    cursor: "ViewedByEdgeGraphQLField" = ViewedByEdgeGraphQLField("cursor")
    last_viewed_at: "ViewedByEdgeGraphQLField" = ViewedByEdgeGraphQLField(
        "lastViewedAt"
    )

    @classmethod
    def node(cls) -> "PersonFields":
        return PersonFields("node")

    def fields(
        self, *subfields: Union[ViewedByEdgeGraphQLField, "PersonFields"]
    ) -> "ViewedByEdgeFields":
        """Subfields should come from the ViewedByEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ViewedByEdgeFields":
        self._alias = alias
        return self


class ViewerPermissionsFields(GraphQLField):
    @classmethod
    def can_assign_namespace(
        cls, type: NamespaceType
    ) -> "ViewerPermissionsGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "NamespaceType!", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewerPermissionsGraphQLField(
            "can_assign_namespace", arguments=cleared_arguments
        )

    @classmethod
    def can_assign_user_defined_resource(
        cls, type: UserDefinedResourceType
    ) -> "ViewerPermissionsGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "UserDefinedResourceType!", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewerPermissionsGraphQLField(
            "can_assign_user_defined_resource", arguments=cleared_arguments
        )

    @classmethod
    def can_create_knowledge_card(
        cls, type: KnowledgeCardType
    ) -> "ViewerPermissionsGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "KnowledgeCardType!", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewerPermissionsGraphQLField(
            "can_create_knowledge_card", arguments=cleared_arguments
        )

    @classmethod
    def can_create_namespace(
        cls, type: NamespaceType
    ) -> "ViewerPermissionsGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "NamespaceType!", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewerPermissionsGraphQLField(
            "can_create_namespace", arguments=cleared_arguments
        )

    @classmethod
    def can_create_user_defined_resource(
        cls, type: UserDefinedResourceType
    ) -> "ViewerPermissionsGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "UserDefinedResourceType!", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewerPermissionsGraphQLField(
            "can_create_user_defined_resource", arguments=cleared_arguments
        )

    can_curate_query: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canCurateQuery"
    )
    can_edit_api_keys: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canEditApiKeys"
    )
    can_edit_crawlers: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canEditCrawlers"
    )
    can_edit_groups: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canEditGroups"
    )
    can_edit_users: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canEditUsers"
    )
    can_list_users: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canListUsers"
    )
    can_manage_custom_data_grouping_order: "ViewerPermissionsGraphQLField" = (
        ViewerPermissionsGraphQLField("canManageCustomDataGroupingOrder")
    )
    can_run_query: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canRunQuery"
    )
    can_search_users: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canSearchUsers"
    )
    can_see_api_keys: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canSeeApiKeys"
    )
    can_see_crawlers: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canSeeCrawlers"
    )

    def fields(
        self, *subfields: ViewerPermissionsGraphQLField
    ) -> "ViewerPermissionsFields":
        """Subfields should come from the ViewerPermissionsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ViewerPermissionsFields":
        self._alias = alias
        return self


class VirtualViewFields(GraphQLField):
    @classmethod
    def anchor_entity_filters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchor_entity_filters")

    @classmethod
    def asset_contacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("asset_contacts")

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    created_at: "VirtualViewGraphQLField" = VirtualViewGraphQLField("createdAt")

    @classmethod
    def dbt_model(cls) -> "DbtModelFields":
        return DbtModelFields("dbt_model")

    deleted_at: "VirtualViewGraphQLField" = VirtualViewGraphQLField("deletedAt")

    @classmethod
    def descriptions(cls) -> "DerivedAssetDescriptionsFields":
        return DerivedAssetDescriptionsFields("descriptions")

    display_name: "VirtualViewGraphQLField" = VirtualViewGraphQLField("displayName")

    @classmethod
    def downstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineage_for: Optional[LineageFilterInput] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineage_for},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstream_of_type", arguments=cleared_arguments
        )

    entity_type: "VirtualViewGraphQLField" = VirtualViewGraphQLField("entityType")

    @classmethod
    def entity_upstream(cls) -> "EntityUpstreamFields":
        return EntityUpstreamFields("entity_upstream")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def force_shown(cls) -> "AuditStampFields":
        return AuditStampFields("force_shown")

    @classmethod
    def governed_tags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governed_tags", arguments=cleared_arguments
        )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "VirtualViewGraphQLField" = VirtualViewGraphQLField("id")

    @classmethod
    def interested_parties(cls) -> "InterestedPartyFields":
        return InterestedPartyFields("interested_parties")

    is_complete: "VirtualViewGraphQLField" = VirtualViewGraphQLField("isComplete")
    is_deleted: "VirtualViewGraphQLField" = VirtualViewGraphQLField("isDeleted")
    is_production: "VirtualViewGraphQLField" = VirtualViewGraphQLField("isProduction")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledge_cards(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledge_cards", arguments=cleared_arguments
        )

    @classmethod
    def labels(cls) -> "AnchorEntityLabelFields":
        return AnchorEntityLabelFields("labels")

    last_ingested_at: "VirtualViewGraphQLField" = VirtualViewGraphQLField(
        "lastIngestedAt"
    )
    last_modified_at: "VirtualViewGraphQLField" = VirtualViewGraphQLField(
        "lastModifiedAt"
    )

    @classmethod
    def logical_id(cls) -> "VirtualViewLogicalIdFields":
        return VirtualViewLogicalIdFields("logical_id")

    @classmethod
    def looker_explore(cls) -> "LookerExploreFields":
        return LookerExploreFields("looker_explore")

    @classmethod
    def looker_view(cls) -> "LookerViewFields":
        return LookerViewFields("looker_view")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def overall_data_quality(cls) -> "OverallDataQualityFields":
        return OverallDataQualityFields("overall_data_quality")

    @classmethod
    def pipeline_info(cls) -> "PipelineInfoFields":
        return PipelineInfoFields("pipeline_info")

    @classmethod
    def power_bi_dataset(cls) -> "PowerBIDatasetFields":
        return PowerBIDatasetFields("power_bi_dataset")

    @classmethod
    def recent_user_activities(
        cls, *, input: Optional[RecentUserActivitiesFilterInput] = None
    ) -> "RecentUserActivitiesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "RecentUserActivitiesFilterInput", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return RecentUserActivitiesFields(
            "recent_user_activities", arguments=cleared_arguments
        )

    @classmethod
    def recently_viewed_by(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "ViewedByConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewedByConnectionFields(
            "recently_viewed_by", arguments=cleared_arguments
        )

    @classmethod
    def structure(cls) -> "AssetStructureFields":
        return AssetStructureFields("structure")

    @classmethod
    def system_contacts(cls) -> "SystemContactsFields":
        return SystemContactsFields("system_contacts")

    @classmethod
    def system_description(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("system_description")

    system_tag_values: "VirtualViewGraphQLField" = VirtualViewGraphQLField(
        "systemTagValues"
    )

    @classmethod
    def system_tags(cls) -> "SystemTagsFields":
        return SystemTagsFields("system_tags")

    @classmethod
    def tableau_datasource(cls) -> "TableauDatasourceFields":
        return TableauDatasourceFields("tableau_datasource")

    @classmethod
    def thought_spot(cls) -> "ThoughtSpotDataObjectFields":
        return ThoughtSpotDataObjectFields("thought_spot")

    @classmethod
    def top_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("top_authors", arguments=cleared_arguments)

    @classmethod
    def top_knowledge_card_authors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(
            "top_knowledge_card_authors", arguments=cleared_arguments
        )

    @classmethod
    def upstream_of_type(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineage_for: Optional[LineageFilterInput] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineage_for},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstream_of_type", arguments=cleared_arguments
        )

    viewer_can_assign_asset_contacts: "VirtualViewGraphQLField" = (
        VirtualViewGraphQLField("viewerCanAssignAssetContacts")
    )
    viewer_has_pinned: "VirtualViewGraphQLField" = VirtualViewGraphQLField(
        "viewerHasPinned"
    )

    def fields(
        self,
        *subfields: Union[
            VirtualViewGraphQLField,
            "AggregationMetadataFields",
            "AnchorEntityLabelFields",
            "AssetContactsFields",
            "AssetFollowersFields",
            "AssetStructureFields",
            "AuditStampFields",
            "BrowsePathFields",
            "DbtModelFields",
            "DerivedAssetDescriptionsFields",
            "EntityLineageConnectionFields",
            "EntityUpstreamFields",
            "HashtagFields",
            "InterestedPartyFields",
            "KnowledgeCardConnectionFields",
            "LookerExploreFields",
            "LookerViewFields",
            "NamespaceConnectionFields",
            "OverallDataQualityFields",
            "PersonConnectionFields",
            "PipelineInfoFields",
            "PowerBIDatasetFields",
            "RecentUserActivitiesFields",
            "SystemContactsFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
            "TableauDatasourceFields",
            "ThoughtSpotDataObjectFields",
            "UserDefinedResourceConnectionFields",
            "ViewedByConnectionFields",
            "VirtualViewLogicalIdFields",
        ]
    ) -> "VirtualViewFields":
        """Subfields should come from the VirtualViewFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewFields":
        self._alias = alias
        return self


class VirtualViewConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "VirtualViewEdgeFields":
        return VirtualViewEdgeFields("edges")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    total_count: "VirtualViewConnectionGraphQLField" = (
        VirtualViewConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            VirtualViewConnectionGraphQLField, "PageInfoFields", "VirtualViewEdgeFields"
        ]
    ) -> "VirtualViewConnectionFields":
        """Subfields should come from the VirtualViewConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewConnectionFields":
        self._alias = alias
        return self


class VirtualViewEdgeFields(GraphQLField):
    cursor: "VirtualViewEdgeGraphQLField" = VirtualViewEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "VirtualViewFields":
        return VirtualViewFields("node")

    def fields(
        self, *subfields: Union[VirtualViewEdgeGraphQLField, "VirtualViewFields"]
    ) -> "VirtualViewEdgeFields":
        """Subfields should come from the VirtualViewEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewEdgeFields":
        self._alias = alias
        return self


class VirtualViewHighlightFields(GraphQLField):
    column_descriptions: "VirtualViewHighlightGraphQLField" = (
        VirtualViewHighlightGraphQLField("columnDescriptions")
    )
    column_names: "VirtualViewHighlightGraphQLField" = VirtualViewHighlightGraphQLField(
        "columnNames"
    )
    contact_display_names: "VirtualViewHighlightGraphQLField" = (
        VirtualViewHighlightGraphQLField("contactDisplayNames")
    )
    description: "VirtualViewHighlightGraphQLField" = VirtualViewHighlightGraphQLField(
        "description"
    )
    governed_tags: "VirtualViewHighlightGraphQLField" = (
        VirtualViewHighlightGraphQLField("governedTags")
    )
    hashtags: "VirtualViewHighlightGraphQLField" = VirtualViewHighlightGraphQLField(
        "hashtags"
    )
    name: "VirtualViewHighlightGraphQLField" = VirtualViewHighlightGraphQLField("name")

    def fields(
        self, *subfields: VirtualViewHighlightGraphQLField
    ) -> "VirtualViewHighlightFields":
        """Subfields should come from the VirtualViewHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewHighlightFields":
        self._alias = alias
        return self


class VirtualViewLogicalIdFields(GraphQLField):
    name: "VirtualViewLogicalIdGraphQLField" = VirtualViewLogicalIdGraphQLField("name")
    type: "VirtualViewLogicalIdGraphQLField" = VirtualViewLogicalIdGraphQLField("type")

    def fields(
        self, *subfields: VirtualViewLogicalIdGraphQLField
    ) -> "VirtualViewLogicalIdFields":
        """Subfields should come from the VirtualViewLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewLogicalIdFields":
        self._alias = alias
        return self


class VirtualViewSearchDocumentFields(GraphQLField):
    browse_path_hierarchy: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browse_path_segments: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browse_paths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browse_paths")

    column_descriptions: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("columnDescriptions")
    )
    column_names: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("columnNames")
    )
    contact_display_names: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("contactDisplayNames")
    )
    dbt_materialization_type: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("dbtMaterializationType")
    )
    description: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("description")
    )
    document_id: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("documentId")
    )
    domain_display_names: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("domainDisplayNames")
    )
    domains: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("domains")
    )
    embedded_string_1: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("embeddedString_1")
    )
    embedded_string_2: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("embeddedString_2")
    )
    entity_id: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("entityId")
    )
    governed_tags: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("governedTags")
    )
    has_column_lineage: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("hasColumnLineage")
    )
    has_table_lineage: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("hasTableLineage")
    )
    hashtags: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("hashtags")
    )

    @classmethod
    def highlight(cls) -> "VirtualViewHighlightFields":
        return VirtualViewHighlightFields("highlight")

    is_complete: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("isComplete")
    )
    is_deleted: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("isDeleted")
    )
    is_production: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("isProduction")
    )
    knowledge_card_count: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("knowledgeCardCount")
    )
    last_refreshed: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("lastRefreshed")
    )
    model: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("model")
    )
    name: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("name")
    )
    overall_data_quality: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("overallDataQuality")
    )
    pagination_token: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("paginationToken")
    )
    project: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("project")
    )

    @classmethod
    def score_details(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("score_details")

    thought_spot_data_object_type: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("thoughtSpotDataObjectType")
    )
    type: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("type")
    )
    view_count: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("viewCount")
    )
    workspace: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("workspace")
    )

    def fields(
        self,
        *subfields: Union[
            VirtualViewSearchDocumentGraphQLField,
            "BrowsePathFields",
            "SearchScoreDetailsFields",
            "VirtualViewHighlightFields",
        ]
    ) -> "VirtualViewSearchDocumentFields":
        """Subfields should come from the VirtualViewSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewSearchDocumentFields":
        self._alias = alias
        return self


class VirtualViewSearchInfoFields(GraphQLField):
    type: "VirtualViewSearchInfoGraphQLField" = VirtualViewSearchInfoGraphQLField(
        "type"
    )

    def fields(
        self, *subfields: VirtualViewSearchInfoGraphQLField
    ) -> "VirtualViewSearchInfoFields":
        """Subfields should come from the VirtualViewSearchInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewSearchInfoFields":
        self._alias = alias
        return self


class VirtualViewSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "VirtualViewSearchDocumentFields":
        return VirtualViewSearchDocumentFields("documents")

    error_message: "VirtualViewSearchResultGraphQLField" = (
        VirtualViewSearchResultGraphQLField("errorMessage")
    )
    from_: "VirtualViewSearchResultGraphQLField" = VirtualViewSearchResultGraphQLField(
        "from"
    )
    has_more: "VirtualViewSearchResultGraphQLField" = (
        VirtualViewSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    pagination_token: "VirtualViewSearchResultGraphQLField" = (
        VirtualViewSearchResultGraphQLField("paginationToken")
    )
    search_context: "VirtualViewSearchResultGraphQLField" = (
        VirtualViewSearchResultGraphQLField("searchContext")
    )
    search_index: "VirtualViewSearchResultGraphQLField" = (
        VirtualViewSearchResultGraphQLField("searchIndex")
    )
    size: "VirtualViewSearchResultGraphQLField" = VirtualViewSearchResultGraphQLField(
        "size"
    )
    total_count: "VirtualViewSearchResultGraphQLField" = (
        VirtualViewSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            VirtualViewSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "VirtualViewSearchDocumentFields",
        ]
    ) -> "VirtualViewSearchResultFields":
        """Subfields should come from the VirtualViewSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewSearchResultFields":
        self._alias = alias
        return self


class VolumeFileFields(GraphQLField):
    entity_id: "VolumeFileGraphQLField" = VolumeFileGraphQLField("entityId")
    modification_time: "VolumeFileGraphQLField" = VolumeFileGraphQLField(
        "modification_time"
    )
    name: "VolumeFileGraphQLField" = VolumeFileGraphQLField("name")
    path: "VolumeFileGraphQLField" = VolumeFileGraphQLField("path")
    size: "VolumeFileGraphQLField" = VolumeFileGraphQLField("size")

    def fields(self, *subfields: VolumeFileGraphQLField) -> "VolumeFileFields":
        """Subfields should come from the VolumeFileFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VolumeFileFields":
        self._alias = alias
        return self


class WebhookFields(GraphQLField):
    id: "WebhookGraphQLField" = WebhookGraphQLField("_id")
    created_at: "WebhookGraphQLField" = WebhookGraphQLField("createdAt")
    description: "WebhookGraphQLField" = WebhookGraphQLField("description")
    trigger: "WebhookGraphQLField" = WebhookGraphQLField("trigger")
    url: "WebhookGraphQLField" = WebhookGraphQLField("url")

    def fields(self, *subfields: WebhookGraphQLField) -> "WebhookFields":
        """Subfields should come from the WebhookFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "WebhookFields":
        self._alias = alias
        return self
