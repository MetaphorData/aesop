# Generated by ariadne-codegen

from typing import Any, Dict, Optional, Union

from . import (
    EntityType,
    KnowledgeCardType,
    NamespaceType,
    SearchContext,
    UserDefinedOrderType,
    UserDefinedResourceType,
)
from .base_operation import GraphQLField
from .custom_typing_fields import (
    AcknowledgeChangeRequestGraphQLField,
    ActivityDependencyGraphQLField,
    ActivityFeedConnectionGraphQLField,
    ActivityFeedEdgeGraphQLField,
    AggregationBucketGraphQLField,
    AggregationMetadataGraphQLField,
    AISearchQueryGraphQLField,
    AnchorEntityLabelGraphQLField,
    ApiKeyBaseGraphQLField,
    ApiKeyDeletionPayloadGraphQLField,
    ApiKeyGraphQLField,
    ApiKeyInputGraphQLField,
    AspectGraphQLField,
    AssetConnectionGraphQLField,
    AssetContactsGraphQLField,
    AssetDescriptionKnowledgeCardGraphQLField,
    AssetDescriptionTokenizedContentGraphQLField,
    AssetDocumentAggregationBucketGraphQLField,
    AssetEdgeGraphQLField,
    AssetFollowersGraphQLField,
    AssetGraphQLField,
    AssetLikesGraphQLField,
    AssetSearchDocumentGraphQLField,
    AssetSearchHighlightGraphQLField,
    AssetSearchResultGraphQLField,
    AssetStructureGraphQLField,
    AthenaQueryResultGraphQLField,
    AthenaResultRowGraphQLField,
    AuditStampGraphQLField,
    AuthorizationGraphQLField,
    AutoGeneratedDocumentGraphQLField,
    AzureAdSSOGraphQLField,
    AzureDataFactoryActivityGraphQLField,
    AzureDataFactoryPipelineGraphQLField,
    BrowsePathGraphQLField,
    BrowsePathSegmentGraphQLField,
    ChangeRequestKnowledgeCardGraphQLField,
    ChangeRequestTokenizedContentGraphQLField,
    ChartGraphQLField,
    ChartQueryGraphQLField,
    ColumnDescriptionKnowledgeCardGraphQLField,
    CommentGraphQLField,
    CommentTokenizedContentGraphQLField,
    CommonColumnAttributesBaseGraphQLField,
    CommonColumnAttributesGraphQLField,
    CrawlerGraphQLField,
    CrawlerMetadataBaseGraphQLField,
    CrawlerRunMetadataConnectionGraphQLField,
    CrawlerRunMetadataEdgeGraphQLField,
    CrawlerRunMetadataGraphQLField,
    CrawlerRunStatusGraphQLField,
    CrawlerScheduleGraphQLField,
    CrawlerTypeResponseGraphQLField,
    CustomAttributesGraphQLField,
    CustomDirectorySearchResultGraphQLField,
    CustomMetadataConfigGraphQLField,
    CustomMetadataGraphQLField,
    CustomMetadataItemGraphQLField,
    CustomSortableNamedAssetCollectionGraphQLField,
    CustomSortableSavedLiveQueryGraphQLField,
    CustomTagAttributesGraphQLField,
    DashboardConnectionGraphQLField,
    DashboardEdgeGraphQLField,
    DashboardGraphQLField,
    DashboardHighlightGraphQLField,
    DashboardInfoGraphQLField,
    DashboardLogicalIdGraphQLField,
    DashboardSearchDocumentGraphQLField,
    DashboardSearchInfoGraphQLField,
    DashboardSearchResultGraphQLField,
    DataDocumentGraphQLField,
    DataDocumentSearchResultGraphQLField,
    DataDocumentTokenizedContentGraphQLField,
    DataGroupSearchResultGraphQLField,
    DataMonitorGraphQLField,
    DataMonitorTargetGraphQLField,
    DataQualityStatusSourceGraphQLField,
    DatasetColumnsGraphQLField,
    DatasetConnectionGraphQLField,
    DatasetDataQualityGraphQLField,
    DatasetDocumentationGraphQLField,
    DatasetEdgeGraphQLField,
    DatasetFieldAssociationsGraphQLField,
    DatasetFieldStatisticsGraphQLField,
    DatasetGraphQLField,
    DatasetHighlightGraphQLField,
    DatasetLastQueryGraphQLField,
    DatasetLogicalIdGraphQLField,
    DatasetPatternGraphQLField,
    DatasetSchemaGraphQLField,
    DatasetSearchDocumentGraphQLField,
    DatasetSearchInfoGraphQLField,
    DatasetSearchResultGraphQLField,
    DatasetStatisticsGraphQLField,
    DatasetStructureGraphQLField,
    DatasetUsageGraphQLField,
    DbtMacroArgumentGraphQLField,
    DbtMacroGraphQLField,
    DbtMaterializationGraphQLField,
    DbtMetadataItemGraphQLField,
    DbtMetricGraphQLField,
    DbtModelGraphQLField,
    DbtModelSearchResultGraphQLField,
    DbtTestGraphQLField,
    DeleteCrawlersResponseGraphQLField,
    DeleteWebhookResponseGraphQLField,
    DeprecationKnowledgeCardGraphQLField,
    DeprecationTokenizedContentGraphQLField,
    DerivedAssetDescriptionsGraphQLField,
    DesignatedContactGraphQLField,
    EntityConnectionGraphQLField,
    EntityCountGraphQLField,
    EntityEdgeGraphQLField,
    EntityGraphQLField,
    EntityLineageConnectionGraphQLField,
    EntityLineageEdgeGraphQLField,
    EntityUpstreamGraphQLField,
    FieldDocumentationGraphQLField,
    FieldMappingGraphQLField,
    FieldPathPermissionGraphQLField,
    FieldQueryCountGraphQLField,
    FieldQueryCountsGraphQLField,
    FieldStatisticsGraphQLField,
    FieldTagAssociationsGraphQLField,
    FiveTranConnectorStatusGraphQLField,
    FivetranPipelineGraphQLField,
    FollowOrUnfollowOutputGraphQLField,
    ForeignKeyGraphQLField,
    GeneratedAssetDescriptionGraphQLField,
    GeneratedFieldDescriptionGraphQLField,
    GoogleSocialLoginGraphQLField,
    GoogleWorkspaceSSOGraphQLField,
    GovernedEntityGraphQLField,
    GroupBaseGraphQLField,
    GroupConnectionGraphQLField,
    GroupDescriptionGraphQLField,
    GroupEdgeGraphQLField,
    GroupGraphQLField,
    GroupHighlightGraphQLField,
    GroupInfoBaseGraphQLField,
    GroupInfoGraphQLField,
    GroupLogicalIdGraphQLField,
    GroupSearchDocumentGraphQLField,
    GroupSearchResultGraphQLField,
    HardDeletionGraphQLField,
    HashtagGraphQLField,
    HierarchyConnectionGraphQLField,
    HierarchyEdgeGraphQLField,
    HierarchyGraphQLField,
    HierarchyInfoGraphQLField,
    HierarchyLogicalIdGraphQLField,
    HowToUseTokenizedContentGraphQLField,
    IncidentKnowledgeCardGraphQLField,
    IncidentTokenizedContentGraphQLField,
    InformaticaMappingGraphQLField,
    IntegrationsGraphQLField,
    InterestedPartyGraphQLField,
    KeyValuePairGraphQLField,
    KnowledgeCardBaseGraphQLField,
    KnowledgeCardConnectionGraphQLField,
    KnowledgeCardDeletePayloadGraphQLField,
    KnowledgeCardDetailGraphQLField,
    KnowledgeCardEdgeGraphQLField,
    KnowledgeCardGraphQLField,
    KnowledgeCardHighlightGraphQLField,
    KnowledgeCardInfoBaseGraphQLField,
    KnowledgeCardInfoGraphQLField,
    KnowledgeCardInfoOutputGraphQLField,
    KnowledgeCardLogicalIdGraphQLField,
    KnowledgeCardSearchDocumentGraphQLField,
    KnowledgeCardSearchResultGraphQLField,
    LDAPGraphQLField,
    LDAPGroupSearchGraphQLField,
    LDAPUserSearchGraphQLField,
    LinkedInSocialLoginGraphQLField,
    LogicalIdUnion,
    LookerExploreFilterGraphQLField,
    LookerExploreGraphQLField,
    LookerExploreJoinGraphQLField,
    LookerExploreSearchResultGraphQLField,
    LookerViewDimensionGraphQLField,
    LookerViewFilterGraphQLField,
    LookerViewGraphQLField,
    LookerViewMeasureGraphQLField,
    LookerViewQueryGraphQLField,
    LookerViewSearchResultGraphQLField,
    MetabaseCollectionGraphQLField,
    MetricBaseGraphQLField,
    MetricConnectionGraphQLField,
    MetricEdgeGraphQLField,
    MetricFilterGraphQLField,
    MetricGraphQLField,
    MetricInfoBaseGraphQLField,
    MetricInfoGraphQLField,
    MetricLogicalIdGraphQLField,
    MetricSearchInfoGraphQLField,
    MetricSearchResultGraphQLField,
    MicrosoftSocialLoginGraphQLField,
    NamespaceAssetsGraphQLField,
    NamespaceBaseGraphQLField,
    NamespaceConnectionGraphQLField,
    NamespaceDeletePayloadGraphQLField,
    NamespaceDescriptionGraphQLField,
    NamespaceEdgeGraphQLField,
    NamespaceGraphQLField,
    NamespaceHighlightGraphQLField,
    NamespaceInfoBaseGraphQLField,
    NamespaceInfoGraphQLField,
    NamespaceLogicalIdGraphQLField,
    NamespaceSearchDocumentGraphQLField,
    NamespaceSearchResultGraphQLField,
    NamespaceSummaryGraphQLField,
    NamespaceTypeDetailBaseGraphQLField,
    NamespaceTypeDetailGraphQLField,
    NodeGraphQLField,
    NonProdGraphQLField,
    OIDCGraphQLField,
    OktaSSOGraphQLField,
    OnboardingEmailGraphQLField,
    OnboardingExperienceGraphQLField,
    OrderedEntryGraphQLField,
    OrganizationGraphQLField,
    OverallDataQualityGraphQLField,
    PageInfoGraphQLField,
    PersonActivityGraphQLField,
    PersonalizationOptionsBaseGraphQLField,
    PersonalizationOptionsGraphQLField,
    PersonalizationTraitGraphQLField,
    PersonConnectionGraphQLField,
    PersonDetailsInterfaceGraphQLField,
    PersonEdgeGraphQLField,
    PersonGraphQLField,
    PersonHighlightGraphQLField,
    PersonLogicalIdGraphQLField,
    PersonOrganizationGraphQLField,
    PersonPinsGraphQLField,
    PersonPinsPinningOutputGraphQLField,
    PersonPropertiesGraphQLField,
    PersonSearchDocumentGraphQLField,
    PersonSearchResultGraphQLField,
    PersonSlackProfileGraphQLField,
    PipelineGraphQLField,
    PipelineHighlightGraphQLField,
    PipelineInfoGraphQLField,
    PipelineLogicalIdGraphQLField,
    PipelineMappingGraphQLField,
    PipelineSearchDocumentGraphQLField,
    PipelineSearchInfoGraphQLField,
    PipelineSearchResultGraphQLField,
    PowerBiAppGraphQLField,
    PowerBIColumnGraphQLField,
    PowerBIDataflowGraphQLField,
    PowerBIDatasetGraphQLField,
    PowerBIDatasetParameterGraphQLField,
    PowerBIDatasetSearchResultGraphQLField,
    PowerBIDatasetTableGraphQLField,
    PowerBiEndorsementGraphQLField,
    PowerBiInfoGraphQLField,
    PowerBIMeasureGraphQLField,
    PowerBIRefreshScheduleGraphQLField,
    PowerBiSensitivityLabelGraphQLField,
    PowerBiSubscriptionGraphQLField,
    PowerBiSubscriptionUserGraphQLField,
    PowerBiUserGraphQLField,
    PowerBiWorkspaceGraphQLField,
    PowerBiWorkspaceUserGraphQLField,
    PurgeDataQualityGraphQLField,
    QueryCountGraphQLField,
    QueryCountPercentileGraphQLField,
    QueryCountsGraphQLField,
    QueryExplainerGraphQLField,
    QueryExplainerTokenizedContentGraphQLField,
    QueryInfoConnectionGraphQLField,
    QueryInfoEdgeGraphQLField,
    QueryInfoGraphQLField,
    QueryKnowledgeCardGraphQLField,
    QueryResultGraphQLField,
    QuickSightDatasetSearchResultGraphQLField,
    RecentUserActivitiesGraphQLField,
    ResultRowGraphQLField,
    RunCrawlerResponseGraphQLField,
    SAMLGraphQLField,
    SampleSearchQuestionGraphQLField,
    SavedLiveQueryGraphQLField,
    SchemaFieldGraphQLField,
    SchemaFieldWithCommonAttributesGraphQLField,
    SearchQueryGraphQLField,
    SearchScoreDetailsGraphQLField,
    SearchStatisticsResultGraphQLField,
    SettingsGraphQLField,
    SetupInfoGraphQLField,
    SimilarAssetsResultItemGraphQLField,
    SnowflakeStreamInfoGraphQLField,
    SocialLoginGraphQLField,
    SoftDeletionGraphQLField,
    SourceFieldGraphQLField,
    SourceInfoGraphQLField,
    SparkJobGraphQLField,
    SQLExplainerResultGraphQLField,
    SqlSchemaGraphQLField,
    SSOGraphQLField,
    StatusGraphQLField,
    SuggestItemGraphQLField,
    SuggestResultGraphQLField,
    SystemContactGraphQLField,
    SystemContactsGraphQLField,
    SystemDescriptionGraphQLField,
    SystemTagCountsConnectionGraphQLField,
    SystemTagCountsEdgeGraphQLField,
    SystemTagCountsGraphQLField,
    SystemTagGraphQLField,
    SystemTagsGraphQLField,
    SystemTagSourcesGraphQLField,
    TableauDatasourceGraphQLField,
    TableauDatasourceSearchResultGraphQLField,
    TableauFieldGraphQLField,
    TableColumnsUsageGraphQLField,
    TableJoinGraphQLField,
    TableJoinScenarioGraphQLField,
    TableJoinsGraphQLField,
    TenantInfoGraphQLField,
    ThoughtSpotColumnGraphQLField,
    ThoughtSpotDataObjectGraphQLField,
    ThoughtSpotDataObjectSearchResultGraphQLField,
    ThoughtSpotInfoGraphQLField,
    ToggleMuteNotificationOutputGraphQLField,
    UnityCatalogGraphQLField,
    UnityCatalogTableInfoGraphQLField,
    UnityCatalogVolumeInfoGraphQLField,
    UniversalSearchResultGraphQLField,
    UpdateCrawlerScheduleGraphQLField,
    UsageKnowledgeCardGraphQLField,
    UserActivityActorInfoGraphQLField,
    UserActivityGraphQLField,
    UserDefinedResourceBaseGraphQLField,
    UserDefinedResourceConnectionGraphQLField,
    UserDefinedResourceDeletePayloadGraphQLField,
    UserDefinedResourceDescriptionGraphQLField,
    UserDefinedResourceEdgeGraphQLField,
    UserDefinedResourceGraphQLField,
    UserDefinedResourceHighlightGraphQLField,
    UserDefinedResourceInfoBaseGraphQLField,
    UserDefinedResourceInfoGraphQLField,
    UserDefinedResourceLogicalIdGraphQLField,
    UserDefinedResourceSearchDocumentGraphQLField,
    UserDefinedResourceSearchResultGraphQLField,
    UserQueryCountGraphQLField,
    UserQueryCountsGraphQLField,
    UserSpecifiedOrderingGraphQLField,
    VersionHistoryConnectionGraphQLField,
    VersionHistoryEdgeGraphQLField,
    VersionHistoryGraphQLField,
    ViewActivityConnectionGraphQLField,
    ViewActivityEdgeGraphQLField,
    ViewedByConnectionGraphQLField,
    ViewedByEdgeGraphQLField,
    ViewerPermissionsGraphQLField,
    VirtualViewConnectionGraphQLField,
    VirtualViewEdgeGraphQLField,
    VirtualViewGraphQLField,
    VirtualViewHighlightGraphQLField,
    VirtualViewLogicalIdGraphQLField,
    VirtualViewSchemaFieldGraphQLField,
    VirtualViewSchemaGraphQLField,
    VirtualViewSearchDocumentGraphQLField,
    VirtualViewSearchInfoGraphQLField,
    VirtualViewSearchResultGraphQLField,
    VolumeFileGraphQLField,
    WebhookGraphQLField,
)
from .input_types import (
    AssetConnectionFilterInput,
    AssetsConnectionFilterInput,
    AssociatedAssetConnectionFilterInput,
    BaseConnectionFilter,
    ConnectionOrderBy,
    DatasetRelationInput,
    DbtDownstreamLineageInput,
    DbtModelRelationInput,
    DbtUpstreamLineageInput,
    GovernedTagFilterInput,
    KnowledgeCardConnectionFilterInput,
    LineageFilterInput,
    NamespaceInfoConnectionFilterInput,
    PersonConnectionFilterInput,
    PinsConnectionFilterInput,
    QueryInfoConnectionFilterInput,
    RecentUserActivitiesFilterInput,
    ResourceInfoConnectionFilterInput,
    TableauDatasourceDownstreamLineageInput,
    TableauDatasourceUpstreamLineageInput,
    ThoughtSpotDataObjectDownstreamLineageInput,
    ThoughtSpotDataObjectUpstreamLineageInput,
)


class AISearchQueryFields(GraphQLField):
    query: "AISearchQueryGraphQLField" = AISearchQueryGraphQLField("query")

    def fields(self, *subfields: AISearchQueryGraphQLField) -> "AISearchQueryFields":
        """Subfields should come from the AISearchQueryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AISearchQueryFields":
        self._alias = alias
        return self


class AcknowledgeChangeRequestFields(GraphQLField):
    @classmethod
    def acknowledgedBy(cls) -> "AuditStampFields":
        return AuditStampFields("acknowledgedBy")

    entityId: "AcknowledgeChangeRequestGraphQLField" = (
        AcknowledgeChangeRequestGraphQLField("entityId")
    )
    message: "AcknowledgeChangeRequestGraphQLField" = (
        AcknowledgeChangeRequestGraphQLField("message")
    )

    def fields(
        self,
        *subfields: Union[AcknowledgeChangeRequestGraphQLField, "AuditStampFields"]
    ) -> "AcknowledgeChangeRequestFields":
        """Subfields should come from the AcknowledgeChangeRequestFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AcknowledgeChangeRequestFields":
        self._alias = alias
        return self


class ActivityDependencyFields(GraphQLField):
    dependencyConditions: "ActivityDependencyGraphQLField" = (
        ActivityDependencyGraphQLField("dependencyConditions")
    )
    name: "ActivityDependencyGraphQLField" = ActivityDependencyGraphQLField("name")

    def fields(
        self, *subfields: ActivityDependencyGraphQLField
    ) -> "ActivityDependencyFields":
        """Subfields should come from the ActivityDependencyFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ActivityDependencyFields":
        self._alias = alias
        return self


class ActivityFeedConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "ActivityFeedEdgeFields":
        return ActivityFeedEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "ActivityFeedConnectionGraphQLField" = (
        ActivityFeedConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            ActivityFeedConnectionGraphQLField,
            "ActivityFeedEdgeFields",
            "PageInfoFields",
        ]
    ) -> "ActivityFeedConnectionFields":
        """Subfields should come from the ActivityFeedConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ActivityFeedConnectionFields":
        self._alias = alias
        return self


class ActivityFeedEdgeFields(GraphQLField):
    action: "ActivityFeedEdgeGraphQLField" = ActivityFeedEdgeGraphQLField("action")
    cursor: "ActivityFeedEdgeGraphQLField" = ActivityFeedEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "EntityInterface":
        return EntityInterface("node")

    def fields(
        self, *subfields: Union[ActivityFeedEdgeGraphQLField, "EntityInterface"]
    ) -> "ActivityFeedEdgeFields":
        """Subfields should come from the ActivityFeedEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ActivityFeedEdgeFields":
        self._alias = alias
        return self


class AggregationBucketFields(GraphQLField):
    count: "AggregationBucketGraphQLField" = AggregationBucketGraphQLField("count")
    displayName: "AggregationBucketGraphQLField" = AggregationBucketGraphQLField(
        "displayName"
    )
    key: "AggregationBucketGraphQLField" = AggregationBucketGraphQLField("key")

    def fields(
        self, *subfields: AggregationBucketGraphQLField
    ) -> "AggregationBucketFields":
        """Subfields should come from the AggregationBucketFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AggregationBucketFields":
        self._alias = alias
        return self


class AggregationMetadataFields(GraphQLField):
    @classmethod
    def buckets(cls) -> "AggregationBucketFields":
        return AggregationBucketFields("buckets")

    displayName: "AggregationMetadataGraphQLField" = AggregationMetadataGraphQLField(
        "displayName"
    )
    isCustomMetadata: "AggregationMetadataGraphQLField" = (
        AggregationMetadataGraphQLField("isCustomMetadata")
    )
    name: "AggregationMetadataGraphQLField" = AggregationMetadataGraphQLField("name")

    def fields(
        self,
        *subfields: Union[AggregationMetadataGraphQLField, "AggregationBucketFields"]
    ) -> "AggregationMetadataFields":
        """Subfields should come from the AggregationMetadataFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AggregationMetadataFields":
        self._alias = alias
        return self


class AnchorEntityLabelFields(GraphQLField):
    count: "AnchorEntityLabelGraphQLField" = AnchorEntityLabelGraphQLField("count")
    value: "AnchorEntityLabelGraphQLField" = AnchorEntityLabelGraphQLField("value")

    def fields(
        self, *subfields: AnchorEntityLabelGraphQLField
    ) -> "AnchorEntityLabelFields":
        """Subfields should come from the AnchorEntityLabelFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AnchorEntityLabelFields":
        self._alias = alias
        return self


class ApiKeyFields(GraphQLField):
    description: "ApiKeyGraphQLField" = ApiKeyGraphQLField("description")
    enabled: "ApiKeyGraphQLField" = ApiKeyGraphQLField("enabled")
    id: "ApiKeyGraphQLField" = ApiKeyGraphQLField("id")
    name: "ApiKeyGraphQLField" = ApiKeyGraphQLField("name")
    value: "ApiKeyGraphQLField" = ApiKeyGraphQLField("value")

    def fields(self, *subfields: ApiKeyGraphQLField) -> "ApiKeyFields":
        """Subfields should come from the ApiKeyFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ApiKeyFields":
        self._alias = alias
        return self


class ApiKeyBaseInterface(GraphQLField):
    description: "ApiKeyBaseGraphQLField" = ApiKeyBaseGraphQLField("description")
    enabled: "ApiKeyBaseGraphQLField" = ApiKeyBaseGraphQLField("enabled")

    def fields(self, *subfields: ApiKeyBaseGraphQLField) -> "ApiKeyBaseInterface":
        """Subfields should come from the ApiKeyBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ApiKeyBaseInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "ApiKeyBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class ApiKeyDeletionPayloadFields(GraphQLField):
    deletedIds: "ApiKeyDeletionPayloadGraphQLField" = ApiKeyDeletionPayloadGraphQLField(
        "deletedIds"
    )
    failedIds: "ApiKeyDeletionPayloadGraphQLField" = ApiKeyDeletionPayloadGraphQLField(
        "failedIds"
    )

    def fields(
        self, *subfields: ApiKeyDeletionPayloadGraphQLField
    ) -> "ApiKeyDeletionPayloadFields":
        """Subfields should come from the ApiKeyDeletionPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ApiKeyDeletionPayloadFields":
        self._alias = alias
        return self


class ApiKeyInputInterface(GraphQLField):
    description: "ApiKeyInputGraphQLField" = ApiKeyInputGraphQLField("description")
    enabled: "ApiKeyInputGraphQLField" = ApiKeyInputGraphQLField("enabled")
    name: "ApiKeyInputGraphQLField" = ApiKeyInputGraphQLField("name")

    def fields(self, *subfields: ApiKeyInputGraphQLField) -> "ApiKeyInputInterface":
        """Subfields should come from the ApiKeyInputInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ApiKeyInputInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "ApiKeyInputInterface":
        self._inline_fragments[type_name] = subfields
        return self


class AspectInterface(GraphQLField):
    createdAt: "AspectGraphQLField" = AspectGraphQLField("createdAt")
    entityId: "AspectGraphQLField" = AspectGraphQLField("entityId")

    def fields(self, *subfields: AspectGraphQLField) -> "AspectInterface":
        """Subfields should come from the AspectInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AspectInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "AspectInterface":
        self._inline_fragments[type_name] = subfields
        return self


class AssetInterface(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "AssetGraphQLField" = AssetGraphQLField("createdAt")
    deletedAt: "AssetGraphQLField" = AssetGraphQLField("deletedAt")
    displayName: "AssetGraphQLField" = AssetGraphQLField("displayName")
    entityType: "AssetGraphQLField" = AssetGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def forceShown(cls) -> "AuditStampFields":
        return AuditStampFields("forceShown")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "AssetGraphQLField" = AssetGraphQLField("id")
    isComplete: "AssetGraphQLField" = AssetGraphQLField("isComplete")
    isDeleted: "AssetGraphQLField" = AssetGraphQLField("isDeleted")
    isProduction: "AssetGraphQLField" = AssetGraphQLField("isProduction")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    lastIngestedAt: "AssetGraphQLField" = AssetGraphQLField("lastIngestedAt")
    lastModifiedAt: "AssetGraphQLField" = AssetGraphQLField("lastModifiedAt")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def sourceInfo(cls) -> "SourceInfoFields":
        return SourceInfoFields("sourceInfo")

    @classmethod
    def systemContacts(cls) -> "SystemContactsFields":
        return SystemContactsFields("systemContacts")

    @classmethod
    def systemDescription(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("systemDescription")

    systemTagValues: "AssetGraphQLField" = AssetGraphQLField("systemTagValues")

    @classmethod
    def systemTags(cls) -> "SystemTagsFields":
        return SystemTagsFields("systemTags")

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            AssetGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "AuditStampFields",
            "BrowsePathFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "SourceInfoFields",
            "SystemContactsFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
        ]
    ) -> "AssetInterface":
        """Subfields should come from the AssetInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "AssetInterface":
        self._inline_fragments[type_name] = subfields
        return self


class AssetConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "AssetEdgeFields":
        return AssetEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "AssetConnectionGraphQLField" = AssetConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            AssetConnectionGraphQLField, "AssetEdgeFields", "PageInfoFields"
        ]
    ) -> "AssetConnectionFields":
        """Subfields should come from the AssetConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetConnectionFields":
        self._alias = alias
        return self


class AssetContactsFields(GraphQLField):
    @classmethod
    def contacts(cls) -> "DesignatedContactFields":
        return DesignatedContactFields("contacts")

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "AssetContactsGraphQLField" = AssetContactsGraphQLField("createdAt")
    entityId: "AssetContactsGraphQLField" = AssetContactsGraphQLField("entityId")

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    def fields(
        self,
        *subfields: Union[
            AssetContactsGraphQLField, "AuditStampFields", "DesignatedContactFields"
        ]
    ) -> "AssetContactsFields":
        """Subfields should come from the AssetContactsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetContactsFields":
        self._alias = alias
        return self


class AssetDescriptionKnowledgeCardFields(GraphQLField):
    description: "AssetDescriptionKnowledgeCardGraphQLField" = (
        AssetDescriptionKnowledgeCardGraphQLField("description")
    )
    title: "AssetDescriptionKnowledgeCardGraphQLField" = (
        AssetDescriptionKnowledgeCardGraphQLField("title")
    )

    @classmethod
    def tokenizedContent(cls) -> "AssetDescriptionTokenizedContentFields":
        return AssetDescriptionTokenizedContentFields("tokenizedContent")

    def fields(
        self,
        *subfields: Union[
            AssetDescriptionKnowledgeCardGraphQLField,
            "AssetDescriptionTokenizedContentFields",
        ]
    ) -> "AssetDescriptionKnowledgeCardFields":
        """Subfields should come from the AssetDescriptionKnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetDescriptionKnowledgeCardFields":
        self._alias = alias
        return self


class AssetDescriptionTokenizedContentFields(GraphQLField):
    description: "AssetDescriptionTokenizedContentGraphQLField" = (
        AssetDescriptionTokenizedContentGraphQLField("description")
    )

    def fields(
        self, *subfields: AssetDescriptionTokenizedContentGraphQLField
    ) -> "AssetDescriptionTokenizedContentFields":
        """Subfields should come from the AssetDescriptionTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetDescriptionTokenizedContentFields":
        self._alias = alias
        return self


class AssetDocumentAggregationBucketFields(GraphQLField):
    count: "AssetDocumentAggregationBucketGraphQLField" = (
        AssetDocumentAggregationBucketGraphQLField("count")
    )
    entityType: "AssetDocumentAggregationBucketGraphQLField" = (
        AssetDocumentAggregationBucketGraphQLField("entityType")
    )
    subType: "AssetDocumentAggregationBucketGraphQLField" = (
        AssetDocumentAggregationBucketGraphQLField("subType")
    )

    def fields(
        self, *subfields: AssetDocumentAggregationBucketGraphQLField
    ) -> "AssetDocumentAggregationBucketFields":
        """Subfields should come from the AssetDocumentAggregationBucketFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetDocumentAggregationBucketFields":
        self._alias = alias
        return self


class AssetEdgeFields(GraphQLField):
    cursor: "AssetEdgeGraphQLField" = AssetEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "AssetInterface":
        return AssetInterface("node")

    def fields(
        self, *subfields: Union[AssetEdgeGraphQLField, "AssetInterface"]
    ) -> "AssetEdgeFields":
        """Subfields should come from the AssetEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetEdgeFields":
        self._alias = alias
        return self


class AssetFollowersFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "AssetFollowersGraphQLField" = AssetFollowersGraphQLField("createdAt")
    entityId: "AssetFollowersGraphQLField" = AssetFollowersGraphQLField("entityId")
    followedBy: "AssetFollowersGraphQLField" = AssetFollowersGraphQLField("followedBy")

    @classmethod
    def followers(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("followers", arguments=cleared_arguments)

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    numberOfFollowers: "AssetFollowersGraphQLField" = AssetFollowersGraphQLField(
        "numberOfFollowers"
    )
    viewerCanUnfollow: "AssetFollowersGraphQLField" = AssetFollowersGraphQLField(
        "viewerCanUnfollow"
    )
    viewerDoesFollow: "AssetFollowersGraphQLField" = AssetFollowersGraphQLField(
        "viewerDoesFollow"
    )
    viewerIsMutedNotifications: "AssetFollowersGraphQLField" = (
        AssetFollowersGraphQLField("viewerIsMutedNotifications")
    )

    def fields(
        self,
        *subfields: Union[
            AssetFollowersGraphQLField, "AuditStampFields", "EntityConnectionFields"
        ]
    ) -> "AssetFollowersFields":
        """Subfields should come from the AssetFollowersFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetFollowersFields":
        self._alias = alias
        return self


class AssetLikesFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "AssetLikesGraphQLField" = AssetLikesGraphQLField("createdAt")
    entityId: "AssetLikesGraphQLField" = AssetLikesGraphQLField("entityId")

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    likeCount: "AssetLikesGraphQLField" = AssetLikesGraphQLField("likeCount")

    @classmethod
    def likedBy(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("likedBy", arguments=cleared_arguments)

    viewerDoesLike: "AssetLikesGraphQLField" = AssetLikesGraphQLField("viewerDoesLike")

    def fields(
        self,
        *subfields: Union[
            AssetLikesGraphQLField, "AuditStampFields", "PersonConnectionFields"
        ]
    ) -> "AssetLikesFields":
        """Subfields should come from the AssetLikesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetLikesFields":
        self._alias = alias
        return self


class AssetSearchDocumentFields(GraphQLField):
    browsePathHierarchy: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browsePathSegments: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    columnDescriptions: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("columnDescriptions")
    )
    columnNames: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "columnNames"
    )
    columnTags: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "columnTags"
    )
    contactDisplayNames: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("contactDisplayNames")
    )
    created: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "created"
    )

    @classmethod
    def dashboard(cls) -> "DashboardSearchInfoFields":
        return DashboardSearchInfoFields("dashboard")

    @classmethod
    def dataset(cls) -> "DatasetSearchInfoFields":
        return DatasetSearchInfoFields("dataset")

    description: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "description"
    )
    documentId: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "documentId"
    )
    domainDisplayNames: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("domainDisplayNames")
    )
    domains: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "domains"
    )
    embeddedString_1: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("embeddedString_1")
    )
    embeddedString_2: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("embeddedString_2")
    )
    entityId: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "entityId"
    )
    entityType: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "entityType"
    )
    governedTags: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "governedTags"
    )
    hasColumnLineage: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("hasColumnLineage")
    )
    hasTableLineage: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("hasTableLineage")
    )
    hashtags: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "hashtags"
    )
    hierarchies: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "hierarchies"
    )

    @classmethod
    def highlight(cls) -> "AssetSearchHighlightFields":
        return AssetSearchHighlightFields("highlight")

    isComplete: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "isComplete"
    )
    isDeleted: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "isDeleted"
    )
    isProduction: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "isProduction"
    )
    knowledgeCardCount: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("knowledgeCardCount")
    )
    lastQueried: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "lastQueried"
    )
    lastRefreshed: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "lastRefreshed"
    )
    lastUpdated: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "lastUpdated"
    )

    @classmethod
    def metric(cls) -> "MetricSearchInfoFields":
        return MetricSearchInfoFields("metric")

    model: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField("model")
    name: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField("name")
    overallDataQuality: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("overallDataQuality")
    )
    paginationToken: "AssetSearchDocumentGraphQLField" = (
        AssetSearchDocumentGraphQLField("paginationToken")
    )

    @classmethod
    def pipeline(cls) -> "PipelineSearchInfoFields":
        return PipelineSearchInfoFields("pipeline")

    platform: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "platform"
    )
    project: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "project"
    )

    @classmethod
    def scoreDetails(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("scoreDetails")

    subType: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "subType"
    )
    viewCount: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "viewCount"
    )

    @classmethod
    def virtualView(cls) -> "VirtualViewSearchInfoFields":
        return VirtualViewSearchInfoFields("virtualView")

    workspace: "AssetSearchDocumentGraphQLField" = AssetSearchDocumentGraphQLField(
        "workspace"
    )

    def fields(
        self,
        *subfields: Union[
            AssetSearchDocumentGraphQLField,
            "AssetSearchHighlightFields",
            "BrowsePathFields",
            "DashboardSearchInfoFields",
            "DatasetSearchInfoFields",
            "MetricSearchInfoFields",
            "PipelineSearchInfoFields",
            "SearchScoreDetailsFields",
            "VirtualViewSearchInfoFields",
        ]
    ) -> "AssetSearchDocumentFields":
        """Subfields should come from the AssetSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetSearchDocumentFields":
        self._alias = alias
        return self


class AssetSearchHighlightFields(GraphQLField):
    chartDescriptions: "AssetSearchHighlightGraphQLField" = (
        AssetSearchHighlightGraphQLField("chartDescriptions")
    )
    charts: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField(
        "charts"
    )
    columnDescriptions: "AssetSearchHighlightGraphQLField" = (
        AssetSearchHighlightGraphQLField("columnDescriptions")
    )
    columnNames: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField(
        "columnNames"
    )
    columnTags: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField(
        "columnTags"
    )
    contactDisplayNames: "AssetSearchHighlightGraphQLField" = (
        AssetSearchHighlightGraphQLField("contactDisplayNames")
    )
    dashboardId: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField(
        "dashboardId"
    )
    description: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField(
        "description"
    )
    governedTags: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField(
        "governedTags"
    )
    hashtags: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField(
        "hashtags"
    )
    name: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField("name")
    pipelineId: "AssetSearchHighlightGraphQLField" = AssetSearchHighlightGraphQLField(
        "pipelineId"
    )

    def fields(
        self, *subfields: AssetSearchHighlightGraphQLField
    ) -> "AssetSearchHighlightFields":
        """Subfields should come from the AssetSearchHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetSearchHighlightFields":
        self._alias = alias
        return self


class AssetSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "AssetSearchDocumentFields":
        return AssetSearchDocumentFields("documents")

    errorMessage: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField(
        "errorMessage"
    )
    from_: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField("from")
    hasMore: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField("hasMore")

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField(
        "paginationToken"
    )
    searchContext: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField(
        "searchContext"
    )
    searchIndex: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField(
        "searchIndex"
    )
    size: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField("size")
    totalCount: "AssetSearchResultGraphQLField" = AssetSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            AssetSearchResultGraphQLField,
            "AggregationMetadataFields",
            "AssetSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "AssetSearchResultFields":
        """Subfields should come from the AssetSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetSearchResultFields":
        self._alias = alias
        return self


class AssetStructureFields(GraphQLField):
    createdAt: "AssetStructureGraphQLField" = AssetStructureGraphQLField("createdAt")
    directories: "AssetStructureGraphQLField" = AssetStructureGraphQLField(
        "directories"
    )
    entityId: "AssetStructureGraphQLField" = AssetStructureGraphQLField("entityId")
    name: "AssetStructureGraphQLField" = AssetStructureGraphQLField("name")

    def fields(self, *subfields: AssetStructureGraphQLField) -> "AssetStructureFields":
        """Subfields should come from the AssetStructureFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AssetStructureFields":
        self._alias = alias
        return self


class AthenaQueryResultFields(GraphQLField):
    columns: "AthenaQueryResultGraphQLField" = AthenaQueryResultGraphQLField("columns")
    nextToken: "AthenaQueryResultGraphQLField" = AthenaQueryResultGraphQLField(
        "nextToken"
    )

    @classmethod
    def rows(cls) -> "AthenaResultRowFields":
        return AthenaResultRowFields("rows")

    def fields(
        self, *subfields: Union[AthenaQueryResultGraphQLField, "AthenaResultRowFields"]
    ) -> "AthenaQueryResultFields":
        """Subfields should come from the AthenaQueryResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AthenaQueryResultFields":
        self._alias = alias
        return self


class AthenaResultRowFields(GraphQLField):
    values: "AthenaResultRowGraphQLField" = AthenaResultRowGraphQLField("values")

    def fields(
        self, *subfields: AthenaResultRowGraphQLField
    ) -> "AthenaResultRowFields":
        """Subfields should come from the AthenaResultRowFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AthenaResultRowFields":
        self._alias = alias
        return self


class AuditStampFields(GraphQLField):
    @classmethod
    def actingPerson(cls) -> "PersonFields":
        return PersonFields("actingPerson")

    actor: "AuditStampGraphQLField" = AuditStampGraphQLField("actor")
    time: "AuditStampGraphQLField" = AuditStampGraphQLField("time")

    def fields(
        self, *subfields: Union[AuditStampGraphQLField, "PersonFields"]
    ) -> "AuditStampFields":
        """Subfields should come from the AuditStampFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AuditStampFields":
        self._alias = alias
        return self


class AuthorizationFields(GraphQLField):
    newUserDefaultRole: "AuthorizationGraphQLField" = AuthorizationGraphQLField(
        "newUserDefaultRole"
    )

    def fields(self, *subfields: AuthorizationGraphQLField) -> "AuthorizationFields":
        """Subfields should come from the AuthorizationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AuthorizationFields":
        self._alias = alias
        return self


class AutoGeneratedDocumentFields(GraphQLField):
    generatedContent: "AutoGeneratedDocumentGraphQLField" = (
        AutoGeneratedDocumentGraphQLField("generatedContent")
    )
    path: "AutoGeneratedDocumentGraphQLField" = AutoGeneratedDocumentGraphQLField(
        "path"
    )
    title: "AutoGeneratedDocumentGraphQLField" = AutoGeneratedDocumentGraphQLField(
        "title"
    )

    def fields(
        self, *subfields: AutoGeneratedDocumentGraphQLField
    ) -> "AutoGeneratedDocumentFields":
        """Subfields should come from the AutoGeneratedDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AutoGeneratedDocumentFields":
        self._alias = alias
        return self


class AzureAdSSOFields(GraphQLField):
    metadataUrl: "AzureAdSSOGraphQLField" = AzureAdSSOGraphQLField("metadataUrl")

    def fields(self, *subfields: AzureAdSSOGraphQLField) -> "AzureAdSSOFields":
        """Subfields should come from the AzureAdSSOFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AzureAdSSOFields":
        self._alias = alias
        return self


class AzureDataFactoryActivityFields(GraphQLField):
    @classmethod
    def dependsOn(cls) -> "ActivityDependencyFields":
        return ActivityDependencyFields("dependsOn")

    name: "AzureDataFactoryActivityGraphQLField" = AzureDataFactoryActivityGraphQLField(
        "name"
    )
    type: "AzureDataFactoryActivityGraphQLField" = AzureDataFactoryActivityGraphQLField(
        "type"
    )

    def fields(
        self,
        *subfields: Union[
            AzureDataFactoryActivityGraphQLField, "ActivityDependencyFields"
        ]
    ) -> "AzureDataFactoryActivityFields":
        """Subfields should come from the AzureDataFactoryActivityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AzureDataFactoryActivityFields":
        self._alias = alias
        return self


class AzureDataFactoryPipelineFields(GraphQLField):
    @classmethod
    def activities(cls) -> "AzureDataFactoryActivityFields":
        return AzureDataFactoryActivityFields("activities")

    createdAt: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("createdAt")
    )
    entityId: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("entityId")
    )
    factory: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("factory")
    )
    lastDurationInMs: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("lastDurationInMs")
    )
    lastInvokeType: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("lastInvokeType")
    )
    lastPublishTime: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("lastPublishTime")
    )
    lastRunEnd: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("lastRunEnd")
    )
    lastRunMessage: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("lastRunMessage")
    )
    lastRunStart: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("lastRunStart")
    )
    lastRunStatus: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("lastRunStatus")
    )
    pipelineName: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("pipelineName")
    )
    pipelineUrl: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("pipelineUrl")
    )
    sinks: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("sinks")
    )
    sources: "AzureDataFactoryPipelineGraphQLField" = (
        AzureDataFactoryPipelineGraphQLField("sources")
    )

    def fields(
        self,
        *subfields: Union[
            AzureDataFactoryPipelineGraphQLField, "AzureDataFactoryActivityFields"
        ]
    ) -> "AzureDataFactoryPipelineFields":
        """Subfields should come from the AzureDataFactoryPipelineFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AzureDataFactoryPipelineFields":
        self._alias = alias
        return self


class BrowsePathFields(GraphQLField):
    index: "BrowsePathGraphQLField" = BrowsePathGraphQLField("index")

    @classmethod
    def segments(cls) -> "BrowsePathSegmentFields":
        return BrowsePathSegmentFields("segments")

    def fields(
        self, *subfields: Union[BrowsePathGraphQLField, "BrowsePathSegmentFields"]
    ) -> "BrowsePathFields":
        """Subfields should come from the BrowsePathFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "BrowsePathFields":
        self._alias = alias
        return self


class BrowsePathSegmentFields(GraphQLField):
    count: "BrowsePathSegmentGraphQLField" = BrowsePathSegmentGraphQLField("count")
    displayName: "BrowsePathSegmentGraphQLField" = BrowsePathSegmentGraphQLField(
        "displayName"
    )
    nativeType: "BrowsePathSegmentGraphQLField" = BrowsePathSegmentGraphQLField(
        "nativeType"
    )
    segmentId: "BrowsePathSegmentGraphQLField" = BrowsePathSegmentGraphQLField(
        "segmentId"
    )
    text: "BrowsePathSegmentGraphQLField" = BrowsePathSegmentGraphQLField("text")
    type: "BrowsePathSegmentGraphQLField" = BrowsePathSegmentGraphQLField("type")

    def fields(
        self, *subfields: BrowsePathSegmentGraphQLField
    ) -> "BrowsePathSegmentFields":
        """Subfields should come from the BrowsePathSegmentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "BrowsePathSegmentFields":
        self._alias = alias
        return self


class ChangeRequestKnowledgeCardFields(GraphQLField):
    @classmethod
    def acknowledged(cls) -> "AcknowledgeChangeRequestFields":
        return AcknowledgeChangeRequestFields("acknowledged")

    message: "ChangeRequestKnowledgeCardGraphQLField" = (
        ChangeRequestKnowledgeCardGraphQLField("message")
    )

    @classmethod
    def recipient(cls) -> "EntityInterface":
        return EntityInterface("recipient")

    recipientId: "ChangeRequestKnowledgeCardGraphQLField" = (
        ChangeRequestKnowledgeCardGraphQLField("recipientId")
    )
    requestType: "ChangeRequestKnowledgeCardGraphQLField" = (
        ChangeRequestKnowledgeCardGraphQLField("requestType")
    )

    @classmethod
    def status(cls) -> "StatusFields":
        return StatusFields("status")

    title: "ChangeRequestKnowledgeCardGraphQLField" = (
        ChangeRequestKnowledgeCardGraphQLField("title")
    )

    @classmethod
    def tokenizedContent(cls) -> "ChangeRequestTokenizedContentFields":
        return ChangeRequestTokenizedContentFields("tokenizedContent")

    def fields(
        self,
        *subfields: Union[
            ChangeRequestKnowledgeCardGraphQLField,
            "AcknowledgeChangeRequestFields",
            "ChangeRequestTokenizedContentFields",
            "EntityInterface",
            "StatusFields",
        ]
    ) -> "ChangeRequestKnowledgeCardFields":
        """Subfields should come from the ChangeRequestKnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ChangeRequestKnowledgeCardFields":
        self._alias = alias
        return self


class ChangeRequestTokenizedContentFields(GraphQLField):
    message: "ChangeRequestTokenizedContentGraphQLField" = (
        ChangeRequestTokenizedContentGraphQLField("message")
    )

    def fields(
        self, *subfields: ChangeRequestTokenizedContentGraphQLField
    ) -> "ChangeRequestTokenizedContentFields":
        """Subfields should come from the ChangeRequestTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ChangeRequestTokenizedContentFields":
        self._alias = alias
        return self


class ChartFields(GraphQLField):
    chartType: "ChartGraphQLField" = ChartGraphQLField("chartType")
    description: "ChartGraphQLField" = ChartGraphQLField("description")
    id: "ChartGraphQLField" = ChartGraphQLField("id")
    preview: "ChartGraphQLField" = ChartGraphQLField("preview")

    @classmethod
    def query(cls) -> "ChartQueryFields":
        return ChartQueryFields("query")

    title: "ChartGraphQLField" = ChartGraphQLField("title")
    url: "ChartGraphQLField" = ChartGraphQLField("url")

    def fields(
        self, *subfields: Union[ChartGraphQLField, "ChartQueryFields"]
    ) -> "ChartFields":
        """Subfields should come from the ChartFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ChartFields":
        self._alias = alias
        return self


class ChartQueryFields(GraphQLField):
    account: "ChartQueryGraphQLField" = ChartQueryGraphQLField("account")
    defaultDatabase: "ChartQueryGraphQLField" = ChartQueryGraphQLField(
        "defaultDatabase"
    )
    defaultSchema: "ChartQueryGraphQLField" = ChartQueryGraphQLField("defaultSchema")
    platform: "ChartQueryGraphQLField" = ChartQueryGraphQLField("platform")
    query: "ChartQueryGraphQLField" = ChartQueryGraphQLField("query")

    def fields(self, *subfields: ChartQueryGraphQLField) -> "ChartQueryFields":
        """Subfields should come from the ChartQueryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ChartQueryFields":
        self._alias = alias
        return self


class ColumnDescriptionKnowledgeCardFields(GraphQLField):
    description: "ColumnDescriptionKnowledgeCardGraphQLField" = (
        ColumnDescriptionKnowledgeCardGraphQLField("description")
    )
    fieldPath: "ColumnDescriptionKnowledgeCardGraphQLField" = (
        ColumnDescriptionKnowledgeCardGraphQLField("fieldPath")
    )
    fieldPathNamespace: "ColumnDescriptionKnowledgeCardGraphQLField" = (
        ColumnDescriptionKnowledgeCardGraphQLField("fieldPathNamespace")
    )
    title: "ColumnDescriptionKnowledgeCardGraphQLField" = (
        ColumnDescriptionKnowledgeCardGraphQLField("title")
    )

    def fields(
        self, *subfields: ColumnDescriptionKnowledgeCardGraphQLField
    ) -> "ColumnDescriptionKnowledgeCardFields":
        """Subfields should come from the ColumnDescriptionKnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ColumnDescriptionKnowledgeCardFields":
        self._alias = alias
        return self


class CommentFields(GraphQLField):
    comment: "CommentGraphQLField" = CommentGraphQLField("comment")
    parentCommentId: "CommentGraphQLField" = CommentGraphQLField("parentCommentId")

    @classmethod
    def replies(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("replies", arguments=cleared_arguments)

    title: "CommentGraphQLField" = CommentGraphQLField("title")

    @classmethod
    def tokenizedContent(cls) -> "CommentTokenizedContentFields":
        return CommentTokenizedContentFields("tokenizedContent")

    def fields(
        self,
        *subfields: Union[
            CommentGraphQLField,
            "CommentTokenizedContentFields",
            "KnowledgeCardConnectionFields",
        ]
    ) -> "CommentFields":
        """Subfields should come from the CommentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CommentFields":
        self._alias = alias
        return self


class CommentTokenizedContentFields(GraphQLField):
    comment: "CommentTokenizedContentGraphQLField" = (
        CommentTokenizedContentGraphQLField("comment")
    )

    def fields(
        self, *subfields: CommentTokenizedContentGraphQLField
    ) -> "CommentTokenizedContentFields":
        """Subfields should come from the CommentTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CommentTokenizedContentFields":
        self._alias = alias
        return self


class CommonColumnAttributesFields(GraphQLField):
    @classmethod
    def assetContacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("assetContacts")

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "CommonColumnAttributesGraphQLField" = (
        CommonColumnAttributesGraphQLField("createdAt")
    )

    @classmethod
    def description(cls) -> "UserDefinedResourceDescriptionFields":
        return UserDefinedResourceDescriptionFields("description")

    entityId: "CommonColumnAttributesGraphQLField" = CommonColumnAttributesGraphQLField(
        "entityId"
    )

    @classmethod
    def exclusion(cls) -> "DatasetColumnsFields":
        return DatasetColumnsFields("exclusion")

    @classmethod
    def governedTags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governedTags", arguments=cleared_arguments
        )

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    def fields(
        self,
        *subfields: Union[
            CommonColumnAttributesGraphQLField,
            "AssetContactsFields",
            "AuditStampFields",
            "DatasetColumnsFields",
            "UserDefinedResourceConnectionFields",
            "UserDefinedResourceDescriptionFields",
        ]
    ) -> "CommonColumnAttributesFields":
        """Subfields should come from the CommonColumnAttributesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CommonColumnAttributesFields":
        self._alias = alias
        return self


class CommonColumnAttributesBaseInterface(GraphQLField):
    createdAt: "CommonColumnAttributesBaseGraphQLField" = (
        CommonColumnAttributesBaseGraphQLField("createdAt")
    )

    @classmethod
    def description(cls) -> "UserDefinedResourceDescriptionFields":
        return UserDefinedResourceDescriptionFields("description")

    entityId: "CommonColumnAttributesBaseGraphQLField" = (
        CommonColumnAttributesBaseGraphQLField("entityId")
    )

    @classmethod
    def exclusion(cls) -> "DatasetColumnsFields":
        return DatasetColumnsFields("exclusion")

    def fields(
        self,
        *subfields: Union[
            CommonColumnAttributesBaseGraphQLField,
            "DatasetColumnsFields",
            "UserDefinedResourceDescriptionFields",
        ]
    ) -> "CommonColumnAttributesBaseInterface":
        """Subfields should come from the CommonColumnAttributesBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CommonColumnAttributesBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "CommonColumnAttributesBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class CrawlerFields(GraphQLField):
    contacts: "CrawlerGraphQLField" = CrawlerGraphQLField("contacts")
    crawlerConfig: "CrawlerGraphQLField" = CrawlerGraphQLField("crawlerConfig")
    displayName: "CrawlerGraphQLField" = CrawlerGraphQLField("displayName")
    id: "CrawlerGraphQLField" = CrawlerGraphQLField("id")
    isMetaphorManaged: "CrawlerGraphQLField" = CrawlerGraphQLField("isMetaphorManaged")
    platform: "CrawlerGraphQLField" = CrawlerGraphQLField("platform")

    @classmethod
    def runHistory(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "CrawlerRunMetadataConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return CrawlerRunMetadataConnectionFields(
            "runHistory", arguments=cleared_arguments
        )

    @classmethod
    def runMetadata(cls) -> "CrawlerRunMetadataFields":
        return CrawlerRunMetadataFields("runMetadata")

    @classmethod
    def schedule(cls) -> "CrawlerScheduleFields":
        return CrawlerScheduleFields("schedule")

    @classmethod
    def status(cls) -> "CrawlerRunStatusFields":
        return CrawlerRunStatusFields("status")

    def fields(
        self,
        *subfields: Union[
            CrawlerGraphQLField,
            "CrawlerRunMetadataConnectionFields",
            "CrawlerRunMetadataFields",
            "CrawlerRunStatusFields",
            "CrawlerScheduleFields",
        ]
    ) -> "CrawlerFields":
        """Subfields should come from the CrawlerFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerFields":
        self._alias = alias
        return self


class CrawlerMetadataBaseInterface(GraphQLField):
    id: "CrawlerMetadataBaseGraphQLField" = CrawlerMetadataBaseGraphQLField("id")
    isMetaphorManaged: "CrawlerMetadataBaseGraphQLField" = (
        CrawlerMetadataBaseGraphQLField("isMetaphorManaged")
    )

    def fields(
        self, *subfields: CrawlerMetadataBaseGraphQLField
    ) -> "CrawlerMetadataBaseInterface":
        """Subfields should come from the CrawlerMetadataBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerMetadataBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "CrawlerMetadataBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class CrawlerRunMetadataFields(GraphQLField):
    crawlerName: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "crawlerName"
    )
    description: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "description"
    )
    endTime: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "endTime"
    )
    entityCount: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "entityCount"
    )
    errorMessage: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "errorMessage"
    )
    logFile: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "logFile"
    )
    logFileSignedUrl: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "logFileSignedUrl"
    )
    platform: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "platform"
    )
    stackTrace: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "stackTrace"
    )
    startTime: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField(
        "startTime"
    )
    status: "CrawlerRunMetadataGraphQLField" = CrawlerRunMetadataGraphQLField("status")

    def fields(
        self, *subfields: CrawlerRunMetadataGraphQLField
    ) -> "CrawlerRunMetadataFields":
        """Subfields should come from the CrawlerRunMetadataFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerRunMetadataFields":
        self._alias = alias
        return self


class CrawlerRunMetadataConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "CrawlerRunMetadataEdgeFields":
        return CrawlerRunMetadataEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "CrawlerRunMetadataConnectionGraphQLField" = (
        CrawlerRunMetadataConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            CrawlerRunMetadataConnectionGraphQLField,
            "CrawlerRunMetadataEdgeFields",
            "PageInfoFields",
        ]
    ) -> "CrawlerRunMetadataConnectionFields":
        """Subfields should come from the CrawlerRunMetadataConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerRunMetadataConnectionFields":
        self._alias = alias
        return self


class CrawlerRunMetadataEdgeFields(GraphQLField):
    cursor: "CrawlerRunMetadataEdgeGraphQLField" = CrawlerRunMetadataEdgeGraphQLField(
        "cursor"
    )

    @classmethod
    def node(cls) -> "CrawlerRunMetadataFields":
        return CrawlerRunMetadataFields("node")

    def fields(
        self,
        *subfields: Union[
            CrawlerRunMetadataEdgeGraphQLField, "CrawlerRunMetadataFields"
        ]
    ) -> "CrawlerRunMetadataEdgeFields":
        """Subfields should come from the CrawlerRunMetadataEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerRunMetadataEdgeFields":
        self._alias = alias
        return self


class CrawlerRunStatusFields(GraphQLField):
    estimatedCompletionTime: "CrawlerRunStatusGraphQLField" = (
        CrawlerRunStatusGraphQLField("estimatedCompletionTime")
    )
    lastStatus: "CrawlerRunStatusGraphQLField" = CrawlerRunStatusGraphQLField(
        "lastStatus"
    )
    startTime: "CrawlerRunStatusGraphQLField" = CrawlerRunStatusGraphQLField(
        "startTime"
    )

    def fields(
        self, *subfields: CrawlerRunStatusGraphQLField
    ) -> "CrawlerRunStatusFields":
        """Subfields should come from the CrawlerRunStatusFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerRunStatusFields":
        self._alias = alias
        return self


class CrawlerScheduleFields(GraphQLField):
    description: "CrawlerScheduleGraphQLField" = CrawlerScheduleGraphQLField(
        "description"
    )
    enabled: "CrawlerScheduleGraphQLField" = CrawlerScheduleGraphQLField("enabled")
    isDaily: "CrawlerScheduleGraphQLField" = CrawlerScheduleGraphQLField("isDaily")
    schedule: "CrawlerScheduleGraphQLField" = CrawlerScheduleGraphQLField("schedule")
    type: "CrawlerScheduleGraphQLField" = CrawlerScheduleGraphQLField("type")

    def fields(
        self, *subfields: CrawlerScheduleGraphQLField
    ) -> "CrawlerScheduleFields":
        """Subfields should come from the CrawlerScheduleFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerScheduleFields":
        self._alias = alias
        return self


class CrawlerTypeResponseFields(GraphQLField):
    platform: "CrawlerTypeResponseGraphQLField" = CrawlerTypeResponseGraphQLField(
        "platform"
    )
    type: "CrawlerTypeResponseGraphQLField" = CrawlerTypeResponseGraphQLField("type")

    def fields(
        self, *subfields: CrawlerTypeResponseGraphQLField
    ) -> "CrawlerTypeResponseFields":
        """Subfields should come from the CrawlerTypeResponseFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CrawlerTypeResponseFields":
        self._alias = alias
        return self


class CustomAttributesFields(GraphQLField):
    color: "CustomAttributesGraphQLField" = CustomAttributesGraphQLField("color")
    iconKey: "CustomAttributesGraphQLField" = CustomAttributesGraphQLField("iconKey")

    def fields(
        self, *subfields: CustomAttributesGraphQLField
    ) -> "CustomAttributesFields":
        """Subfields should come from the CustomAttributesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CustomAttributesFields":
        self._alias = alias
        return self


class CustomDirectorySearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "NamespaceSearchDocumentFields":
        return NamespaceSearchDocumentFields("documents")

    errorMessage: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("errorMessage")
    )
    from_: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("from")
    )
    hasMore: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("paginationToken")
    )
    searchContext: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("searchContext")
    )
    searchIndex: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("searchIndex")
    )
    size: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("size")
    )
    totalCount: "CustomDirectorySearchResultGraphQLField" = (
        CustomDirectorySearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            CustomDirectorySearchResultGraphQLField,
            "AggregationMetadataFields",
            "NamespaceSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "CustomDirectorySearchResultFields":
        """Subfields should come from the CustomDirectorySearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CustomDirectorySearchResultFields":
        self._alias = alias
        return self


class CustomMetadataFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "CustomMetadataGraphQLField" = CustomMetadataGraphQLField("createdAt")
    entityId: "CustomMetadataGraphQLField" = CustomMetadataGraphQLField("entityId")

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    @classmethod
    def metadata(cls) -> "CustomMetadataItemFields":
        return CustomMetadataItemFields("metadata")

    def fields(
        self,
        *subfields: Union[
            CustomMetadataGraphQLField, "AuditStampFields", "CustomMetadataItemFields"
        ]
    ) -> "CustomMetadataFields":
        """Subfields should come from the CustomMetadataFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CustomMetadataFields":
        self._alias = alias
        return self


class CustomMetadataConfigFields(GraphQLField):
    dataType: "CustomMetadataConfigGraphQLField" = CustomMetadataConfigGraphQLField(
        "dataType"
    )
    displayName: "CustomMetadataConfigGraphQLField" = CustomMetadataConfigGraphQLField(
        "displayName"
    )
    highlight: "CustomMetadataConfigGraphQLField" = CustomMetadataConfigGraphQLField(
        "highlight"
    )
    key: "CustomMetadataConfigGraphQLField" = CustomMetadataConfigGraphQLField("key")
    searchable: "CustomMetadataConfigGraphQLField" = CustomMetadataConfigGraphQLField(
        "searchable"
    )

    def fields(
        self, *subfields: CustomMetadataConfigGraphQLField
    ) -> "CustomMetadataConfigFields":
        """Subfields should come from the CustomMetadataConfigFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CustomMetadataConfigFields":
        self._alias = alias
        return self


class CustomMetadataItemFields(GraphQLField):
    key: "CustomMetadataItemGraphQLField" = CustomMetadataItemGraphQLField("key")
    value: "CustomMetadataItemGraphQLField" = CustomMetadataItemGraphQLField("value")

    def fields(
        self, *subfields: CustomMetadataItemGraphQLField
    ) -> "CustomMetadataItemFields":
        """Subfields should come from the CustomMetadataItemFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CustomMetadataItemFields":
        self._alias = alias
        return self


class CustomSortableNamedAssetCollectionFields(GraphQLField):
    assetIds: "CustomSortableNamedAssetCollectionGraphQLField" = (
        CustomSortableNamedAssetCollectionGraphQLField("assetIds")
    )

    @classmethod
    def assets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("assets", arguments=cleared_arguments)

    @classmethod
    def customAssetOrdering(
        cls, *, type: Optional[UserDefinedOrderType] = None
    ) -> "OrderedEntryFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "UserDefinedOrderType", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return OrderedEntryFields("customAssetOrdering", arguments=cleared_arguments)

    id: "CustomSortableNamedAssetCollectionGraphQLField" = (
        CustomSortableNamedAssetCollectionGraphQLField("id")
    )
    name: "CustomSortableNamedAssetCollectionGraphQLField" = (
        CustomSortableNamedAssetCollectionGraphQLField("name")
    )
    position: "CustomSortableNamedAssetCollectionGraphQLField" = (
        CustomSortableNamedAssetCollectionGraphQLField("position")
    )

    def fields(
        self,
        *subfields: Union[
            CustomSortableNamedAssetCollectionGraphQLField,
            "EntityConnectionFields",
            "OrderedEntryFields",
        ]
    ) -> "CustomSortableNamedAssetCollectionFields":
        """Subfields should come from the CustomSortableNamedAssetCollectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CustomSortableNamedAssetCollectionFields":
        self._alias = alias
        return self


class CustomSortableSavedLiveQueryFields(GraphQLField):
    context: "CustomSortableSavedLiveQueryGraphQLField" = (
        CustomSortableSavedLiveQueryGraphQLField("context")
    )

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    facetsJSON: "CustomSortableSavedLiveQueryGraphQLField" = (
        CustomSortableSavedLiveQueryGraphQLField("facetsJSON")
    )
    id: "CustomSortableSavedLiveQueryGraphQLField" = (
        CustomSortableSavedLiveQueryGraphQLField("id")
    )
    keyword: "CustomSortableSavedLiveQueryGraphQLField" = (
        CustomSortableSavedLiveQueryGraphQLField("keyword")
    )

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    name: "CustomSortableSavedLiveQueryGraphQLField" = (
        CustomSortableSavedLiveQueryGraphQLField("name")
    )
    position: "CustomSortableSavedLiveQueryGraphQLField" = (
        CustomSortableSavedLiveQueryGraphQLField("position")
    )

    def fields(
        self,
        *subfields: Union[CustomSortableSavedLiveQueryGraphQLField, "AuditStampFields"]
    ) -> "CustomSortableSavedLiveQueryFields":
        """Subfields should come from the CustomSortableSavedLiveQueryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CustomSortableSavedLiveQueryFields":
        self._alias = alias
        return self


class CustomTagAttributesFields(GraphQLField):
    color: "CustomTagAttributesGraphQLField" = CustomTagAttributesGraphQLField("color")
    iconKey: "CustomTagAttributesGraphQLField" = CustomTagAttributesGraphQLField(
        "iconKey"
    )

    def fields(
        self, *subfields: CustomTagAttributesGraphQLField
    ) -> "CustomTagAttributesFields":
        """Subfields should come from the CustomTagAttributesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CustomTagAttributesFields":
        self._alias = alias
        return self


class DashboardFields(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def assetContacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("assetContacts")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "DashboardGraphQLField" = DashboardGraphQLField("createdAt")

    @classmethod
    def dashboardInfo(cls) -> "DashboardInfoFields":
        return DashboardInfoFields("dashboardInfo")

    deletedAt: "DashboardGraphQLField" = DashboardGraphQLField("deletedAt")

    @classmethod
    def descriptions(cls) -> "DerivedAssetDescriptionsFields":
        return DerivedAssetDescriptionsFields("descriptions")

    displayName: "DashboardGraphQLField" = DashboardGraphQLField("displayName")

    @classmethod
    def downstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineageFor: Optional[LineageFilterInput] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineageFor},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstreamOfType", arguments=cleared_arguments
        )

    entityType: "DashboardGraphQLField" = DashboardGraphQLField("entityType")

    @classmethod
    def entityUpstream(cls) -> "EntityUpstreamFields":
        return EntityUpstreamFields("entityUpstream")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def forceShown(cls) -> "AuditStampFields":
        return AuditStampFields("forceShown")

    @classmethod
    def governedTags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governedTags", arguments=cleared_arguments
        )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "DashboardGraphQLField" = DashboardGraphQLField("id")

    @classmethod
    def interestedParties(cls) -> "InterestedPartyFields":
        return InterestedPartyFields("interestedParties")

    isComplete: "DashboardGraphQLField" = DashboardGraphQLField("isComplete")
    isDeleted: "DashboardGraphQLField" = DashboardGraphQLField("isDeleted")
    isProduction: "DashboardGraphQLField" = DashboardGraphQLField("isProduction")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledgeCards(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledgeCards", arguments=cleared_arguments
        )

    @classmethod
    def labels(cls) -> "AnchorEntityLabelFields":
        return AnchorEntityLabelFields("labels")

    lastIngestedAt: "DashboardGraphQLField" = DashboardGraphQLField("lastIngestedAt")
    lastModifiedAt: "DashboardGraphQLField" = DashboardGraphQLField("lastModifiedAt")

    @classmethod
    def logicalId(cls) -> "DashboardLogicalIdFields":
        return DashboardLogicalIdFields("logicalId")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def overallDataQuality(cls) -> "OverallDataQualityFields":
        return OverallDataQualityFields("overallDataQuality")

    @classmethod
    def recentUserActivities(
        cls, *, input: Optional[RecentUserActivitiesFilterInput] = None
    ) -> "RecentUserActivitiesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "RecentUserActivitiesFilterInput", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return RecentUserActivitiesFields(
            "recentUserActivities", arguments=cleared_arguments
        )

    @classmethod
    def recentlyViewedBy(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "ViewedByConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewedByConnectionFields("recentlyViewedBy", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def relatedMetrics(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedMetrics", arguments=cleared_arguments)

    @classmethod
    def sourceInfo(cls) -> "SourceInfoFields":
        return SourceInfoFields("sourceInfo")

    @classmethod
    def structure(cls) -> "AssetStructureFields":
        return AssetStructureFields("structure")

    @classmethod
    def systemContacts(cls) -> "SystemContactsFields":
        return SystemContactsFields("systemContacts")

    @classmethod
    def systemDescription(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("systemDescription")

    systemTagValues: "DashboardGraphQLField" = DashboardGraphQLField("systemTagValues")

    @classmethod
    def systemTags(cls) -> "SystemTagsFields":
        return SystemTagsFields("systemTags")

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    @classmethod
    def topKnowledgeCardAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(
            "topKnowledgeCardAuthors", arguments=cleared_arguments
        )

    @classmethod
    def upstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineageFor: Optional[LineageFilterInput] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineageFor},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstreamOfType", arguments=cleared_arguments
        )

    viewerCanAssignAssetContacts: "DashboardGraphQLField" = DashboardGraphQLField(
        "viewerCanAssignAssetContacts"
    )
    viewerHasPinned: "DashboardGraphQLField" = DashboardGraphQLField("viewerHasPinned")

    def fields(
        self,
        *subfields: Union[
            DashboardGraphQLField,
            "AggregationMetadataFields",
            "AnchorEntityLabelFields",
            "AssetContactsFields",
            "AssetFollowersFields",
            "AssetStructureFields",
            "AuditStampFields",
            "BrowsePathFields",
            "DashboardInfoFields",
            "DashboardLogicalIdFields",
            "DerivedAssetDescriptionsFields",
            "EntityConnectionFields",
            "EntityLineageConnectionFields",
            "EntityUpstreamFields",
            "HashtagFields",
            "InterestedPartyFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "OverallDataQualityFields",
            "PersonConnectionFields",
            "RecentUserActivitiesFields",
            "SourceInfoFields",
            "SystemContactsFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
            "UserDefinedResourceConnectionFields",
            "ViewedByConnectionFields",
        ]
    ) -> "DashboardFields":
        """Subfields should come from the DashboardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardFields":
        self._alias = alias
        return self


class DashboardConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "DashboardEdgeFields":
        return DashboardEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "DashboardConnectionGraphQLField" = DashboardConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            DashboardConnectionGraphQLField, "DashboardEdgeFields", "PageInfoFields"
        ]
    ) -> "DashboardConnectionFields":
        """Subfields should come from the DashboardConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardConnectionFields":
        self._alias = alias
        return self


class DashboardEdgeFields(GraphQLField):
    cursor: "DashboardEdgeGraphQLField" = DashboardEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "DashboardFields":
        return DashboardFields("node")

    def fields(
        self, *subfields: Union[DashboardEdgeGraphQLField, "DashboardFields"]
    ) -> "DashboardEdgeFields":
        """Subfields should come from the DashboardEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardEdgeFields":
        self._alias = alias
        return self


class DashboardHighlightFields(GraphQLField):
    chartDescriptions: "DashboardHighlightGraphQLField" = (
        DashboardHighlightGraphQLField("chartDescriptions")
    )
    charts: "DashboardHighlightGraphQLField" = DashboardHighlightGraphQLField("charts")
    contactDisplayNames: "DashboardHighlightGraphQLField" = (
        DashboardHighlightGraphQLField("contactDisplayNames")
    )
    dashboardId: "DashboardHighlightGraphQLField" = DashboardHighlightGraphQLField(
        "dashboardId"
    )
    description: "DashboardHighlightGraphQLField" = DashboardHighlightGraphQLField(
        "description"
    )
    governedTags: "DashboardHighlightGraphQLField" = DashboardHighlightGraphQLField(
        "governedTags"
    )
    hashtags: "DashboardHighlightGraphQLField" = DashboardHighlightGraphQLField(
        "hashtags"
    )
    name: "DashboardHighlightGraphQLField" = DashboardHighlightGraphQLField("name")

    def fields(
        self, *subfields: DashboardHighlightGraphQLField
    ) -> "DashboardHighlightFields":
        """Subfields should come from the DashboardHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardHighlightFields":
        self._alias = alias
        return self


class DashboardInfoFields(GraphQLField):
    @classmethod
    def charts(cls) -> "ChartFields":
        return ChartFields("charts")

    createdAt: "DashboardInfoGraphQLField" = DashboardInfoGraphQLField("createdAt")
    dashboardType: "DashboardInfoGraphQLField" = DashboardInfoGraphQLField(
        "dashboardType"
    )
    description: "DashboardInfoGraphQLField" = DashboardInfoGraphQLField("description")
    entityId: "DashboardInfoGraphQLField" = DashboardInfoGraphQLField("entityId")

    @classmethod
    def powerBi(cls) -> "PowerBiInfoFields":
        return PowerBiInfoFields("powerBi")

    @classmethod
    def thoughtSpot(cls) -> "ThoughtSpotInfoFields":
        return ThoughtSpotInfoFields("thoughtSpot")

    title: "DashboardInfoGraphQLField" = DashboardInfoGraphQLField("title")
    viewCount: "DashboardInfoGraphQLField" = DashboardInfoGraphQLField("viewCount")

    def fields(
        self,
        *subfields: Union[
            DashboardInfoGraphQLField,
            "ChartFields",
            "PowerBiInfoFields",
            "ThoughtSpotInfoFields",
        ]
    ) -> "DashboardInfoFields":
        """Subfields should come from the DashboardInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardInfoFields":
        self._alias = alias
        return self


class DashboardLogicalIdFields(GraphQLField):
    dashboardId: "DashboardLogicalIdGraphQLField" = DashboardLogicalIdGraphQLField(
        "dashboardId"
    )
    platform: "DashboardLogicalIdGraphQLField" = DashboardLogicalIdGraphQLField(
        "platform"
    )

    def fields(
        self, *subfields: DashboardLogicalIdGraphQLField
    ) -> "DashboardLogicalIdFields":
        """Subfields should come from the DashboardLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardLogicalIdFields":
        self._alias = alias
        return self


class DashboardSearchDocumentFields(GraphQLField):
    browsePathHierarchy: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browsePathSegments: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    chartDescriptions: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("chartDescriptions")
    )
    charts: "DashboardSearchDocumentGraphQLField" = DashboardSearchDocumentGraphQLField(
        "charts"
    )
    contactDisplayNames: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("contactDisplayNames")
    )
    dashboardId: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("dashboardId")
    )
    dashboardType: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("dashboardType")
    )
    description: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("description")
    )
    documentId: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("documentId")
    )
    domainDisplayNames: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("domainDisplayNames")
    )
    domains: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("domains")
    )
    embeddedString_1: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("embeddedString_1")
    )
    embeddedString_2: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("embeddedString_2")
    )
    entityId: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("entityId")
    )
    governedTags: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("governedTags")
    )
    hasColumnLineage: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("hasColumnLineage")
    )
    hasTableLineage: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("hasTableLineage")
    )
    hashtags: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("hashtags")
    )

    @classmethod
    def highlight(cls) -> "DashboardHighlightFields":
        return DashboardHighlightFields("highlight")

    isComplete: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("isComplete")
    )
    isDeleted: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("isDeleted")
    )
    isProduction: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("isProduction")
    )
    knowledgeCardCount: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("knowledgeCardCount")
    )
    lastRefreshed: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("lastRefreshed")
    )
    model: "DashboardSearchDocumentGraphQLField" = DashboardSearchDocumentGraphQLField(
        "model"
    )
    name: "DashboardSearchDocumentGraphQLField" = DashboardSearchDocumentGraphQLField(
        "name"
    )
    overallDataQuality: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("overallDataQuality")
    )
    paginationToken: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("paginationToken")
    )
    platform: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("platform")
    )
    project: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("project")
    )

    @classmethod
    def scoreDetails(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("scoreDetails")

    thoughtSpotDashboardType: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("thoughtSpotDashboardType")
    )
    viewCount: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("viewCount")
    )
    workspace: "DashboardSearchDocumentGraphQLField" = (
        DashboardSearchDocumentGraphQLField("workspace")
    )

    def fields(
        self,
        *subfields: Union[
            DashboardSearchDocumentGraphQLField,
            "BrowsePathFields",
            "DashboardHighlightFields",
            "SearchScoreDetailsFields",
        ]
    ) -> "DashboardSearchDocumentFields":
        """Subfields should come from the DashboardSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardSearchDocumentFields":
        self._alias = alias
        return self


class DashboardSearchInfoFields(GraphQLField):
    chartDescriptions: "DashboardSearchInfoGraphQLField" = (
        DashboardSearchInfoGraphQLField("chartDescriptions")
    )
    charts: "DashboardSearchInfoGraphQLField" = DashboardSearchInfoGraphQLField(
        "charts"
    )
    dashboardId: "DashboardSearchInfoGraphQLField" = DashboardSearchInfoGraphQLField(
        "dashboardId"
    )

    def fields(
        self, *subfields: DashboardSearchInfoGraphQLField
    ) -> "DashboardSearchInfoFields":
        """Subfields should come from the DashboardSearchInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardSearchInfoFields":
        self._alias = alias
        return self


class DashboardSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "DashboardSearchDocumentFields":
        return DashboardSearchDocumentFields("documents")

    errorMessage: "DashboardSearchResultGraphQLField" = (
        DashboardSearchResultGraphQLField("errorMessage")
    )
    from_: "DashboardSearchResultGraphQLField" = DashboardSearchResultGraphQLField(
        "from"
    )
    hasMore: "DashboardSearchResultGraphQLField" = DashboardSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "DashboardSearchResultGraphQLField" = (
        DashboardSearchResultGraphQLField("paginationToken")
    )
    searchContext: "DashboardSearchResultGraphQLField" = (
        DashboardSearchResultGraphQLField("searchContext")
    )
    searchIndex: "DashboardSearchResultGraphQLField" = (
        DashboardSearchResultGraphQLField("searchIndex")
    )
    size: "DashboardSearchResultGraphQLField" = DashboardSearchResultGraphQLField(
        "size"
    )
    totalCount: "DashboardSearchResultGraphQLField" = DashboardSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            DashboardSearchResultGraphQLField,
            "AggregationMetadataFields",
            "DashboardSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "DashboardSearchResultFields":
        """Subfields should come from the DashboardSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DashboardSearchResultFields":
        self._alias = alias
        return self


class DataDocumentFields(GraphQLField):
    content: "DataDocumentGraphQLField" = DataDocumentGraphQLField("content")
    title: "DataDocumentGraphQLField" = DataDocumentGraphQLField("title")

    @classmethod
    def tokenizedContent(cls) -> "DataDocumentTokenizedContentFields":
        return DataDocumentTokenizedContentFields("tokenizedContent")

    def fields(
        self,
        *subfields: Union[
            DataDocumentGraphQLField, "DataDocumentTokenizedContentFields"
        ]
    ) -> "DataDocumentFields":
        """Subfields should come from the DataDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DataDocumentFields":
        self._alias = alias
        return self


class DataDocumentSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "KnowledgeCardSearchDocumentFields":
        return KnowledgeCardSearchDocumentFields("documents")

    errorMessage: "DataDocumentSearchResultGraphQLField" = (
        DataDocumentSearchResultGraphQLField("errorMessage")
    )
    from_: "DataDocumentSearchResultGraphQLField" = (
        DataDocumentSearchResultGraphQLField("from")
    )
    hasMore: "DataDocumentSearchResultGraphQLField" = (
        DataDocumentSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "DataDocumentSearchResultGraphQLField" = (
        DataDocumentSearchResultGraphQLField("paginationToken")
    )
    searchContext: "DataDocumentSearchResultGraphQLField" = (
        DataDocumentSearchResultGraphQLField("searchContext")
    )
    searchIndex: "DataDocumentSearchResultGraphQLField" = (
        DataDocumentSearchResultGraphQLField("searchIndex")
    )
    size: "DataDocumentSearchResultGraphQLField" = DataDocumentSearchResultGraphQLField(
        "size"
    )
    totalCount: "DataDocumentSearchResultGraphQLField" = (
        DataDocumentSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            DataDocumentSearchResultGraphQLField,
            "AggregationMetadataFields",
            "KnowledgeCardSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "DataDocumentSearchResultFields":
        """Subfields should come from the DataDocumentSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DataDocumentSearchResultFields":
        self._alias = alias
        return self


class DataDocumentTokenizedContentFields(GraphQLField):
    content: "DataDocumentTokenizedContentGraphQLField" = (
        DataDocumentTokenizedContentGraphQLField("content")
    )

    def fields(
        self, *subfields: DataDocumentTokenizedContentGraphQLField
    ) -> "DataDocumentTokenizedContentFields":
        """Subfields should come from the DataDocumentTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DataDocumentTokenizedContentFields":
        self._alias = alias
        return self


class DataGroupSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "NamespaceSearchDocumentFields":
        return NamespaceSearchDocumentFields("documents")

    errorMessage: "DataGroupSearchResultGraphQLField" = (
        DataGroupSearchResultGraphQLField("errorMessage")
    )
    from_: "DataGroupSearchResultGraphQLField" = DataGroupSearchResultGraphQLField(
        "from"
    )
    hasMore: "DataGroupSearchResultGraphQLField" = DataGroupSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "DataGroupSearchResultGraphQLField" = (
        DataGroupSearchResultGraphQLField("paginationToken")
    )
    searchContext: "DataGroupSearchResultGraphQLField" = (
        DataGroupSearchResultGraphQLField("searchContext")
    )
    searchIndex: "DataGroupSearchResultGraphQLField" = (
        DataGroupSearchResultGraphQLField("searchIndex")
    )
    size: "DataGroupSearchResultGraphQLField" = DataGroupSearchResultGraphQLField(
        "size"
    )
    totalCount: "DataGroupSearchResultGraphQLField" = DataGroupSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            DataGroupSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NamespaceSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "DataGroupSearchResultFields":
        """Subfields should come from the DataGroupSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DataGroupSearchResultFields":
        self._alias = alias
        return self


class DataMonitorFields(GraphQLField):
    description: "DataMonitorGraphQLField" = DataMonitorGraphQLField("description")
    exceptions: "DataMonitorGraphQLField" = DataMonitorGraphQLField("exceptions")
    lastRun: "DataMonitorGraphQLField" = DataMonitorGraphQLField("lastRun")
    owner: "DataMonitorGraphQLField" = DataMonitorGraphQLField("owner")
    severity: "DataMonitorGraphQLField" = DataMonitorGraphQLField("severity")
    status: "DataMonitorGraphQLField" = DataMonitorGraphQLField("status")

    @classmethod
    def targets(cls) -> "DataMonitorTargetFields":
        return DataMonitorTargetFields("targets")

    title: "DataMonitorGraphQLField" = DataMonitorGraphQLField("title")
    url: "DataMonitorGraphQLField" = DataMonitorGraphQLField("url")
    value: "DataMonitorGraphQLField" = DataMonitorGraphQLField("value")

    def fields(
        self, *subfields: Union[DataMonitorGraphQLField, "DataMonitorTargetFields"]
    ) -> "DataMonitorFields":
        """Subfields should come from the DataMonitorFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DataMonitorFields":
        self._alias = alias
        return self


class DataMonitorTargetFields(GraphQLField):
    column: "DataMonitorTargetGraphQLField" = DataMonitorTargetGraphQLField("column")
    dataset: "DataMonitorTargetGraphQLField" = DataMonitorTargetGraphQLField("dataset")

    def fields(
        self, *subfields: DataMonitorTargetGraphQLField
    ) -> "DataMonitorTargetFields":
        """Subfields should come from the DataMonitorTargetFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DataMonitorTargetFields":
        self._alias = alias
        return self


class DataQualityStatusSourceFields(GraphQLField):
    sourceEntity: "DataQualityStatusSourceGraphQLField" = (
        DataQualityStatusSourceGraphQLField("sourceEntity")
    )
    status: "DataQualityStatusSourceGraphQLField" = DataQualityStatusSourceGraphQLField(
        "status"
    )

    def fields(
        self, *subfields: DataQualityStatusSourceGraphQLField
    ) -> "DataQualityStatusSourceFields":
        """Subfields should come from the DataQualityStatusSourceFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DataQualityStatusSourceFields":
        self._alias = alias
        return self


class DatasetFields(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def assetContacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("assetContacts")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "DatasetGraphQLField" = DatasetGraphQLField("createdAt")

    @classmethod
    def customMetadata(cls) -> "CustomMetadataFields":
        return CustomMetadataFields("customMetadata")

    @classmethod
    def dataQuality(cls) -> "DatasetDataQualityFields":
        return DatasetDataQualityFields("dataQuality")

    deletedAt: "DatasetGraphQLField" = DatasetGraphQLField("deletedAt")

    @classmethod
    def descriptions(cls) -> "DerivedAssetDescriptionsFields":
        return DerivedAssetDescriptionsFields("descriptions")

    displayName: "DatasetGraphQLField" = DatasetGraphQLField("displayName")

    @classmethod
    def documentation(cls) -> "DatasetDocumentationFields":
        return DatasetDocumentationFields("documentation")

    @classmethod
    def downstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineageFor: Optional[LineageFilterInput] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineageFor},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstreamOfType", arguments=cleared_arguments
        )

    entityType: "DatasetGraphQLField" = DatasetGraphQLField("entityType")

    @classmethod
    def entityUpstream(cls) -> "EntityUpstreamFields":
        return EntityUpstreamFields("entityUpstream")

    @classmethod
    def fieldAssociations(cls) -> "DatasetFieldAssociationsFields":
        return DatasetFieldAssociationsFields("fieldAssociations")

    @classmethod
    def fieldStatistics(cls) -> "DatasetFieldStatisticsFields":
        return DatasetFieldStatisticsFields("fieldStatistics")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def forceShown(cls) -> "AuditStampFields":
        return AuditStampFields("forceShown")

    @classmethod
    def governedTags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governedTags", arguments=cleared_arguments
        )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "DatasetGraphQLField" = DatasetGraphQLField("id")

    @classmethod
    def interestedParties(cls) -> "InterestedPartyFields":
        return InterestedPartyFields("interestedParties")

    isComplete: "DatasetGraphQLField" = DatasetGraphQLField("isComplete")
    isDeleted: "DatasetGraphQLField" = DatasetGraphQLField("isDeleted")
    isProduction: "DatasetGraphQLField" = DatasetGraphQLField("isProduction")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledgeCards(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledgeCards", arguments=cleared_arguments
        )

    @classmethod
    def labels(cls) -> "AnchorEntityLabelFields":
        return AnchorEntityLabelFields("labels")

    lastIngestedAt: "DatasetGraphQLField" = DatasetGraphQLField("lastIngestedAt")
    lastModifiedAt: "DatasetGraphQLField" = DatasetGraphQLField("lastModifiedAt")

    @classmethod
    def lastQuery(cls) -> "DatasetLastQueryFields":
        return DatasetLastQueryFields("lastQuery")

    @classmethod
    def logicalId(cls) -> "DatasetLogicalIdFields":
        return DatasetLogicalIdFields("logicalId")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def overallDataQuality(cls) -> "OverallDataQualityFields":
        return OverallDataQualityFields("overallDataQuality")

    overallDataQualityStatus: "DatasetGraphQLField" = DatasetGraphQLField(
        "overallDataQualityStatus"
    )

    @classmethod
    def pipelineInfo(cls) -> "PipelineInfoFields":
        return PipelineInfoFields("pipelineInfo")

    @classmethod
    def queryCurators(cls) -> "PersonFields":
        return PersonFields("queryCurators")

    @classmethod
    def queryIssuers(
        cls,
        *,
        daysAgo: Optional[float] = None,
        hideServiceAccount: Optional[bool] = None
    ) -> "DatasetGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "daysAgo": {"type": "Float", "value": daysAgo},
            "hideServiceAccount": {"type": "Boolean", "value": hideServiceAccount},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DatasetGraphQLField("queryIssuers", arguments=cleared_arguments)

    @classmethod
    def queryLogs(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[QueryInfoConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "QueryInfoConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "QueryInfoConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return QueryInfoConnectionFields("queryLogs", arguments=cleared_arguments)

    @classmethod
    def recentQueries(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        daysAgo: Optional[float] = None,
        filters: Optional[QueryInfoConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "QueryInfoConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "daysAgo": {"type": "Float", "value": daysAgo},
            "filters": {"type": "QueryInfoConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return QueryInfoConnectionFields("recentQueries", arguments=cleared_arguments)

    @classmethod
    def recentUserActivities(
        cls, *, input: Optional[RecentUserActivitiesFilterInput] = None
    ) -> "RecentUserActivitiesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "RecentUserActivitiesFilterInput", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return RecentUserActivitiesFields(
            "recentUserActivities", arguments=cleared_arguments
        )

    @classmethod
    def recentlyViewedBy(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "ViewedByConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewedByConnectionFields("recentlyViewedBy", arguments=cleared_arguments)

    @classmethod
    def relatedAssetOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        relationFor: Optional[DatasetRelationInput] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "relationFor": {"type": "DatasetRelationInput", "value": relationFor},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "relatedAssetOfType", arguments=cleared_arguments
        )

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def schema(cls) -> "DatasetSchemaFields":
        return DatasetSchemaFields("schema")

    @classmethod
    def snowflakeStreamInfo(cls) -> "SnowflakeStreamInfoFields":
        return SnowflakeStreamInfoFields("snowflakeStreamInfo")

    @classmethod
    def sourceInfo(cls) -> "SourceInfoFields":
        return SourceInfoFields("sourceInfo")

    @classmethod
    def statistics(cls) -> "DatasetStatisticsFields":
        return DatasetStatisticsFields("statistics")

    @classmethod
    def structure(cls) -> "DatasetStructureFields":
        return DatasetStructureFields("structure")

    @classmethod
    def systemContacts(cls) -> "SystemContactsFields":
        return SystemContactsFields("systemContacts")

    @classmethod
    def systemDescription(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("systemDescription")

    systemTagValues: "DatasetGraphQLField" = DatasetGraphQLField("systemTagValues")

    @classmethod
    def systemTags(cls) -> "SystemTagsFields":
        return SystemTagsFields("systemTags")

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    @classmethod
    def topKnowledgeCardAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(
            "topKnowledgeCardAuthors", arguments=cleared_arguments
        )

    @classmethod
    def unityCatalog(cls) -> "UnityCatalogFields":
        return UnityCatalogFields("unityCatalog")

    @classmethod
    def upstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineageFor: Optional[LineageFilterInput] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineageFor},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstreamOfType", arguments=cleared_arguments
        )

    @classmethod
    def usage(cls) -> "DatasetUsageFields":
        return DatasetUsageFields("usage")

    viewerCanAssignAssetContacts: "DatasetGraphQLField" = DatasetGraphQLField(
        "viewerCanAssignAssetContacts"
    )
    viewerHasPinned: "DatasetGraphQLField" = DatasetGraphQLField("viewerHasPinned")

    def fields(
        self,
        *subfields: Union[
            DatasetGraphQLField,
            "AggregationMetadataFields",
            "AnchorEntityLabelFields",
            "AssetContactsFields",
            "AssetFollowersFields",
            "AuditStampFields",
            "BrowsePathFields",
            "CustomMetadataFields",
            "DatasetDataQualityFields",
            "DatasetDocumentationFields",
            "DatasetFieldAssociationsFields",
            "DatasetFieldStatisticsFields",
            "DatasetLastQueryFields",
            "DatasetLogicalIdFields",
            "DatasetSchemaFields",
            "DatasetStatisticsFields",
            "DatasetStructureFields",
            "DatasetUsageFields",
            "DerivedAssetDescriptionsFields",
            "EntityConnectionFields",
            "EntityLineageConnectionFields",
            "EntityUpstreamFields",
            "HashtagFields",
            "InterestedPartyFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "OverallDataQualityFields",
            "PersonConnectionFields",
            "PersonFields",
            "PipelineInfoFields",
            "QueryInfoConnectionFields",
            "RecentUserActivitiesFields",
            "SnowflakeStreamInfoFields",
            "SourceInfoFields",
            "SystemContactsFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
            "UnityCatalogFields",
            "UserDefinedResourceConnectionFields",
            "ViewedByConnectionFields",
        ]
    ) -> "DatasetFields":
        """Subfields should come from the DatasetFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetFields":
        self._alias = alias
        return self


class DatasetColumnsFields(GraphQLField):
    datasetId: "DatasetColumnsGraphQLField" = DatasetColumnsGraphQLField("datasetId")

    @classmethod
    def datasetLogicalId(cls) -> "DatasetLogicalIdFields":
        return DatasetLogicalIdFields("datasetLogicalId")

    fields: "DatasetColumnsGraphQLField" = DatasetColumnsGraphQLField("fields")

    def fields(
        self, *subfields: Union[DatasetColumnsGraphQLField, "DatasetLogicalIdFields"]
    ) -> "DatasetColumnsFields":
        """Subfields should come from the DatasetColumnsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetColumnsFields":
        self._alias = alias
        return self


class DatasetConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "DatasetEdgeFields":
        return DatasetEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "DatasetConnectionGraphQLField" = DatasetConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            DatasetConnectionGraphQLField, "DatasetEdgeFields", "PageInfoFields"
        ]
    ) -> "DatasetConnectionFields":
        """Subfields should come from the DatasetConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetConnectionFields":
        self._alias = alias
        return self


class DatasetDataQualityFields(GraphQLField):
    createdAt: "DatasetDataQualityGraphQLField" = DatasetDataQualityGraphQLField(
        "createdAt"
    )
    entityId: "DatasetDataQualityGraphQLField" = DatasetDataQualityGraphQLField(
        "entityId"
    )

    @classmethod
    def monitors(cls) -> "DataMonitorFields":
        return DataMonitorFields("monitors")

    provider: "DatasetDataQualityGraphQLField" = DatasetDataQualityGraphQLField(
        "provider"
    )
    url: "DatasetDataQualityGraphQLField" = DatasetDataQualityGraphQLField("url")

    def fields(
        self, *subfields: Union[DatasetDataQualityGraphQLField, "DataMonitorFields"]
    ) -> "DatasetDataQualityFields":
        """Subfields should come from the DatasetDataQualityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetDataQualityFields":
        self._alias = alias
        return self


class DatasetDocumentationFields(GraphQLField):
    createdAt: "DatasetDocumentationGraphQLField" = DatasetDocumentationGraphQLField(
        "createdAt"
    )
    datasetDocumentations: "DatasetDocumentationGraphQLField" = (
        DatasetDocumentationGraphQLField("datasetDocumentations")
    )
    entityId: "DatasetDocumentationGraphQLField" = DatasetDocumentationGraphQLField(
        "entityId"
    )

    @classmethod
    def fieldDocumentations(cls) -> "FieldDocumentationFields":
        return FieldDocumentationFields("fieldDocumentations")

    def fields(
        self,
        *subfields: Union[DatasetDocumentationGraphQLField, "FieldDocumentationFields"]
    ) -> "DatasetDocumentationFields":
        """Subfields should come from the DatasetDocumentationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetDocumentationFields":
        self._alias = alias
        return self


class DatasetEdgeFields(GraphQLField):
    cursor: "DatasetEdgeGraphQLField" = DatasetEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "DatasetFields":
        return DatasetFields("node")

    def fields(
        self, *subfields: Union[DatasetEdgeGraphQLField, "DatasetFields"]
    ) -> "DatasetEdgeFields":
        """Subfields should come from the DatasetEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetEdgeFields":
        self._alias = alias
        return self


class DatasetFieldAssociationsFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "DatasetFieldAssociationsGraphQLField" = (
        DatasetFieldAssociationsGraphQLField("createdAt")
    )
    entityId: "DatasetFieldAssociationsGraphQLField" = (
        DatasetFieldAssociationsGraphQLField("entityId")
    )

    @classmethod
    def governedTagFields(cls) -> "FieldTagAssociationsFields":
        return FieldTagAssociationsFields("governedTagFields")

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    def fields(
        self,
        *subfields: Union[
            DatasetFieldAssociationsGraphQLField,
            "AuditStampFields",
            "FieldTagAssociationsFields",
        ]
    ) -> "DatasetFieldAssociationsFields":
        """Subfields should come from the DatasetFieldAssociationsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetFieldAssociationsFields":
        self._alias = alias
        return self


class DatasetFieldStatisticsFields(GraphQLField):
    createdAt: "DatasetFieldStatisticsGraphQLField" = (
        DatasetFieldStatisticsGraphQLField("createdAt")
    )
    entityId: "DatasetFieldStatisticsGraphQLField" = DatasetFieldStatisticsGraphQLField(
        "entityId"
    )

    @classmethod
    def fieldStatistics(cls) -> "FieldStatisticsFields":
        return FieldStatisticsFields("fieldStatistics")

    def fields(
        self,
        *subfields: Union[DatasetFieldStatisticsGraphQLField, "FieldStatisticsFields"]
    ) -> "DatasetFieldStatisticsFields":
        """Subfields should come from the DatasetFieldStatisticsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetFieldStatisticsFields":
        self._alias = alias
        return self


class DatasetHighlightFields(GraphQLField):
    columnDescriptions: "DatasetHighlightGraphQLField" = DatasetHighlightGraphQLField(
        "columnDescriptions"
    )
    columnNames: "DatasetHighlightGraphQLField" = DatasetHighlightGraphQLField(
        "columnNames"
    )
    columnTags: "DatasetHighlightGraphQLField" = DatasetHighlightGraphQLField(
        "columnTags"
    )
    contactDisplayNames: "DatasetHighlightGraphQLField" = DatasetHighlightGraphQLField(
        "contactDisplayNames"
    )
    description: "DatasetHighlightGraphQLField" = DatasetHighlightGraphQLField(
        "description"
    )
    governedTags: "DatasetHighlightGraphQLField" = DatasetHighlightGraphQLField(
        "governedTags"
    )
    hashtags: "DatasetHighlightGraphQLField" = DatasetHighlightGraphQLField("hashtags")
    name: "DatasetHighlightGraphQLField" = DatasetHighlightGraphQLField("name")

    def fields(
        self, *subfields: DatasetHighlightGraphQLField
    ) -> "DatasetHighlightFields":
        """Subfields should come from the DatasetHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetHighlightFields":
        self._alias = alias
        return self


class DatasetLastQueryFields(GraphQLField):
    createdAt: "DatasetLastQueryGraphQLField" = DatasetLastQueryGraphQLField(
        "createdAt"
    )
    entityId: "DatasetLastQueryGraphQLField" = DatasetLastQueryGraphQLField("entityId")
    lastQueriedAt: "DatasetLastQueryGraphQLField" = DatasetLastQueryGraphQLField(
        "lastQueriedAt"
    )
    lastQueriedBy: "DatasetLastQueryGraphQLField" = DatasetLastQueryGraphQLField(
        "lastQueriedBy"
    )

    def fields(
        self, *subfields: DatasetLastQueryGraphQLField
    ) -> "DatasetLastQueryFields":
        """Subfields should come from the DatasetLastQueryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetLastQueryFields":
        self._alias = alias
        return self


class DatasetLogicalIdFields(GraphQLField):
    account: "DatasetLogicalIdGraphQLField" = DatasetLogicalIdGraphQLField("account")
    name: "DatasetLogicalIdGraphQLField" = DatasetLogicalIdGraphQLField("name")
    platform: "DatasetLogicalIdGraphQLField" = DatasetLogicalIdGraphQLField("platform")

    def fields(
        self, *subfields: DatasetLogicalIdGraphQLField
    ) -> "DatasetLogicalIdFields":
        """Subfields should come from the DatasetLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetLogicalIdFields":
        self._alias = alias
        return self


class DatasetPatternFields(GraphQLField):
    account: "DatasetPatternGraphQLField" = DatasetPatternGraphQLField("account")
    database: "DatasetPatternGraphQLField" = DatasetPatternGraphQLField("database")
    isCaseSensitive: "DatasetPatternGraphQLField" = DatasetPatternGraphQLField(
        "isCaseSensitive"
    )
    platform: "DatasetPatternGraphQLField" = DatasetPatternGraphQLField("platform")
    schema: "DatasetPatternGraphQLField" = DatasetPatternGraphQLField("schema")
    table: "DatasetPatternGraphQLField" = DatasetPatternGraphQLField("table")

    def fields(self, *subfields: DatasetPatternGraphQLField) -> "DatasetPatternFields":
        """Subfields should come from the DatasetPatternFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetPatternFields":
        self._alias = alias
        return self


class DatasetSchemaFields(GraphQLField):
    @classmethod
    def commonColumnAttributes(cls) -> "SchemaFieldWithCommonAttributesFields":
        return SchemaFieldWithCommonAttributesFields("commonColumnAttributes")

    createdAt: "DatasetSchemaGraphQLField" = DatasetSchemaGraphQLField("createdAt")

    @classmethod
    def dbtSchemaFields(cls) -> "SchemaFieldFields":
        return SchemaFieldFields("dbtSchemaFields")

    description: "DatasetSchemaGraphQLField" = DatasetSchemaGraphQLField("description")
    entityId: "DatasetSchemaGraphQLField" = DatasetSchemaGraphQLField("entityId")

    @classmethod
    def fields(cls) -> "SchemaFieldFields":
        return SchemaFieldFields("fields")

    @classmethod
    def flattenedSubfields(cls) -> "SchemaFieldFields":
        return SchemaFieldFields("flattenedSubfields")

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    rawSchema: "DatasetSchemaGraphQLField" = DatasetSchemaGraphQLField("rawSchema")

    @classmethod
    def schemaFieldCrowdSourcedDescriptions(
        cls, *, filters: Optional[KnowledgeCardConnectionFilterInput] = None
    ) -> "KnowledgeCardFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardFields(
            "schemaFieldCrowdSourcedDescriptions", arguments=cleared_arguments
        )

    schemaType: "DatasetSchemaGraphQLField" = DatasetSchemaGraphQLField("schemaType")

    @classmethod
    def sqlSchema(cls) -> "SqlSchemaFields":
        return SqlSchemaFields("sqlSchema")

    @classmethod
    def viewerCanAddSchemaFieldDescriptionFor(
        cls, *, fieldPaths: Optional[str] = None
    ) -> "FieldPathPermissionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "fieldPaths": {"type": "String", "value": fieldPaths}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FieldPathPermissionFields(
            "viewerCanAddSchemaFieldDescriptionFor", arguments=cleared_arguments
        )

    def fields(
        self,
        *subfields: Union[
            DatasetSchemaGraphQLField,
            "AuditStampFields",
            "FieldPathPermissionFields",
            "KnowledgeCardFields",
            "SchemaFieldFields",
            "SchemaFieldWithCommonAttributesFields",
            "SqlSchemaFields",
        ]
    ) -> "DatasetSchemaFields":
        """Subfields should come from the DatasetSchemaFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetSchemaFields":
        self._alias = alias
        return self


class DatasetSearchDocumentFields(GraphQLField):
    browsePathHierarchy: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browsePathSegments: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    columnDescriptions: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("columnDescriptions")
    )
    columnNames: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("columnNames")
    )
    columnTags: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "columnTags"
    )
    contactDisplayNames: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("contactDisplayNames")
    )
    created: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "created"
    )
    database: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "database"
    )
    dbtTags: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "dbtTags"
    )
    description: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("description")
    )
    documentId: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "documentId"
    )
    domainDisplayNames: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("domainDisplayNames")
    )
    domains: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "domains"
    )
    embeddedString_1: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("embeddedString_1")
    )
    embeddedString_2: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("embeddedString_2")
    )
    entityId: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "entityId"
    )
    fullName: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "fullName"
    )
    governedTags: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("governedTags")
    )
    hasColumnLineage: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("hasColumnLineage")
    )
    hasTableLineage: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("hasTableLineage")
    )
    hashtags: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "hashtags"
    )

    @classmethod
    def highlight(cls) -> "DatasetHighlightFields":
        return DatasetHighlightFields("highlight")

    isComplete: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "isComplete"
    )
    isDeleted: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "isDeleted"
    )
    isProduction: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("isProduction")
    )
    knowledgeCardCount: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("knowledgeCardCount")
    )
    lastQueried: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("lastQueried")
    )
    lastRefreshed: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("lastRefreshed")
    )
    lastUpdated: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("lastUpdated")
    )
    materializationType: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("materializationType")
    )
    name: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "name"
    )
    overallDataQuality: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("overallDataQuality")
    )
    paginationToken: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("paginationToken")
    )
    platform: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "platform"
    )

    @classmethod
    def queryCountPercentile(cls) -> "QueryCountPercentileFields":
        return QueryCountPercentileFields("queryCountPercentile")

    rowCount: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "rowCount"
    )
    schema: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "schema"
    )

    @classmethod
    def scoreDetails(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("scoreDetails")

    size: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "size"
    )
    snowflakeTags: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("snowflakeTags")
    )
    unityCatalogDatasetType: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("unityCatalogDatasetType")
    )
    unityCatalogTags: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("unityCatalogTags")
    )
    usageLevel: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "usageLevel"
    )
    usagePercentile: "DatasetSearchDocumentGraphQLField" = (
        DatasetSearchDocumentGraphQLField("usagePercentile")
    )
    viewCount: "DatasetSearchDocumentGraphQLField" = DatasetSearchDocumentGraphQLField(
        "viewCount"
    )

    def fields(
        self,
        *subfields: Union[
            DatasetSearchDocumentGraphQLField,
            "BrowsePathFields",
            "DatasetHighlightFields",
            "QueryCountPercentileFields",
            "SearchScoreDetailsFields",
        ]
    ) -> "DatasetSearchDocumentFields":
        """Subfields should come from the DatasetSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetSearchDocumentFields":
        self._alias = alias
        return self


class DatasetSearchInfoFields(GraphQLField):
    database: "DatasetSearchInfoGraphQLField" = DatasetSearchInfoGraphQLField(
        "database"
    )
    fullName: "DatasetSearchInfoGraphQLField" = DatasetSearchInfoGraphQLField(
        "fullName"
    )

    @classmethod
    def queryCountPercentile(cls) -> "QueryCountPercentileFields":
        return QueryCountPercentileFields("queryCountPercentile")

    rowCount: "DatasetSearchInfoGraphQLField" = DatasetSearchInfoGraphQLField(
        "rowCount"
    )
    schema: "DatasetSearchInfoGraphQLField" = DatasetSearchInfoGraphQLField("schema")
    size: "DatasetSearchInfoGraphQLField" = DatasetSearchInfoGraphQLField("size")
    usageLevel: "DatasetSearchInfoGraphQLField" = DatasetSearchInfoGraphQLField(
        "usageLevel"
    )
    usagePercentile: "DatasetSearchInfoGraphQLField" = DatasetSearchInfoGraphQLField(
        "usagePercentile"
    )

    def fields(
        self,
        *subfields: Union[DatasetSearchInfoGraphQLField, "QueryCountPercentileFields"]
    ) -> "DatasetSearchInfoFields":
        """Subfields should come from the DatasetSearchInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetSearchInfoFields":
        self._alias = alias
        return self


class DatasetSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "DatasetSearchDocumentFields":
        return DatasetSearchDocumentFields("documents")

    errorMessage: "DatasetSearchResultGraphQLField" = DatasetSearchResultGraphQLField(
        "errorMessage"
    )
    from_: "DatasetSearchResultGraphQLField" = DatasetSearchResultGraphQLField("from")
    hasMore: "DatasetSearchResultGraphQLField" = DatasetSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "DatasetSearchResultGraphQLField" = (
        DatasetSearchResultGraphQLField("paginationToken")
    )
    searchContext: "DatasetSearchResultGraphQLField" = DatasetSearchResultGraphQLField(
        "searchContext"
    )
    searchIndex: "DatasetSearchResultGraphQLField" = DatasetSearchResultGraphQLField(
        "searchIndex"
    )
    size: "DatasetSearchResultGraphQLField" = DatasetSearchResultGraphQLField("size")
    totalCount: "DatasetSearchResultGraphQLField" = DatasetSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            DatasetSearchResultGraphQLField,
            "AggregationMetadataFields",
            "DatasetSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "DatasetSearchResultFields":
        """Subfields should come from the DatasetSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetSearchResultFields":
        self._alias = alias
        return self


class DatasetStatisticsFields(GraphQLField):
    createdAt: "DatasetStatisticsGraphQLField" = DatasetStatisticsGraphQLField(
        "createdAt"
    )
    dataSizeBytes: "DatasetStatisticsGraphQLField" = DatasetStatisticsGraphQLField(
        "dataSizeBytes"
    )
    entityId: "DatasetStatisticsGraphQLField" = DatasetStatisticsGraphQLField(
        "entityId"
    )

    @classmethod
    def fieldStatistics(cls) -> "FieldStatisticsFields":
        return FieldStatisticsFields("fieldStatistics")

    recordCount: "DatasetStatisticsGraphQLField" = DatasetStatisticsGraphQLField(
        "recordCount"
    )

    def fields(
        self, *subfields: Union[DatasetStatisticsGraphQLField, "FieldStatisticsFields"]
    ) -> "DatasetStatisticsFields":
        """Subfields should come from the DatasetStatisticsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetStatisticsFields":
        self._alias = alias
        return self


class DatasetStructureFields(GraphQLField):
    createdAt: "DatasetStructureGraphQLField" = DatasetStructureGraphQLField(
        "createdAt"
    )
    database: "DatasetStructureGraphQLField" = DatasetStructureGraphQLField("database")
    entityId: "DatasetStructureGraphQLField" = DatasetStructureGraphQLField("entityId")
    schema: "DatasetStructureGraphQLField" = DatasetStructureGraphQLField("schema")
    table: "DatasetStructureGraphQLField" = DatasetStructureGraphQLField("table")

    def fields(
        self, *subfields: DatasetStructureGraphQLField
    ) -> "DatasetStructureFields":
        """Subfields should come from the DatasetStructureFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetStructureFields":
        self._alias = alias
        return self


class DatasetUsageFields(GraphQLField):
    createdAt: "DatasetUsageGraphQLField" = DatasetUsageGraphQLField("createdAt")
    entityId: "DatasetUsageGraphQLField" = DatasetUsageGraphQLField("entityId")

    @classmethod
    def fieldQueryCounts(cls) -> "FieldQueryCountsFields":
        return FieldQueryCountsFields("fieldQueryCounts")

    @classmethod
    def queryCounts(cls) -> "QueryCountsFields":
        return QueryCountsFields("queryCounts")

    @classmethod
    def tableJoins(cls) -> "TableJoinsFields":
        return TableJoinsFields("tableJoins")

    @classmethod
    def userQueryCounts(cls) -> "UserQueryCountsFields":
        return UserQueryCountsFields("userQueryCounts")

    def fields(
        self,
        *subfields: Union[
            DatasetUsageGraphQLField,
            "FieldQueryCountsFields",
            "QueryCountsFields",
            "TableJoinsFields",
            "UserQueryCountsFields",
        ]
    ) -> "DatasetUsageFields":
        """Subfields should come from the DatasetUsageFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetUsageFields":
        self._alias = alias
        return self


class DbtMacroFields(GraphQLField):
    @classmethod
    def arguments(cls) -> "DbtMacroArgumentFields":
        return DbtMacroArgumentFields("arguments")

    dependsOnMacros: "DbtMacroGraphQLField" = DbtMacroGraphQLField("dependsOnMacros")
    description: "DbtMacroGraphQLField" = DbtMacroGraphQLField("description")
    name: "DbtMacroGraphQLField" = DbtMacroGraphQLField("name")
    packageName: "DbtMacroGraphQLField" = DbtMacroGraphQLField("packageName")
    sql: "DbtMacroGraphQLField" = DbtMacroGraphQLField("sql")
    uniqueId: "DbtMacroGraphQLField" = DbtMacroGraphQLField("uniqueId")

    def fields(
        self, *subfields: Union[DbtMacroGraphQLField, "DbtMacroArgumentFields"]
    ) -> "DbtMacroFields":
        """Subfields should come from the DbtMacroFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtMacroFields":
        self._alias = alias
        return self


class DbtMacroArgumentFields(GraphQLField):
    description: "DbtMacroArgumentGraphQLField" = DbtMacroArgumentGraphQLField(
        "description"
    )
    name: "DbtMacroArgumentGraphQLField" = DbtMacroArgumentGraphQLField("name")
    type: "DbtMacroArgumentGraphQLField" = DbtMacroArgumentGraphQLField("type")

    def fields(
        self, *subfields: DbtMacroArgumentGraphQLField
    ) -> "DbtMacroArgumentFields":
        """Subfields should come from the DbtMacroArgumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtMacroArgumentFields":
        self._alias = alias
        return self


class DbtMaterializationFields(GraphQLField):
    targetDataset: "DbtMaterializationGraphQLField" = DbtMaterializationGraphQLField(
        "targetDataset"
    )
    type: "DbtMaterializationGraphQLField" = DbtMaterializationGraphQLField("type")

    def fields(
        self, *subfields: DbtMaterializationGraphQLField
    ) -> "DbtMaterializationFields":
        """Subfields should come from the DbtMaterializationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtMaterializationFields":
        self._alias = alias
        return self


class DbtMetadataItemFields(GraphQLField):
    key: "DbtMetadataItemGraphQLField" = DbtMetadataItemGraphQLField("key")
    value: "DbtMetadataItemGraphQLField" = DbtMetadataItemGraphQLField("value")

    def fields(
        self, *subfields: DbtMetadataItemGraphQLField
    ) -> "DbtMetadataItemFields":
        """Subfields should come from the DbtMetadataItemFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtMetadataItemFields":
        self._alias = alias
        return self


class DbtMetricFields(GraphQLField):
    createdAt: "DbtMetricGraphQLField" = DbtMetricGraphQLField("createdAt")
    description: "DbtMetricGraphQLField" = DbtMetricGraphQLField("description")
    dimensions: "DbtMetricGraphQLField" = DbtMetricGraphQLField("dimensions")
    entityId: "DbtMetricGraphQLField" = DbtMetricGraphQLField("entityId")

    @classmethod
    def filters(cls) -> "MetricFilterFields":
        return MetricFilterFields("filters")

    label: "DbtMetricGraphQLField" = DbtMetricGraphQLField("label")
    packageName: "DbtMetricGraphQLField" = DbtMetricGraphQLField("packageName")
    sql: "DbtMetricGraphQLField" = DbtMetricGraphQLField("sql")
    timeGrains: "DbtMetricGraphQLField" = DbtMetricGraphQLField("timeGrains")
    timestamp: "DbtMetricGraphQLField" = DbtMetricGraphQLField("timestamp")
    type: "DbtMetricGraphQLField" = DbtMetricGraphQLField("type")
    url: "DbtMetricGraphQLField" = DbtMetricGraphQLField("url")

    def fields(
        self, *subfields: Union[DbtMetricGraphQLField, "MetricFilterFields"]
    ) -> "DbtMetricFields":
        """Subfields should come from the DbtMetricFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtMetricFields":
        self._alias = alias
        return self


class DbtModelFields(GraphQLField):
    compiledSql: "DbtModelGraphQLField" = DbtModelGraphQLField("compiledSql")
    createdAt: "DbtModelGraphQLField" = DbtModelGraphQLField("createdAt")
    description: "DbtModelGraphQLField" = DbtModelGraphQLField("description")
    docsUrl: "DbtModelGraphQLField" = DbtModelGraphQLField("docsUrl")

    @classmethod
    def downstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineageFor: Optional[DbtDownstreamLineageInput] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "DbtDownstreamLineageInput", "value": lineageFor},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstreamOfType", arguments=cleared_arguments
        )

    entityId: "DbtModelGraphQLField" = DbtModelGraphQLField("entityId")

    @classmethod
    def fields(cls) -> "SchemaFieldFields":
        return SchemaFieldFields("fields")

    @classmethod
    def macros(cls) -> "DbtMacroFields":
        return DbtMacroFields("macros")

    @classmethod
    def materialization(cls) -> "DbtMaterializationFields":
        return DbtMaterializationFields("materialization")

    @classmethod
    def meta(cls) -> "DbtMetadataItemFields":
        return DbtMetadataItemFields("meta")

    @classmethod
    def owners(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("owners", arguments=cleared_arguments)

    packageName: "DbtModelGraphQLField" = DbtModelGraphQLField("packageName")
    rawSql: "DbtModelGraphQLField" = DbtModelGraphQLField("rawSql")

    @classmethod
    def relatedAssetOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        relationFor: Optional[DbtModelRelationInput] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "relationFor": {"type": "DbtModelRelationInput", "value": relationFor},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "relatedAssetOfType", arguments=cleared_arguments
        )

    @classmethod
    def tests(cls) -> "DbtTestFields":
        return DbtTestFields("tests")

    @classmethod
    def upstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineageFor: Optional[DbtUpstreamLineageInput] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "DbtUpstreamLineageInput", "value": lineageFor},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstreamOfType", arguments=cleared_arguments
        )

    url: "DbtModelGraphQLField" = DbtModelGraphQLField("url")

    def fields(
        self,
        *subfields: Union[
            DbtModelGraphQLField,
            "DbtMacroFields",
            "DbtMaterializationFields",
            "DbtMetadataItemFields",
            "DbtTestFields",
            "EntityLineageConnectionFields",
            "PersonConnectionFields",
            "SchemaFieldFields",
        ]
    ) -> "DbtModelFields":
        """Subfields should come from the DbtModelFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtModelFields":
        self._alias = alias
        return self


class DbtModelSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "VirtualViewSearchDocumentFields":
        return VirtualViewSearchDocumentFields("documents")

    errorMessage: "DbtModelSearchResultGraphQLField" = DbtModelSearchResultGraphQLField(
        "errorMessage"
    )
    from_: "DbtModelSearchResultGraphQLField" = DbtModelSearchResultGraphQLField("from")
    hasMore: "DbtModelSearchResultGraphQLField" = DbtModelSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "DbtModelSearchResultGraphQLField" = (
        DbtModelSearchResultGraphQLField("paginationToken")
    )
    searchContext: "DbtModelSearchResultGraphQLField" = (
        DbtModelSearchResultGraphQLField("searchContext")
    )
    searchIndex: "DbtModelSearchResultGraphQLField" = DbtModelSearchResultGraphQLField(
        "searchIndex"
    )
    size: "DbtModelSearchResultGraphQLField" = DbtModelSearchResultGraphQLField("size")
    totalCount: "DbtModelSearchResultGraphQLField" = DbtModelSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            DbtModelSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "VirtualViewSearchDocumentFields",
        ]
    ) -> "DbtModelSearchResultFields":
        """Subfields should come from the DbtModelSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtModelSearchResultFields":
        self._alias = alias
        return self


class DbtTestFields(GraphQLField):
    columns: "DbtTestGraphQLField" = DbtTestGraphQLField("columns")
    dependsOnMacros: "DbtTestGraphQLField" = DbtTestGraphQLField("dependsOnMacros")
    name: "DbtTestGraphQLField" = DbtTestGraphQLField("name")
    sql: "DbtTestGraphQLField" = DbtTestGraphQLField("sql")
    uniqueId: "DbtTestGraphQLField" = DbtTestGraphQLField("uniqueId")

    def fields(self, *subfields: DbtTestGraphQLField) -> "DbtTestFields":
        """Subfields should come from the DbtTestFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbtTestFields":
        self._alias = alias
        return self


class DeleteCrawlersResponseFields(GraphQLField):
    deletedIds: "DeleteCrawlersResponseGraphQLField" = (
        DeleteCrawlersResponseGraphQLField("deletedIds")
    )

    def fields(
        self, *subfields: DeleteCrawlersResponseGraphQLField
    ) -> "DeleteCrawlersResponseFields":
        """Subfields should come from the DeleteCrawlersResponseFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DeleteCrawlersResponseFields":
        self._alias = alias
        return self


class DeleteWebhookResponseFields(GraphQLField):
    deletedIds: "DeleteWebhookResponseGraphQLField" = DeleteWebhookResponseGraphQLField(
        "deletedIds"
    )

    def fields(
        self, *subfields: DeleteWebhookResponseGraphQLField
    ) -> "DeleteWebhookResponseFields":
        """Subfields should come from the DeleteWebhookResponseFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DeleteWebhookResponseFields":
        self._alias = alias
        return self


class DeprecationKnowledgeCardFields(GraphQLField):
    detail: "DeprecationKnowledgeCardGraphQLField" = (
        DeprecationKnowledgeCardGraphQLField("detail")
    )
    plannedDate: "DeprecationKnowledgeCardGraphQLField" = (
        DeprecationKnowledgeCardGraphQLField("plannedDate")
    )
    title: "DeprecationKnowledgeCardGraphQLField" = (
        DeprecationKnowledgeCardGraphQLField("title")
    )

    @classmethod
    def tokenizedContent(cls) -> "DeprecationTokenizedContentFields":
        return DeprecationTokenizedContentFields("tokenizedContent")

    def fields(
        self,
        *subfields: Union[
            DeprecationKnowledgeCardGraphQLField, "DeprecationTokenizedContentFields"
        ]
    ) -> "DeprecationKnowledgeCardFields":
        """Subfields should come from the DeprecationKnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DeprecationKnowledgeCardFields":
        self._alias = alias
        return self


class DeprecationTokenizedContentFields(GraphQLField):
    detail: "DeprecationTokenizedContentGraphQLField" = (
        DeprecationTokenizedContentGraphQLField("detail")
    )

    def fields(
        self, *subfields: DeprecationTokenizedContentGraphQLField
    ) -> "DeprecationTokenizedContentFields":
        """Subfields should come from the DeprecationTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DeprecationTokenizedContentFields":
        self._alias = alias
        return self


class DerivedAssetDescriptionsFields(GraphQLField):
    dbt: "DerivedAssetDescriptionsGraphQLField" = DerivedAssetDescriptionsGraphQLField(
        "dbt"
    )
    entityId: "DerivedAssetDescriptionsGraphQLField" = (
        DerivedAssetDescriptionsGraphQLField("entityId")
    )

    @classmethod
    def userGenerated(
        cls, *, filters: Optional[KnowledgeCardConnectionFilterInput] = None
    ) -> "KnowledgeCardFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardFields("userGenerated", arguments=cleared_arguments)

    viewerCanAdd: "DerivedAssetDescriptionsGraphQLField" = (
        DerivedAssetDescriptionsGraphQLField("viewerCanAdd")
    )

    def fields(
        self,
        *subfields: Union[DerivedAssetDescriptionsGraphQLField, "KnowledgeCardFields"]
    ) -> "DerivedAssetDescriptionsFields":
        """Subfields should come from the DerivedAssetDescriptionsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DerivedAssetDescriptionsFields":
        self._alias = alias
        return self


class DesignatedContactFields(GraphQLField):
    @classmethod
    def designation(cls) -> "UserDefinedResourceFields":
        return UserDefinedResourceFields("designation")

    @classmethod
    def group(cls) -> "GroupFields":
        return GroupFields("group")

    @classmethod
    def person(cls) -> "PersonFields":
        return PersonFields("person")

    value: "DesignatedContactGraphQLField" = DesignatedContactGraphQLField("value")
    valueType: "DesignatedContactGraphQLField" = DesignatedContactGraphQLField(
        "valueType"
    )

    def fields(
        self,
        *subfields: Union[
            DesignatedContactGraphQLField,
            "GroupFields",
            "PersonFields",
            "UserDefinedResourceFields",
        ]
    ) -> "DesignatedContactFields":
        """Subfields should come from the DesignatedContactFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DesignatedContactFields":
        self._alias = alias
        return self


class EntityInterface(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "EntityGraphQLField" = EntityGraphQLField("createdAt")
    deletedAt: "EntityGraphQLField" = EntityGraphQLField("deletedAt")
    displayName: "EntityGraphQLField" = EntityGraphQLField("displayName")
    entityType: "EntityGraphQLField" = EntityGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "EntityGraphQLField" = EntityGraphQLField("id")
    isDeleted: "EntityGraphQLField" = EntityGraphQLField("isDeleted")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    lastIngestedAt: "EntityGraphQLField" = EntityGraphQLField("lastIngestedAt")
    lastModifiedAt: "EntityGraphQLField" = EntityGraphQLField("lastModifiedAt")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            EntityGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "EntityInterface":
        """Subfields should come from the EntityInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EntityInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "EntityInterface":
        self._inline_fragments[type_name] = subfields
        return self


class EntityConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "EntityEdgeFields":
        return EntityEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "EntityConnectionGraphQLField" = EntityConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            EntityConnectionGraphQLField, "EntityEdgeFields", "PageInfoFields"
        ]
    ) -> "EntityConnectionFields":
        """Subfields should come from the EntityConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EntityConnectionFields":
        self._alias = alias
        return self


class EntityCountFields(GraphQLField):
    count: "EntityCountGraphQLField" = EntityCountGraphQLField("count")
    entityType: "EntityCountGraphQLField" = EntityCountGraphQLField("entityType")

    def fields(self, *subfields: EntityCountGraphQLField) -> "EntityCountFields":
        """Subfields should come from the EntityCountFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EntityCountFields":
        self._alias = alias
        return self


class EntityEdgeFields(GraphQLField):
    cursor: "EntityEdgeGraphQLField" = EntityEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "EntityInterface":
        return EntityInterface("node")

    def fields(
        self, *subfields: Union[EntityEdgeGraphQLField, "EntityInterface"]
    ) -> "EntityEdgeFields":
        """Subfields should come from the EntityEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EntityEdgeFields":
        self._alias = alias
        return self


class EntityLineageConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "EntityLineageEdgeFields":
        return EntityLineageEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "EntityLineageConnectionGraphQLField" = (
        EntityLineageConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            EntityLineageConnectionGraphQLField,
            "EntityLineageEdgeFields",
            "PageInfoFields",
        ]
    ) -> "EntityLineageConnectionFields":
        """Subfields should come from the EntityLineageConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EntityLineageConnectionFields":
        self._alias = alias
        return self


class EntityLineageEdgeFields(GraphQLField):
    createdAt: "EntityLineageEdgeGraphQLField" = EntityLineageEdgeGraphQLField(
        "createdAt"
    )
    cursor: "EntityLineageEdgeGraphQLField" = EntityLineageEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "EntityInterface":
        return EntityInterface("node")

    def fields(
        self, *subfields: Union[EntityLineageEdgeGraphQLField, "EntityInterface"]
    ) -> "EntityLineageEdgeFields":
        """Subfields should come from the EntityLineageEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EntityLineageEdgeFields":
        self._alias = alias
        return self


class EntityUpstreamFields(GraphQLField):
    createdAt: "EntityUpstreamGraphQLField" = EntityUpstreamGraphQLField("createdAt")
    entityId: "EntityUpstreamGraphQLField" = EntityUpstreamGraphQLField("entityId")
    executorUrl: "EntityUpstreamGraphQLField" = EntityUpstreamGraphQLField(
        "executorUrl"
    )

    @classmethod
    def fieldMappings(cls) -> "FieldMappingFields":
        return FieldMappingFields("fieldMappings")

    sourceCodeUrl: "EntityUpstreamGraphQLField" = EntityUpstreamGraphQLField(
        "sourceCodeUrl"
    )
    sourceEntities: "EntityUpstreamGraphQLField" = EntityUpstreamGraphQLField(
        "sourceEntities"
    )
    transformation: "EntityUpstreamGraphQLField" = EntityUpstreamGraphQLField(
        "transformation"
    )

    def fields(
        self, *subfields: Union[EntityUpstreamGraphQLField, "FieldMappingFields"]
    ) -> "EntityUpstreamFields":
        """Subfields should come from the EntityUpstreamFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EntityUpstreamFields":
        self._alias = alias
        return self


class FieldDocumentationFields(GraphQLField):
    documentation: "FieldDocumentationGraphQLField" = FieldDocumentationGraphQLField(
        "documentation"
    )
    fieldPath: "FieldDocumentationGraphQLField" = FieldDocumentationGraphQLField(
        "fieldPath"
    )
    tests: "FieldDocumentationGraphQLField" = FieldDocumentationGraphQLField("tests")

    def fields(
        self, *subfields: FieldDocumentationGraphQLField
    ) -> "FieldDocumentationFields":
        """Subfields should come from the FieldDocumentationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FieldDocumentationFields":
        self._alias = alias
        return self


class FieldMappingFields(GraphQLField):
    destination: "FieldMappingGraphQLField" = FieldMappingGraphQLField("destination")

    @classmethod
    def sources(cls) -> "SourceFieldFields":
        return SourceFieldFields("sources")

    transformation: "FieldMappingGraphQLField" = FieldMappingGraphQLField(
        "transformation"
    )

    def fields(
        self, *subfields: Union[FieldMappingGraphQLField, "SourceFieldFields"]
    ) -> "FieldMappingFields":
        """Subfields should come from the FieldMappingFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FieldMappingFields":
        self._alias = alias
        return self


class FieldPathPermissionFields(GraphQLField):
    fieldPath: "FieldPathPermissionGraphQLField" = FieldPathPermissionGraphQLField(
        "fieldPath"
    )
    viewerCanAdd: "FieldPathPermissionGraphQLField" = FieldPathPermissionGraphQLField(
        "viewerCanAdd"
    )

    def fields(
        self, *subfields: FieldPathPermissionGraphQLField
    ) -> "FieldPathPermissionFields":
        """Subfields should come from the FieldPathPermissionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FieldPathPermissionFields":
        self._alias = alias
        return self


class FieldQueryCountFields(GraphQLField):
    count: "FieldQueryCountGraphQLField" = FieldQueryCountGraphQLField("count")
    field: "FieldQueryCountGraphQLField" = FieldQueryCountGraphQLField("field")
    level: "FieldQueryCountGraphQLField" = FieldQueryCountGraphQLField("level")
    percentile: "FieldQueryCountGraphQLField" = FieldQueryCountGraphQLField(
        "percentile"
    )

    def fields(
        self, *subfields: FieldQueryCountGraphQLField
    ) -> "FieldQueryCountFields":
        """Subfields should come from the FieldQueryCountFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FieldQueryCountFields":
        self._alias = alias
        return self


class FieldQueryCountsFields(GraphQLField):
    @classmethod
    def last7Days(cls) -> "FieldQueryCountFields":
        return FieldQueryCountFields("last7Days")

    @classmethod
    def last24Hours(cls) -> "FieldQueryCountFields":
        return FieldQueryCountFields("last24Hours")

    @classmethod
    def last30Days(cls) -> "FieldQueryCountFields":
        return FieldQueryCountFields("last30Days")

    @classmethod
    def last90Days(cls) -> "FieldQueryCountFields":
        return FieldQueryCountFields("last90Days")

    @classmethod
    def last365Days(cls) -> "FieldQueryCountFields":
        return FieldQueryCountFields("last365Days")

    def fields(
        self, *subfields: Union[FieldQueryCountsGraphQLField, "FieldQueryCountFields"]
    ) -> "FieldQueryCountsFields":
        """Subfields should come from the FieldQueryCountsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FieldQueryCountsFields":
        self._alias = alias
        return self


class FieldStatisticsFields(GraphQLField):
    average: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField("average")
    distinctValueCount: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField(
        "distinctValueCount"
    )
    fieldPath: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField("fieldPath")
    maxValue: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField("maxValue")
    minValue: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField("minValue")
    nonnullValueCount: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField(
        "nonnullValueCount"
    )
    nullValueCount: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField(
        "nullValueCount"
    )
    stdDev: "FieldStatisticsGraphQLField" = FieldStatisticsGraphQLField("stdDev")

    def fields(
        self, *subfields: FieldStatisticsGraphQLField
    ) -> "FieldStatisticsFields":
        """Subfields should come from the FieldStatisticsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FieldStatisticsFields":
        self._alias = alias
        return self


class FieldTagAssociationsFields(GraphQLField):
    fieldPath: "FieldTagAssociationsGraphQLField" = FieldTagAssociationsGraphQLField(
        "fieldPath"
    )

    @classmethod
    def governedTags(cls) -> "UserDefinedResourceFields":
        return UserDefinedResourceFields("governedTags")

    def fields(
        self,
        *subfields: Union[FieldTagAssociationsGraphQLField, "UserDefinedResourceFields"]
    ) -> "FieldTagAssociationsFields":
        """Subfields should come from the FieldTagAssociationsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FieldTagAssociationsFields":
        self._alias = alias
        return self


class FiveTranConnectorStatusFields(GraphQLField):
    setupState: "FiveTranConnectorStatusGraphQLField" = (
        FiveTranConnectorStatusGraphQLField("setupState")
    )
    syncState: "FiveTranConnectorStatusGraphQLField" = (
        FiveTranConnectorStatusGraphQLField("syncState")
    )
    updateState: "FiveTranConnectorStatusGraphQLField" = (
        FiveTranConnectorStatusGraphQLField("updateState")
    )

    def fields(
        self, *subfields: FiveTranConnectorStatusGraphQLField
    ) -> "FiveTranConnectorStatusFields":
        """Subfields should come from the FiveTranConnectorStatusFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FiveTranConnectorStatusFields":
        self._alias = alias
        return self


class FivetranPipelineFields(GraphQLField):
    config: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField("config")
    connectorLogsUrl: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "connectorLogsUrl"
    )
    connectorName: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "connectorName"
    )
    connectorTypeId: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "connectorTypeId"
    )
    connectorTypeName: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "connectorTypeName"
    )
    connectorUrl: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "connectorUrl"
    )
    created: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField("created")
    creatorEmail: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "creatorEmail"
    )
    iconUrl: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField("iconUrl")
    lastSucceeded: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "lastSucceeded"
    )
    paused: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField("paused")
    schemaMetadata: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "schemaMetadata"
    )
    sources: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField("sources")

    @classmethod
    def status(cls) -> "FiveTranConnectorStatusFields":
        return FiveTranConnectorStatusFields("status")

    syncIntervalInMinute: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField(
        "syncIntervalInMinute"
    )
    targets: "FivetranPipelineGraphQLField" = FivetranPipelineGraphQLField("targets")

    def fields(
        self,
        *subfields: Union[FivetranPipelineGraphQLField, "FiveTranConnectorStatusFields"]
    ) -> "FivetranPipelineFields":
        """Subfields should come from the FivetranPipelineFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FivetranPipelineFields":
        self._alias = alias
        return self


class FollowOrUnfollowOutputFields(GraphQLField):
    @classmethod
    def followedOrUnfollowed(cls) -> "EntityInterface":
        return EntityInterface("followedOrUnfollowed")

    @classmethod
    def follower(cls) -> "PersonFields":
        return PersonFields("follower")

    def fields(
        self,
        *subfields: Union[
            FollowOrUnfollowOutputGraphQLField, "EntityInterface", "PersonFields"
        ]
    ) -> "FollowOrUnfollowOutputFields":
        """Subfields should come from the FollowOrUnfollowOutputFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FollowOrUnfollowOutputFields":
        self._alias = alias
        return self


class ForeignKeyFields(GraphQLField):
    fieldPath: "ForeignKeyGraphQLField" = ForeignKeyGraphQLField("fieldPath")

    @classmethod
    def parent(cls) -> "DatasetLogicalIdFields":
        return DatasetLogicalIdFields("parent")

    parentField: "ForeignKeyGraphQLField" = ForeignKeyGraphQLField("parentField")

    def fields(
        self, *subfields: Union[ForeignKeyGraphQLField, "DatasetLogicalIdFields"]
    ) -> "ForeignKeyFields":
        """Subfields should come from the ForeignKeyFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ForeignKeyFields":
        self._alias = alias
        return self


class GeneratedAssetDescriptionFields(GraphQLField):
    description: "GeneratedAssetDescriptionGraphQLField" = (
        GeneratedAssetDescriptionGraphQLField("description")
    )
    entityId: "GeneratedAssetDescriptionGraphQLField" = (
        GeneratedAssetDescriptionGraphQLField("entityId")
    )

    @classmethod
    def fieldDescriptions(cls) -> "GeneratedFieldDescriptionFields":
        return GeneratedFieldDescriptionFields("fieldDescriptions")

    table: "GeneratedAssetDescriptionGraphQLField" = (
        GeneratedAssetDescriptionGraphQLField("table")
    )

    def fields(
        self,
        *subfields: Union[
            GeneratedAssetDescriptionGraphQLField, "GeneratedFieldDescriptionFields"
        ]
    ) -> "GeneratedAssetDescriptionFields":
        """Subfields should come from the GeneratedAssetDescriptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GeneratedAssetDescriptionFields":
        self._alias = alias
        return self


class GeneratedFieldDescriptionFields(GraphQLField):
    fieldDescription: "GeneratedFieldDescriptionGraphQLField" = (
        GeneratedFieldDescriptionGraphQLField("fieldDescription")
    )
    fieldPath: "GeneratedFieldDescriptionGraphQLField" = (
        GeneratedFieldDescriptionGraphQLField("fieldPath")
    )

    def fields(
        self, *subfields: GeneratedFieldDescriptionGraphQLField
    ) -> "GeneratedFieldDescriptionFields":
        """Subfields should come from the GeneratedFieldDescriptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GeneratedFieldDescriptionFields":
        self._alias = alias
        return self


class GoogleSocialLoginFields(GraphQLField):
    allowedEmailPatterns: "GoogleSocialLoginGraphQLField" = (
        GoogleSocialLoginGraphQLField("allowedEmailPatterns")
    )

    def fields(
        self, *subfields: GoogleSocialLoginGraphQLField
    ) -> "GoogleSocialLoginFields":
        """Subfields should come from the GoogleSocialLoginFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GoogleSocialLoginFields":
        self._alias = alias
        return self


class GoogleWorkspaceSSOFields(GraphQLField):
    metadataFile: "GoogleWorkspaceSSOGraphQLField" = GoogleWorkspaceSSOGraphQLField(
        "metadataFile"
    )

    def fields(
        self, *subfields: GoogleWorkspaceSSOGraphQLField
    ) -> "GoogleWorkspaceSSOFields":
        """Subfields should come from the GoogleWorkspaceSSOFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GoogleWorkspaceSSOFields":
        self._alias = alias
        return self


class GovernedEntityInterface(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField("createdAt")
    deletedAt: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField("deletedAt")
    displayName: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField(
        "displayName"
    )
    entityType: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField("id")
    isDeleted: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField("isDeleted")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    lastIngestedAt: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField(
        "lastIngestedAt"
    )
    lastModifiedAt: "GovernedEntityGraphQLField" = GovernedEntityGraphQLField(
        "lastModifiedAt"
    )

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            GovernedEntityGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "GovernedEntityInterface":
        """Subfields should come from the GovernedEntityInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GovernedEntityInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "GovernedEntityInterface":
        self._inline_fragments[type_name] = subfields
        return self


class GroupFields(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "GroupGraphQLField" = GroupGraphQLField("createdAt")
    deletedAt: "GroupGraphQLField" = GroupGraphQLField("deletedAt")
    displayName: "GroupGraphQLField" = GroupGraphQLField("displayName")
    entityType: "GroupGraphQLField" = GroupGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def groupInfo(cls) -> "GroupInfoFields":
        return GroupInfoFields("groupInfo")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "GroupGraphQLField" = GroupGraphQLField("id")
    isDeleted: "GroupGraphQLField" = GroupGraphQLField("isDeleted")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    lastIngestedAt: "GroupGraphQLField" = GroupGraphQLField("lastIngestedAt")
    lastModifiedAt: "GroupGraphQLField" = GroupGraphQLField("lastModifiedAt")

    @classmethod
    def logicalId(cls) -> "GroupLogicalIdFields":
        return GroupLogicalIdFields("logicalId")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            GroupGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "EntityConnectionFields",
            "GroupInfoFields",
            "GroupLogicalIdFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "GroupFields":
        """Subfields should come from the GroupFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupFields":
        self._alias = alias
        return self


class GroupBaseInterface(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "GroupBaseGraphQLField" = GroupBaseGraphQLField("createdAt")
    deletedAt: "GroupBaseGraphQLField" = GroupBaseGraphQLField("deletedAt")
    displayName: "GroupBaseGraphQLField" = GroupBaseGraphQLField("displayName")
    entityType: "GroupBaseGraphQLField" = GroupBaseGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "GroupBaseGraphQLField" = GroupBaseGraphQLField("id")
    isDeleted: "GroupBaseGraphQLField" = GroupBaseGraphQLField("isDeleted")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    lastIngestedAt: "GroupBaseGraphQLField" = GroupBaseGraphQLField("lastIngestedAt")
    lastModifiedAt: "GroupBaseGraphQLField" = GroupBaseGraphQLField("lastModifiedAt")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            GroupBaseGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "GroupBaseInterface":
        """Subfields should come from the GroupBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupBaseInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "GroupBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class GroupConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "GroupEdgeFields":
        return GroupEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "GroupConnectionGraphQLField" = GroupConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            GroupConnectionGraphQLField, "GroupEdgeFields", "PageInfoFields"
        ]
    ) -> "GroupConnectionFields":
        """Subfields should come from the GroupConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupConnectionFields":
        self._alias = alias
        return self


class GroupDescriptionFields(GraphQLField):
    text: "GroupDescriptionGraphQLField" = GroupDescriptionGraphQLField("text")
    tokenizedText: "GroupDescriptionGraphQLField" = GroupDescriptionGraphQLField(
        "tokenizedText"
    )

    def fields(
        self, *subfields: GroupDescriptionGraphQLField
    ) -> "GroupDescriptionFields":
        """Subfields should come from the GroupDescriptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupDescriptionFields":
        self._alias = alias
        return self


class GroupEdgeFields(GraphQLField):
    cursor: "GroupEdgeGraphQLField" = GroupEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "GroupFields":
        return GroupFields("node")

    def fields(
        self, *subfields: Union[GroupEdgeGraphQLField, "GroupFields"]
    ) -> "GroupEdgeFields":
        """Subfields should come from the GroupEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupEdgeFields":
        self._alias = alias
        return self


class GroupHighlightFields(GraphQLField):
    contactDisplayNames: "GroupHighlightGraphQLField" = GroupHighlightGraphQLField(
        "contactDisplayNames"
    )
    governedTags: "GroupHighlightGraphQLField" = GroupHighlightGraphQLField(
        "governedTags"
    )
    hashtags: "GroupHighlightGraphQLField" = GroupHighlightGraphQLField("hashtags")
    name: "GroupHighlightGraphQLField" = GroupHighlightGraphQLField("name")

    def fields(self, *subfields: GroupHighlightGraphQLField) -> "GroupHighlightFields":
        """Subfields should come from the GroupHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupHighlightFields":
        self._alias = alias
        return self


class GroupInfoFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "GroupInfoGraphQLField" = GroupInfoGraphQLField("createdAt")

    @classmethod
    def description(cls) -> "GroupDescriptionFields":
        return GroupDescriptionFields("description")

    email: "GroupInfoGraphQLField" = GroupInfoGraphQLField("email")
    entityId: "GroupInfoGraphQLField" = GroupInfoGraphQLField("entityId")
    externalId: "GroupInfoGraphQLField" = GroupInfoGraphQLField("externalId")

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    managedBy: "GroupInfoGraphQLField" = GroupInfoGraphQLField("managedBy")
    members: "GroupInfoGraphQLField" = GroupInfoGraphQLField("members")

    @classmethod
    def membersConnection(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[PersonConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "PersonConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("membersConnection", arguments=cleared_arguments)

    name: "GroupInfoGraphQLField" = GroupInfoGraphQLField("name")
    subgroups: "GroupInfoGraphQLField" = GroupInfoGraphQLField("subgroups")

    def fields(
        self,
        *subfields: Union[
            GroupInfoGraphQLField,
            "AuditStampFields",
            "GroupDescriptionFields",
            "PersonConnectionFields",
        ]
    ) -> "GroupInfoFields":
        """Subfields should come from the GroupInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupInfoFields":
        self._alias = alias
        return self


class GroupInfoBaseInterface(GraphQLField):
    createdAt: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("createdAt")

    @classmethod
    def description(cls) -> "GroupDescriptionFields":
        return GroupDescriptionFields("description")

    email: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("email")
    entityId: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("entityId")
    externalId: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("externalId")
    managedBy: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("managedBy")
    members: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("members")
    name: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("name")
    subgroups: "GroupInfoBaseGraphQLField" = GroupInfoBaseGraphQLField("subgroups")

    def fields(
        self, *subfields: Union[GroupInfoBaseGraphQLField, "GroupDescriptionFields"]
    ) -> "GroupInfoBaseInterface":
        """Subfields should come from the GroupInfoBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupInfoBaseInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "GroupInfoBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class GroupLogicalIdFields(GraphQLField):
    id: "GroupLogicalIdGraphQLField" = GroupLogicalIdGraphQLField("id")

    def fields(self, *subfields: GroupLogicalIdGraphQLField) -> "GroupLogicalIdFields":
        """Subfields should come from the GroupLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupLogicalIdFields":
        self._alias = alias
        return self


class GroupSearchDocumentFields(GraphQLField):
    browsePathHierarchy: "GroupSearchDocumentGraphQLField" = (
        GroupSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browsePathSegments: "GroupSearchDocumentGraphQLField" = (
        GroupSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    contactDisplayNames: "GroupSearchDocumentGraphQLField" = (
        GroupSearchDocumentGraphQLField("contactDisplayNames")
    )
    documentId: "GroupSearchDocumentGraphQLField" = GroupSearchDocumentGraphQLField(
        "documentId"
    )
    emails: "GroupSearchDocumentGraphQLField" = GroupSearchDocumentGraphQLField(
        "emails"
    )
    embeddedString_1: "GroupSearchDocumentGraphQLField" = (
        GroupSearchDocumentGraphQLField("embeddedString_1")
    )
    embeddedString_2: "GroupSearchDocumentGraphQLField" = (
        GroupSearchDocumentGraphQLField("embeddedString_2")
    )
    entityId: "GroupSearchDocumentGraphQLField" = GroupSearchDocumentGraphQLField(
        "entityId"
    )
    governedTags: "GroupSearchDocumentGraphQLField" = GroupSearchDocumentGraphQLField(
        "governedTags"
    )
    hashtags: "GroupSearchDocumentGraphQLField" = GroupSearchDocumentGraphQLField(
        "hashtags"
    )

    @classmethod
    def highlight(cls) -> "GroupHighlightFields":
        return GroupHighlightFields("highlight")

    isDeleted: "GroupSearchDocumentGraphQLField" = GroupSearchDocumentGraphQLField(
        "isDeleted"
    )
    lastRefreshed: "GroupSearchDocumentGraphQLField" = GroupSearchDocumentGraphQLField(
        "lastRefreshed"
    )
    members: "GroupSearchDocumentGraphQLField" = GroupSearchDocumentGraphQLField(
        "members"
    )
    name: "GroupSearchDocumentGraphQLField" = GroupSearchDocumentGraphQLField("name")
    paginationToken: "GroupSearchDocumentGraphQLField" = (
        GroupSearchDocumentGraphQLField("paginationToken")
    )

    @classmethod
    def scoreDetails(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("scoreDetails")

    viewCount: "GroupSearchDocumentGraphQLField" = GroupSearchDocumentGraphQLField(
        "viewCount"
    )

    def fields(
        self,
        *subfields: Union[
            GroupSearchDocumentGraphQLField,
            "BrowsePathFields",
            "GroupHighlightFields",
            "SearchScoreDetailsFields",
        ]
    ) -> "GroupSearchDocumentFields":
        """Subfields should come from the GroupSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupSearchDocumentFields":
        self._alias = alias
        return self


class GroupSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "GroupSearchDocumentFields":
        return GroupSearchDocumentFields("documents")

    errorMessage: "GroupSearchResultGraphQLField" = GroupSearchResultGraphQLField(
        "errorMessage"
    )
    from_: "GroupSearchResultGraphQLField" = GroupSearchResultGraphQLField("from")
    hasMore: "GroupSearchResultGraphQLField" = GroupSearchResultGraphQLField("hasMore")

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "GroupSearchResultGraphQLField" = GroupSearchResultGraphQLField(
        "paginationToken"
    )
    searchContext: "GroupSearchResultGraphQLField" = GroupSearchResultGraphQLField(
        "searchContext"
    )
    searchIndex: "GroupSearchResultGraphQLField" = GroupSearchResultGraphQLField(
        "searchIndex"
    )
    size: "GroupSearchResultGraphQLField" = GroupSearchResultGraphQLField("size")
    totalCount: "GroupSearchResultGraphQLField" = GroupSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            GroupSearchResultGraphQLField,
            "AggregationMetadataFields",
            "GroupSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "GroupSearchResultFields":
        """Subfields should come from the GroupSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GroupSearchResultFields":
        self._alias = alias
        return self


class HardDeletionFields(GraphQLField):
    enabled: "HardDeletionGraphQLField" = HardDeletionGraphQLField("enabled")
    thresholdHours: "HardDeletionGraphQLField" = HardDeletionGraphQLField(
        "thresholdHours"
    )

    def fields(self, *subfields: HardDeletionGraphQLField) -> "HardDeletionFields":
        """Subfields should come from the HardDeletionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "HardDeletionFields":
        self._alias = alias
        return self


class HashtagFields(GraphQLField):
    value: "HashtagGraphQLField" = HashtagGraphQLField("value")

    def fields(self, *subfields: HashtagGraphQLField) -> "HashtagFields":
        """Subfields should come from the HashtagFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "HashtagFields":
        self._alias = alias
        return self


class HierarchyFields(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def assetContacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("assetContacts")

    @classmethod
    def assetCountByType(cls) -> "AssetDocumentAggregationBucketFields":
        return AssetDocumentAggregationBucketFields("assetCountByType")

    @classmethod
    def assets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetsConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "AssetConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetsConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return AssetConnectionFields("assets", arguments=cleared_arguments)

    associatedEntityType: "HierarchyGraphQLField" = HierarchyGraphQLField(
        "associatedEntityType"
    )
    associatedSearchIndex: "HierarchyGraphQLField" = HierarchyGraphQLField(
        "associatedSearchIndex"
    )

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    @classmethod
    def children(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "HierarchyConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return HierarchyConnectionFields("children", arguments=cleared_arguments)

    createdAt: "HierarchyGraphQLField" = HierarchyGraphQLField("createdAt")
    deletedAt: "HierarchyGraphQLField" = HierarchyGraphQLField("deletedAt")

    @classmethod
    def descriptions(cls) -> "DerivedAssetDescriptionsFields":
        return DerivedAssetDescriptionsFields("descriptions")

    displayName: "HierarchyGraphQLField" = HierarchyGraphQLField("displayName")
    entityType: "HierarchyGraphQLField" = HierarchyGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def forceShown(cls) -> "AuditStampFields":
        return AuditStampFields("forceShown")

    @classmethod
    def governedTags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governedTags", arguments=cleared_arguments
        )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    @classmethod
    def hierarchyInfo(cls) -> "HierarchyInfoFields":
        return HierarchyInfoFields("hierarchyInfo")

    id: "HierarchyGraphQLField" = HierarchyGraphQLField("id")

    @classmethod
    def interestedParties(cls) -> "InterestedPartyFields":
        return InterestedPartyFields("interestedParties")

    isComplete: "HierarchyGraphQLField" = HierarchyGraphQLField("isComplete")
    isDeleted: "HierarchyGraphQLField" = HierarchyGraphQLField("isDeleted")
    isHidden: "HierarchyGraphQLField" = HierarchyGraphQLField("isHidden")
    isProduction: "HierarchyGraphQLField" = HierarchyGraphQLField("isProduction")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledgeCards(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledgeCards", arguments=cleared_arguments
        )

    @classmethod
    def labels(cls) -> "AnchorEntityLabelFields":
        return AnchorEntityLabelFields("labels")

    lastIngestedAt: "HierarchyGraphQLField" = HierarchyGraphQLField("lastIngestedAt")
    lastModifiedAt: "HierarchyGraphQLField" = HierarchyGraphQLField("lastModifiedAt")

    @classmethod
    def logicalId(cls) -> "HierarchyLogicalIdFields":
        return HierarchyLogicalIdFields("logicalId")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def recentUserActivities(
        cls, *, input: Optional[RecentUserActivitiesFilterInput] = None
    ) -> "RecentUserActivitiesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "RecentUserActivitiesFilterInput", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return RecentUserActivitiesFields(
            "recentUserActivities", arguments=cleared_arguments
        )

    @classmethod
    def recentlyViewedBy(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "ViewedByConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewedByConnectionFields("recentlyViewedBy", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def sourceInfo(cls) -> "SourceInfoFields":
        return SourceInfoFields("sourceInfo")

    @classmethod
    def systemContacts(cls) -> "SystemContactsFields":
        return SystemContactsFields("systemContacts")

    @classmethod
    def systemDescription(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("systemDescription")

    systemTagValues: "HierarchyGraphQLField" = HierarchyGraphQLField("systemTagValues")

    @classmethod
    def systemTags(cls) -> "SystemTagsFields":
        return SystemTagsFields("systemTags")

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    @classmethod
    def topKnowledgeCardAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(
            "topKnowledgeCardAuthors", arguments=cleared_arguments
        )

    viewerCanAssignAssetContacts: "HierarchyGraphQLField" = HierarchyGraphQLField(
        "viewerCanAssignAssetContacts"
    )
    viewerHasPinned: "HierarchyGraphQLField" = HierarchyGraphQLField("viewerHasPinned")

    def fields(
        self,
        *subfields: Union[
            HierarchyGraphQLField,
            "AggregationMetadataFields",
            "AnchorEntityLabelFields",
            "AssetConnectionFields",
            "AssetContactsFields",
            "AssetDocumentAggregationBucketFields",
            "AssetFollowersFields",
            "AuditStampFields",
            "BrowsePathFields",
            "DerivedAssetDescriptionsFields",
            "EntityConnectionFields",
            "HashtagFields",
            "HierarchyConnectionFields",
            "HierarchyInfoFields",
            "HierarchyLogicalIdFields",
            "InterestedPartyFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "RecentUserActivitiesFields",
            "SourceInfoFields",
            "SystemContactsFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
            "UserDefinedResourceConnectionFields",
            "ViewedByConnectionFields",
        ]
    ) -> "HierarchyFields":
        """Subfields should come from the HierarchyFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "HierarchyFields":
        self._alias = alias
        return self


class HierarchyConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "HierarchyEdgeFields":
        return HierarchyEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "HierarchyConnectionGraphQLField" = HierarchyConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            HierarchyConnectionGraphQLField, "HierarchyEdgeFields", "PageInfoFields"
        ]
    ) -> "HierarchyConnectionFields":
        """Subfields should come from the HierarchyConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "HierarchyConnectionFields":
        self._alias = alias
        return self


class HierarchyEdgeFields(GraphQLField):
    cursor: "HierarchyEdgeGraphQLField" = HierarchyEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "HierarchyFields":
        return HierarchyFields("node")

    def fields(
        self, *subfields: Union[HierarchyEdgeGraphQLField, "HierarchyFields"]
    ) -> "HierarchyEdgeFields":
        """Subfields should come from the HierarchyEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "HierarchyEdgeFields":
        self._alias = alias
        return self


class HierarchyInfoFields(GraphQLField):
    createdAt: "HierarchyInfoGraphQLField" = HierarchyInfoGraphQLField("createdAt")
    description: "HierarchyInfoGraphQLField" = HierarchyInfoGraphQLField("description")
    entityId: "HierarchyInfoGraphQLField" = HierarchyInfoGraphQLField("entityId")

    @classmethod
    def metabaseCollection(cls) -> "MetabaseCollectionFields":
        return MetabaseCollectionFields("metabaseCollection")

    name: "HierarchyInfoGraphQLField" = HierarchyInfoGraphQLField("name")

    @classmethod
    def powerBiWorkspace(cls) -> "PowerBiWorkspaceFields":
        return PowerBiWorkspaceFields("powerBiWorkspace")

    type: "HierarchyInfoGraphQLField" = HierarchyInfoGraphQLField("type")

    def fields(
        self,
        *subfields: Union[
            HierarchyInfoGraphQLField,
            "MetabaseCollectionFields",
            "PowerBiWorkspaceFields",
        ]
    ) -> "HierarchyInfoFields":
        """Subfields should come from the HierarchyInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "HierarchyInfoFields":
        self._alias = alias
        return self


class HierarchyLogicalIdFields(GraphQLField):
    path: "HierarchyLogicalIdGraphQLField" = HierarchyLogicalIdGraphQLField("path")

    def fields(
        self, *subfields: HierarchyLogicalIdGraphQLField
    ) -> "HierarchyLogicalIdFields":
        """Subfields should come from the HierarchyLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "HierarchyLogicalIdFields":
        self._alias = alias
        return self


class HowToUseTokenizedContentFields(GraphQLField):
    detail: "HowToUseTokenizedContentGraphQLField" = (
        HowToUseTokenizedContentGraphQLField("detail")
    )

    def fields(
        self, *subfields: HowToUseTokenizedContentGraphQLField
    ) -> "HowToUseTokenizedContentFields":
        """Subfields should come from the HowToUseTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "HowToUseTokenizedContentFields":
        self._alias = alias
        return self


class IncidentKnowledgeCardFields(GraphQLField):
    detail: "IncidentKnowledgeCardGraphQLField" = IncidentKnowledgeCardGraphQLField(
        "detail"
    )
    title: "IncidentKnowledgeCardGraphQLField" = IncidentKnowledgeCardGraphQLField(
        "title"
    )

    @classmethod
    def tokenizedContent(cls) -> "IncidentTokenizedContentFields":
        return IncidentTokenizedContentFields("tokenizedContent")

    def fields(
        self,
        *subfields: Union[
            IncidentKnowledgeCardGraphQLField, "IncidentTokenizedContentFields"
        ]
    ) -> "IncidentKnowledgeCardFields":
        """Subfields should come from the IncidentKnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "IncidentKnowledgeCardFields":
        self._alias = alias
        return self


class IncidentTokenizedContentFields(GraphQLField):
    detail: "IncidentTokenizedContentGraphQLField" = (
        IncidentTokenizedContentGraphQLField("detail")
    )

    def fields(
        self, *subfields: IncidentTokenizedContentGraphQLField
    ) -> "IncidentTokenizedContentFields":
        """Subfields should come from the IncidentTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "IncidentTokenizedContentFields":
        self._alias = alias
        return self


class InformaticaMappingFields(GraphQLField):
    description: "InformaticaMappingGraphQLField" = InformaticaMappingGraphQLField(
        "description"
    )
    name: "InformaticaMappingGraphQLField" = InformaticaMappingGraphQLField("name")

    def fields(
        self, *subfields: InformaticaMappingGraphQLField
    ) -> "InformaticaMappingFields":
        """Subfields should come from the InformaticaMappingFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "InformaticaMappingFields":
        self._alias = alias
        return self


class IntegrationsFields(GraphQLField):
    installedTeamsTenants: "IntegrationsGraphQLField" = IntegrationsGraphQLField(
        "installedTeamsTenants"
    )

    def fields(self, *subfields: IntegrationsGraphQLField) -> "IntegrationsFields":
        """Subfields should come from the IntegrationsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "IntegrationsFields":
        self._alias = alias
        return self


class InterestedPartyFields(GraphQLField):
    externalEmail: "InterestedPartyGraphQLField" = InterestedPartyGraphQLField(
        "externalEmail"
    )

    @classmethod
    def person(cls) -> "PersonFields":
        return PersonFields("person")

    source: "InterestedPartyGraphQLField" = InterestedPartyGraphQLField("source")

    def fields(
        self, *subfields: Union[InterestedPartyGraphQLField, "PersonFields"]
    ) -> "InterestedPartyFields":
        """Subfields should come from the InterestedPartyFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "InterestedPartyFields":
        self._alias = alias
        return self


class KeyValuePairFields(GraphQLField):
    key: "KeyValuePairGraphQLField" = KeyValuePairGraphQLField("key")
    value: "KeyValuePairGraphQLField" = KeyValuePairGraphQLField("value")

    def fields(self, *subfields: KeyValuePairGraphQLField) -> "KeyValuePairFields":
        """Subfields should come from the KeyValuePairFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KeyValuePairFields":
        self._alias = alias
        return self


class KnowledgeCardFields(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def assetContacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("assetContacts")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField("createdAt")
    deletedAt: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField("deletedAt")
    displayName: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField("displayName")
    entityType: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def governedTags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governedTags", arguments=cleared_arguments
        )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField("id")
    isDeleted: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField("isDeleted")
    isViewerAuthor: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "isViewerAuthor"
    )

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledgeCardInfo(cls) -> "KnowledgeCardInfoFields":
        return KnowledgeCardInfoFields("knowledgeCardInfo")

    @classmethod
    def knowledgeCards(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledgeCards", arguments=cleared_arguments
        )

    lastIngestedAt: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "lastIngestedAt"
    )

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    lastModifiedAt: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "lastModifiedAt"
    )

    @classmethod
    def likes(cls) -> "AssetLikesFields":
        return AssetLikesFields("likes")

    @classmethod
    def logicalId(cls) -> "KnowledgeCardLogicalIdFields":
        return KnowledgeCardLogicalIdFields("logicalId")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def recentlyViewedBy(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "ViewedByConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewedByConnectionFields("recentlyViewedBy", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    viewerCanAcknowledge: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "viewerCanAcknowledge"
    )
    viewerCanAssignAssetContacts: "KnowledgeCardGraphQLField" = (
        KnowledgeCardGraphQLField("viewerCanAssignAssetContacts")
    )
    viewerCanCurateQuery: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "viewerCanCurateQuery"
    )
    viewerCanDelete: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "viewerCanDelete"
    )
    viewerCanEdit: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "viewerCanEdit"
    )
    viewerCanLike: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "viewerCanLike"
    )
    viewerCanUpdateChangeRequestStatus: "KnowledgeCardGraphQLField" = (
        KnowledgeCardGraphQLField("viewerCanUpdateChangeRequestStatus")
    )
    viewerHasPinned: "KnowledgeCardGraphQLField" = KnowledgeCardGraphQLField(
        "viewerHasPinned"
    )

    def fields(
        self,
        *subfields: Union[
            KnowledgeCardGraphQLField,
            "AggregationMetadataFields",
            "AssetContactsFields",
            "AssetFollowersFields",
            "AssetLikesFields",
            "AuditStampFields",
            "BrowsePathFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "KnowledgeCardInfoFields",
            "KnowledgeCardLogicalIdFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "UserDefinedResourceConnectionFields",
            "ViewedByConnectionFields",
        ]
    ) -> "KnowledgeCardFields":
        """Subfields should come from the KnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardFields":
        self._alias = alias
        return self


class KnowledgeCardBaseInterface(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField(
        "createdAt"
    )
    deletedAt: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField(
        "deletedAt"
    )
    displayName: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField(
        "displayName"
    )
    entityType: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField(
        "entityType"
    )

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField("id")
    isDeleted: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField(
        "isDeleted"
    )

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    lastIngestedAt: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField(
        "lastIngestedAt"
    )
    lastModifiedAt: "KnowledgeCardBaseGraphQLField" = KnowledgeCardBaseGraphQLField(
        "lastModifiedAt"
    )

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            KnowledgeCardBaseGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "KnowledgeCardBaseInterface":
        """Subfields should come from the KnowledgeCardBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "KnowledgeCardBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class KnowledgeCardConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "KnowledgeCardEdgeFields":
        return KnowledgeCardEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "KnowledgeCardConnectionGraphQLField" = (
        KnowledgeCardConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            KnowledgeCardConnectionGraphQLField,
            "KnowledgeCardEdgeFields",
            "PageInfoFields",
        ]
    ) -> "KnowledgeCardConnectionFields":
        """Subfields should come from the KnowledgeCardConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardConnectionFields":
        self._alias = alias
        return self


class KnowledgeCardDeletePayloadFields(GraphQLField):
    deletedIds: "KnowledgeCardDeletePayloadGraphQLField" = (
        KnowledgeCardDeletePayloadGraphQLField("deletedIds")
    )
    failedIds: "KnowledgeCardDeletePayloadGraphQLField" = (
        KnowledgeCardDeletePayloadGraphQLField("failedIds")
    )

    def fields(
        self, *subfields: KnowledgeCardDeletePayloadGraphQLField
    ) -> "KnowledgeCardDeletePayloadFields":
        """Subfields should come from the KnowledgeCardDeletePayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardDeletePayloadFields":
        self._alias = alias
        return self


class KnowledgeCardDetailFields(GraphQLField):
    @classmethod
    def assetDescription(cls) -> "AssetDescriptionKnowledgeCardFields":
        return AssetDescriptionKnowledgeCardFields("assetDescription")

    @classmethod
    def changeRequest(cls) -> "ChangeRequestKnowledgeCardFields":
        return ChangeRequestKnowledgeCardFields("changeRequest")

    @classmethod
    def columnDescription(cls) -> "ColumnDescriptionKnowledgeCardFields":
        return ColumnDescriptionKnowledgeCardFields("columnDescription")

    @classmethod
    def comment(cls) -> "CommentFields":
        return CommentFields("comment")

    @classmethod
    def dataDocument(cls) -> "DataDocumentFields":
        return DataDocumentFields("dataDocument")

    @classmethod
    def deprecation(cls) -> "DeprecationKnowledgeCardFields":
        return DeprecationKnowledgeCardFields("deprecation")

    @classmethod
    def incident(cls) -> "IncidentKnowledgeCardFields":
        return IncidentKnowledgeCardFields("incident")

    @classmethod
    def query(cls) -> "QueryKnowledgeCardFields":
        return QueryKnowledgeCardFields("query")

    type: "KnowledgeCardDetailGraphQLField" = KnowledgeCardDetailGraphQLField("type")

    @classmethod
    def usage(cls) -> "UsageKnowledgeCardFields":
        return UsageKnowledgeCardFields("usage")

    def fields(
        self,
        *subfields: Union[
            KnowledgeCardDetailGraphQLField,
            "AssetDescriptionKnowledgeCardFields",
            "ChangeRequestKnowledgeCardFields",
            "ColumnDescriptionKnowledgeCardFields",
            "CommentFields",
            "DataDocumentFields",
            "DeprecationKnowledgeCardFields",
            "IncidentKnowledgeCardFields",
            "QueryKnowledgeCardFields",
            "UsageKnowledgeCardFields",
        ]
    ) -> "KnowledgeCardDetailFields":
        """Subfields should come from the KnowledgeCardDetailFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardDetailFields":
        self._alias = alias
        return self


class KnowledgeCardEdgeFields(GraphQLField):
    cursor: "KnowledgeCardEdgeGraphQLField" = KnowledgeCardEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "KnowledgeCardFields":
        return KnowledgeCardFields("node")

    def fields(
        self, *subfields: Union[KnowledgeCardEdgeGraphQLField, "KnowledgeCardFields"]
    ) -> "KnowledgeCardEdgeFields":
        """Subfields should come from the KnowledgeCardEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardEdgeFields":
        self._alias = alias
        return self


class KnowledgeCardHighlightFields(GraphQLField):
    authorDisplayName: "KnowledgeCardHighlightGraphQLField" = (
        KnowledgeCardHighlightGraphQLField("authorDisplayName")
    )
    contactDisplayNames: "KnowledgeCardHighlightGraphQLField" = (
        KnowledgeCardHighlightGraphQLField("contactDisplayNames")
    )
    content: "KnowledgeCardHighlightGraphQLField" = KnowledgeCardHighlightGraphQLField(
        "content"
    )
    governedTags: "KnowledgeCardHighlightGraphQLField" = (
        KnowledgeCardHighlightGraphQLField("governedTags")
    )
    hashtags: "KnowledgeCardHighlightGraphQLField" = KnowledgeCardHighlightGraphQLField(
        "hashtags"
    )
    name: "KnowledgeCardHighlightGraphQLField" = KnowledgeCardHighlightGraphQLField(
        "name"
    )

    def fields(
        self, *subfields: KnowledgeCardHighlightGraphQLField
    ) -> "KnowledgeCardHighlightFields":
        """Subfields should come from the KnowledgeCardHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardHighlightFields":
        self._alias = alias
        return self


class KnowledgeCardInfoFields(GraphQLField):
    @classmethod
    def anchorEntity(cls) -> "EntityInterface":
        return EntityInterface("anchorEntity")

    @classmethod
    def archived(cls) -> "AuditStampFields":
        return AuditStampFields("archived")

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "KnowledgeCardInfoGraphQLField" = KnowledgeCardInfoGraphQLField(
        "createdAt"
    )

    @classmethod
    def detail(cls) -> "KnowledgeCardDetailFields":
        return KnowledgeCardDetailFields("detail")

    entityId: "KnowledgeCardInfoGraphQLField" = KnowledgeCardInfoGraphQLField(
        "entityId"
    )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    protected: "KnowledgeCardInfoGraphQLField" = KnowledgeCardInfoGraphQLField(
        "protected"
    )

    @classmethod
    def published(cls) -> "AuditStampFields":
        return AuditStampFields("published")

    @classmethod
    def relatedAssetsOfType(
        cls,
        type: EntityType,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "type": {"type": "EntityType!", "value": type},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields(
            "relatedAssetsOfType", arguments=cleared_arguments
        )

    relatedEntityIds: "KnowledgeCardInfoGraphQLField" = KnowledgeCardInfoGraphQLField(
        "relatedEntityIds"
    )

    @classmethod
    def relatedIdsOfType(cls, type: EntityType) -> "KnowledgeCardInfoGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "EntityType!", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardInfoGraphQLField(
            "relatedIdsOfType", arguments=cleared_arguments
        )

    status: "KnowledgeCardInfoGraphQLField" = KnowledgeCardInfoGraphQLField("status")

    def fields(
        self,
        *subfields: Union[
            KnowledgeCardInfoGraphQLField,
            "AuditStampFields",
            "EntityConnectionFields",
            "EntityInterface",
            "HashtagFields",
            "KnowledgeCardDetailFields",
        ]
    ) -> "KnowledgeCardInfoFields":
        """Subfields should come from the KnowledgeCardInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardInfoFields":
        self._alias = alias
        return self


class KnowledgeCardInfoBaseInterface(GraphQLField):
    createdAt: "KnowledgeCardInfoBaseGraphQLField" = KnowledgeCardInfoBaseGraphQLField(
        "createdAt"
    )
    entityId: "KnowledgeCardInfoBaseGraphQLField" = KnowledgeCardInfoBaseGraphQLField(
        "entityId"
    )
    relatedEntityIds: "KnowledgeCardInfoBaseGraphQLField" = (
        KnowledgeCardInfoBaseGraphQLField("relatedEntityIds")
    )

    def fields(
        self, *subfields: KnowledgeCardInfoBaseGraphQLField
    ) -> "KnowledgeCardInfoBaseInterface":
        """Subfields should come from the KnowledgeCardInfoBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardInfoBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "KnowledgeCardInfoBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class KnowledgeCardInfoOutputInterface(GraphQLField):
    @classmethod
    def archived(cls) -> "AuditStampFields":
        return AuditStampFields("archived")

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "KnowledgeCardInfoOutputGraphQLField" = (
        KnowledgeCardInfoOutputGraphQLField("createdAt")
    )
    entityId: "KnowledgeCardInfoOutputGraphQLField" = (
        KnowledgeCardInfoOutputGraphQLField("entityId")
    )

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    protected: "KnowledgeCardInfoOutputGraphQLField" = (
        KnowledgeCardInfoOutputGraphQLField("protected")
    )

    @classmethod
    def published(cls) -> "AuditStampFields":
        return AuditStampFields("published")

    relatedEntityIds: "KnowledgeCardInfoOutputGraphQLField" = (
        KnowledgeCardInfoOutputGraphQLField("relatedEntityIds")
    )

    @classmethod
    def relatedIdsOfType(
        cls, type: EntityType
    ) -> "KnowledgeCardInfoOutputGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "EntityType!", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardInfoOutputGraphQLField(
            "relatedIdsOfType", arguments=cleared_arguments
        )

    status: "KnowledgeCardInfoOutputGraphQLField" = KnowledgeCardInfoOutputGraphQLField(
        "status"
    )

    def fields(
        self, *subfields: Union[KnowledgeCardInfoOutputGraphQLField, "AuditStampFields"]
    ) -> "KnowledgeCardInfoOutputInterface":
        """Subfields should come from the KnowledgeCardInfoOutputInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardInfoOutputInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "KnowledgeCardInfoOutputInterface":
        self._inline_fragments[type_name] = subfields
        return self


class KnowledgeCardLogicalIdFields(GraphQLField):
    id: "KnowledgeCardLogicalIdGraphQLField" = KnowledgeCardLogicalIdGraphQLField("id")

    def fields(
        self, *subfields: KnowledgeCardLogicalIdGraphQLField
    ) -> "KnowledgeCardLogicalIdFields":
        """Subfields should come from the KnowledgeCardLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardLogicalIdFields":
        self._alias = alias
        return self


class KnowledgeCardSearchDocumentFields(GraphQLField):
    anchorEntityId: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("anchorEntityId")
    )
    anchorEntityType: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("anchorEntityType")
    )
    author: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("author")
    )
    authorDisplayName: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("authorDisplayName")
    )
    browsePathHierarchy: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browsePathSegments: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    contactDisplayNames: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("contactDisplayNames")
    )
    content: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("content")
    )
    createdAt: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("createdAt")
    )
    directory: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("directory")
    )
    documentId: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("documentId")
    )
    domainDisplayNames: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("domainDisplayNames")
    )
    domains: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("domains")
    )
    embeddedString_1: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("embeddedString_1")
    )
    embeddedString_2: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("embeddedString_2")
    )
    entityId: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("entityId")
    )
    governedTags: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("governedTags")
    )
    hashtags: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("hashtags")
    )

    @classmethod
    def highlight(cls) -> "KnowledgeCardHighlightFields":
        return KnowledgeCardHighlightFields("highlight")

    isArchived: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("isArchived")
    )
    isDeleted: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("isDeleted")
    )
    isDraft: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("isDraft")
    )
    lastRefreshed: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("lastRefreshed")
    )
    name: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("name")
    )
    paginationToken: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("paginationToken")
    )

    @classmethod
    def scoreDetails(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("scoreDetails")

    type: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("type")
    )
    viewCount: "KnowledgeCardSearchDocumentGraphQLField" = (
        KnowledgeCardSearchDocumentGraphQLField("viewCount")
    )

    def fields(
        self,
        *subfields: Union[
            KnowledgeCardSearchDocumentGraphQLField,
            "BrowsePathFields",
            "KnowledgeCardHighlightFields",
            "SearchScoreDetailsFields",
        ]
    ) -> "KnowledgeCardSearchDocumentFields":
        """Subfields should come from the KnowledgeCardSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardSearchDocumentFields":
        self._alias = alias
        return self


class KnowledgeCardSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "KnowledgeCardSearchDocumentFields":
        return KnowledgeCardSearchDocumentFields("documents")

    errorMessage: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("errorMessage")
    )
    from_: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("from")
    )
    hasMore: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("paginationToken")
    )
    searchContext: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("searchContext")
    )
    searchIndex: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("searchIndex")
    )
    size: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("size")
    )
    totalCount: "KnowledgeCardSearchResultGraphQLField" = (
        KnowledgeCardSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            KnowledgeCardSearchResultGraphQLField,
            "AggregationMetadataFields",
            "KnowledgeCardSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "KnowledgeCardSearchResultFields":
        """Subfields should come from the KnowledgeCardSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KnowledgeCardSearchResultFields":
        self._alias = alias
        return self


class LDAPFields(GraphQLField):
    bindDN: "LDAPGraphQLField" = LDAPGraphQLField("bindDN")
    bindPassword: "LDAPGraphQLField" = LDAPGraphQLField("bindPassword")

    @classmethod
    def groupSearch(cls) -> "LDAPGroupSearchFields":
        return LDAPGroupSearchFields("groupSearch")

    host: "LDAPGraphQLField" = LDAPGraphQLField("host")

    @classmethod
    def userSearch(cls) -> "LDAPUserSearchFields":
        return LDAPUserSearchFields("userSearch")

    def fields(
        self,
        *subfields: Union[
            LDAPGraphQLField, "LDAPGroupSearchFields", "LDAPUserSearchFields"
        ]
    ) -> "LDAPFields":
        """Subfields should come from the LDAPFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LDAPFields":
        self._alias = alias
        return self


class LDAPGroupSearchFields(GraphQLField):
    baseDN: "LDAPGroupSearchGraphQLField" = LDAPGroupSearchGraphQLField("baseDN")
    filter: "LDAPGroupSearchGraphQLField" = LDAPGroupSearchGraphQLField("filter")
    nameAttr: "LDAPGroupSearchGraphQLField" = LDAPGroupSearchGraphQLField("nameAttr")

    def fields(
        self, *subfields: LDAPGroupSearchGraphQLField
    ) -> "LDAPGroupSearchFields":
        """Subfields should come from the LDAPGroupSearchFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LDAPGroupSearchFields":
        self._alias = alias
        return self


class LDAPUserSearchFields(GraphQLField):
    baseDN: "LDAPUserSearchGraphQLField" = LDAPUserSearchGraphQLField("baseDN")
    emailAttr: "LDAPUserSearchGraphQLField" = LDAPUserSearchGraphQLField("emailAttr")
    filter: "LDAPUserSearchGraphQLField" = LDAPUserSearchGraphQLField("filter")
    idAttr: "LDAPUserSearchGraphQLField" = LDAPUserSearchGraphQLField("idAttr")
    nameAttr: "LDAPUserSearchGraphQLField" = LDAPUserSearchGraphQLField("nameAttr")
    username: "LDAPUserSearchGraphQLField" = LDAPUserSearchGraphQLField("username")

    def fields(self, *subfields: LDAPUserSearchGraphQLField) -> "LDAPUserSearchFields":
        """Subfields should come from the LDAPUserSearchFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LDAPUserSearchFields":
        self._alias = alias
        return self


class LinkedInSocialLoginFields(GraphQLField):
    auth0ClientId: "LinkedInSocialLoginGraphQLField" = LinkedInSocialLoginGraphQLField(
        "auth0ClientId"
    )
    auth0ClientSecret: "LinkedInSocialLoginGraphQLField" = (
        LinkedInSocialLoginGraphQLField("auth0ClientSecret")
    )
    auth0Issuer: "LinkedInSocialLoginGraphQLField" = LinkedInSocialLoginGraphQLField(
        "auth0Issuer"
    )

    def fields(
        self, *subfields: LinkedInSocialLoginGraphQLField
    ) -> "LinkedInSocialLoginFields":
        """Subfields should come from the LinkedInSocialLoginFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LinkedInSocialLoginFields":
        self._alias = alias
        return self


class LookerExploreFields(GraphQLField):
    @classmethod
    def baseView(cls) -> "VirtualViewFields":
        return VirtualViewFields("baseView")

    createdAt: "LookerExploreGraphQLField" = LookerExploreGraphQLField("createdAt")
    description: "LookerExploreGraphQLField" = LookerExploreGraphQLField("description")

    @classmethod
    def downstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstreamOfType", arguments=cleared_arguments
        )

    entityId: "LookerExploreGraphQLField" = LookerExploreGraphQLField("entityId")
    extends: "LookerExploreGraphQLField" = LookerExploreGraphQLField("extends")
    fields: "LookerExploreGraphQLField" = LookerExploreGraphQLField("fields")

    @classmethod
    def filters(cls) -> "LookerExploreFilterFields":
        return LookerExploreFilterFields("filters")

    @classmethod
    def joins(cls) -> "LookerExploreJoinFields":
        return LookerExploreJoinFields("joins")

    label: "LookerExploreGraphQLField" = LookerExploreGraphQLField("label")
    modelName: "LookerExploreGraphQLField" = LookerExploreGraphQLField("modelName")

    @classmethod
    def upstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstreamOfType", arguments=cleared_arguments
        )

    url: "LookerExploreGraphQLField" = LookerExploreGraphQLField("url")

    def fields(
        self,
        *subfields: Union[
            LookerExploreGraphQLField,
            "EntityLineageConnectionFields",
            "LookerExploreFilterFields",
            "LookerExploreJoinFields",
            "VirtualViewFields",
        ]
    ) -> "LookerExploreFields":
        """Subfields should come from the LookerExploreFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerExploreFields":
        self._alias = alias
        return self


class LookerExploreFilterFields(GraphQLField):
    allowedValues: "LookerExploreFilterGraphQLField" = LookerExploreFilterGraphQLField(
        "allowedValues"
    )
    field: "LookerExploreFilterGraphQLField" = LookerExploreFilterGraphQLField("field")

    def fields(
        self, *subfields: LookerExploreFilterGraphQLField
    ) -> "LookerExploreFilterFields":
        """Subfields should come from the LookerExploreFilterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerExploreFilterFields":
        self._alias = alias
        return self


class LookerExploreJoinFields(GraphQLField):
    fields: "LookerExploreJoinGraphQLField" = LookerExploreJoinGraphQLField("fields")
    onClause: "LookerExploreJoinGraphQLField" = LookerExploreJoinGraphQLField(
        "onClause"
    )
    relationship: "LookerExploreJoinGraphQLField" = LookerExploreJoinGraphQLField(
        "relationship"
    )
    type: "LookerExploreJoinGraphQLField" = LookerExploreJoinGraphQLField("type")

    @classmethod
    def view(cls) -> "VirtualViewFields":
        return VirtualViewFields("view")

    whereClause: "LookerExploreJoinGraphQLField" = LookerExploreJoinGraphQLField(
        "whereClause"
    )

    def fields(
        self, *subfields: Union[LookerExploreJoinGraphQLField, "VirtualViewFields"]
    ) -> "LookerExploreJoinFields":
        """Subfields should come from the LookerExploreJoinFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerExploreJoinFields":
        self._alias = alias
        return self


class LookerExploreSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "VirtualViewSearchDocumentFields":
        return VirtualViewSearchDocumentFields("documents")

    errorMessage: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("errorMessage")
    )
    from_: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("from")
    )
    hasMore: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("paginationToken")
    )
    searchContext: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("searchContext")
    )
    searchIndex: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("searchIndex")
    )
    size: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("size")
    )
    totalCount: "LookerExploreSearchResultGraphQLField" = (
        LookerExploreSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            LookerExploreSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "VirtualViewSearchDocumentFields",
        ]
    ) -> "LookerExploreSearchResultFields":
        """Subfields should come from the LookerExploreSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerExploreSearchResultFields":
        self._alias = alias
        return self


class LookerViewFields(GraphQLField):
    createdAt: "LookerViewGraphQLField" = LookerViewGraphQLField("createdAt")

    @classmethod
    def dimensions(cls) -> "LookerViewDimensionFields":
        return LookerViewDimensionFields("dimensions")

    @classmethod
    def downstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstreamOfType", arguments=cleared_arguments
        )

    entityId: "LookerViewGraphQLField" = LookerViewGraphQLField("entityId")
    extends: "LookerViewGraphQLField" = LookerViewGraphQLField("extends")

    @classmethod
    def filters(cls) -> "LookerViewFilterFields":
        return LookerViewFilterFields("filters")

    label: "LookerViewGraphQLField" = LookerViewGraphQLField("label")

    @classmethod
    def measures(cls) -> "LookerViewMeasureFields":
        return LookerViewMeasureFields("measures")

    @classmethod
    def query(cls) -> "LookerViewQueryFields":
        return LookerViewQueryFields("query")

    sourceDatasets: "LookerViewGraphQLField" = LookerViewGraphQLField("sourceDatasets")

    @classmethod
    def upstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstreamOfType", arguments=cleared_arguments
        )

    url: "LookerViewGraphQLField" = LookerViewGraphQLField("url")

    def fields(
        self,
        *subfields: Union[
            LookerViewGraphQLField,
            "EntityLineageConnectionFields",
            "LookerViewDimensionFields",
            "LookerViewFilterFields",
            "LookerViewMeasureFields",
            "LookerViewQueryFields",
        ]
    ) -> "LookerViewFields":
        """Subfields should come from the LookerViewFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerViewFields":
        self._alias = alias
        return self


class LookerViewDimensionFields(GraphQLField):
    dataType: "LookerViewDimensionGraphQLField" = LookerViewDimensionGraphQLField(
        "dataType"
    )
    field: "LookerViewDimensionGraphQLField" = LookerViewDimensionGraphQLField("field")

    def fields(
        self, *subfields: LookerViewDimensionGraphQLField
    ) -> "LookerViewDimensionFields":
        """Subfields should come from the LookerViewDimensionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerViewDimensionFields":
        self._alias = alias
        return self


class LookerViewFilterFields(GraphQLField):
    field: "LookerViewFilterGraphQLField" = LookerViewFilterGraphQLField("field")
    type: "LookerViewFilterGraphQLField" = LookerViewFilterGraphQLField("type")

    def fields(
        self, *subfields: LookerViewFilterGraphQLField
    ) -> "LookerViewFilterFields":
        """Subfields should come from the LookerViewFilterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerViewFilterFields":
        self._alias = alias
        return self


class LookerViewMeasureFields(GraphQLField):
    field: "LookerViewMeasureGraphQLField" = LookerViewMeasureGraphQLField("field")
    type: "LookerViewMeasureGraphQLField" = LookerViewMeasureGraphQLField("type")

    def fields(
        self, *subfields: LookerViewMeasureGraphQLField
    ) -> "LookerViewMeasureFields":
        """Subfields should come from the LookerViewMeasureFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerViewMeasureFields":
        self._alias = alias
        return self


class LookerViewQueryFields(GraphQLField):
    defaultDatabase: "LookerViewQueryGraphQLField" = LookerViewQueryGraphQLField(
        "defaultDatabase"
    )
    defaultSchema: "LookerViewQueryGraphQLField" = LookerViewQueryGraphQLField(
        "defaultSchema"
    )
    query: "LookerViewQueryGraphQLField" = LookerViewQueryGraphQLField("query")
    sourceDatasetAccount: "LookerViewQueryGraphQLField" = LookerViewQueryGraphQLField(
        "sourceDatasetAccount"
    )
    sourcePlatform: "LookerViewQueryGraphQLField" = LookerViewQueryGraphQLField(
        "sourcePlatform"
    )

    def fields(
        self, *subfields: LookerViewQueryGraphQLField
    ) -> "LookerViewQueryFields":
        """Subfields should come from the LookerViewQueryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerViewQueryFields":
        self._alias = alias
        return self


class LookerViewSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "VirtualViewSearchDocumentFields":
        return VirtualViewSearchDocumentFields("documents")

    errorMessage: "LookerViewSearchResultGraphQLField" = (
        LookerViewSearchResultGraphQLField("errorMessage")
    )
    from_: "LookerViewSearchResultGraphQLField" = LookerViewSearchResultGraphQLField(
        "from"
    )
    hasMore: "LookerViewSearchResultGraphQLField" = LookerViewSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "LookerViewSearchResultGraphQLField" = (
        LookerViewSearchResultGraphQLField("paginationToken")
    )
    searchContext: "LookerViewSearchResultGraphQLField" = (
        LookerViewSearchResultGraphQLField("searchContext")
    )
    searchIndex: "LookerViewSearchResultGraphQLField" = (
        LookerViewSearchResultGraphQLField("searchIndex")
    )
    size: "LookerViewSearchResultGraphQLField" = LookerViewSearchResultGraphQLField(
        "size"
    )
    totalCount: "LookerViewSearchResultGraphQLField" = (
        LookerViewSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            LookerViewSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "VirtualViewSearchDocumentFields",
        ]
    ) -> "LookerViewSearchResultFields":
        """Subfields should come from the LookerViewSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LookerViewSearchResultFields":
        self._alias = alias
        return self


class MetabaseCollectionFields(GraphQLField):
    name: "MetabaseCollectionGraphQLField" = MetabaseCollectionGraphQLField("name")
    url: "MetabaseCollectionGraphQLField" = MetabaseCollectionGraphQLField("url")

    def fields(
        self, *subfields: MetabaseCollectionGraphQLField
    ) -> "MetabaseCollectionFields":
        """Subfields should come from the MetabaseCollectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetabaseCollectionFields":
        self._alias = alias
        return self


class MetricFields(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def assetContacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("assetContacts")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "MetricGraphQLField" = MetricGraphQLField("createdAt")

    @classmethod
    def dbtMetric(cls) -> "DbtMetricFields":
        return DbtMetricFields("dbtMetric")

    deletedAt: "MetricGraphQLField" = MetricGraphQLField("deletedAt")

    @classmethod
    def descriptions(cls) -> "DerivedAssetDescriptionsFields":
        return DerivedAssetDescriptionsFields("descriptions")

    displayName: "MetricGraphQLField" = MetricGraphQLField("displayName")

    @classmethod
    def downstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineageFor: Optional[LineageFilterInput] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineageFor},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstreamOfType", arguments=cleared_arguments
        )

    entityType: "MetricGraphQLField" = MetricGraphQLField("entityType")

    @classmethod
    def entityUpstream(cls) -> "EntityUpstreamFields":
        return EntityUpstreamFields("entityUpstream")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def forceShown(cls) -> "AuditStampFields":
        return AuditStampFields("forceShown")

    @classmethod
    def governedTags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governedTags", arguments=cleared_arguments
        )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "MetricGraphQLField" = MetricGraphQLField("id")

    @classmethod
    def interestedParties(cls) -> "InterestedPartyFields":
        return InterestedPartyFields("interestedParties")

    isComplete: "MetricGraphQLField" = MetricGraphQLField("isComplete")
    isDeleted: "MetricGraphQLField" = MetricGraphQLField("isDeleted")
    isProduction: "MetricGraphQLField" = MetricGraphQLField("isProduction")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledgeCards(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledgeCards", arguments=cleared_arguments
        )

    @classmethod
    def labels(cls) -> "AnchorEntityLabelFields":
        return AnchorEntityLabelFields("labels")

    lastIngestedAt: "MetricGraphQLField" = MetricGraphQLField("lastIngestedAt")
    lastModifiedAt: "MetricGraphQLField" = MetricGraphQLField("lastModifiedAt")

    @classmethod
    def logicalId(cls) -> "MetricLogicalIdFields":
        return MetricLogicalIdFields("logicalId")

    @classmethod
    def metricInfo(cls) -> "MetricInfoFields":
        return MetricInfoFields("metricInfo")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def recentUserActivities(
        cls, *, input: Optional[RecentUserActivitiesFilterInput] = None
    ) -> "RecentUserActivitiesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "RecentUserActivitiesFilterInput", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return RecentUserActivitiesFields(
            "recentUserActivities", arguments=cleared_arguments
        )

    @classmethod
    def recentlyViewedBy(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "ViewedByConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewedByConnectionFields("recentlyViewedBy", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def sourceInfo(cls) -> "SourceInfoFields":
        return SourceInfoFields("sourceInfo")

    @classmethod
    def systemContacts(cls) -> "SystemContactsFields":
        return SystemContactsFields("systemContacts")

    @classmethod
    def systemDescription(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("systemDescription")

    systemTagValues: "MetricGraphQLField" = MetricGraphQLField("systemTagValues")

    @classmethod
    def systemTags(cls) -> "SystemTagsFields":
        return SystemTagsFields("systemTags")

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    @classmethod
    def topKnowledgeCardAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(
            "topKnowledgeCardAuthors", arguments=cleared_arguments
        )

    @classmethod
    def upstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineageFor: Optional[LineageFilterInput] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineageFor},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstreamOfType", arguments=cleared_arguments
        )

    viewerCanAssignAssetContacts: "MetricGraphQLField" = MetricGraphQLField(
        "viewerCanAssignAssetContacts"
    )
    viewerHasPinned: "MetricGraphQLField" = MetricGraphQLField("viewerHasPinned")

    def fields(
        self,
        *subfields: Union[
            MetricGraphQLField,
            "AggregationMetadataFields",
            "AnchorEntityLabelFields",
            "AssetContactsFields",
            "AssetFollowersFields",
            "AuditStampFields",
            "BrowsePathFields",
            "DbtMetricFields",
            "DerivedAssetDescriptionsFields",
            "EntityConnectionFields",
            "EntityLineageConnectionFields",
            "EntityUpstreamFields",
            "HashtagFields",
            "InterestedPartyFields",
            "KnowledgeCardConnectionFields",
            "MetricInfoFields",
            "MetricLogicalIdFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "RecentUserActivitiesFields",
            "SourceInfoFields",
            "SystemContactsFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
            "UserDefinedResourceConnectionFields",
            "ViewedByConnectionFields",
        ]
    ) -> "MetricFields":
        """Subfields should come from the MetricFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricFields":
        self._alias = alias
        return self


class MetricBaseInterface(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "MetricBaseGraphQLField" = MetricBaseGraphQLField("createdAt")

    @classmethod
    def dbtMetric(cls) -> "DbtMetricFields":
        return DbtMetricFields("dbtMetric")

    deletedAt: "MetricBaseGraphQLField" = MetricBaseGraphQLField("deletedAt")
    displayName: "MetricBaseGraphQLField" = MetricBaseGraphQLField("displayName")
    entityType: "MetricBaseGraphQLField" = MetricBaseGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def forceShown(cls) -> "AuditStampFields":
        return AuditStampFields("forceShown")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "MetricBaseGraphQLField" = MetricBaseGraphQLField("id")
    isComplete: "MetricBaseGraphQLField" = MetricBaseGraphQLField("isComplete")
    isDeleted: "MetricBaseGraphQLField" = MetricBaseGraphQLField("isDeleted")
    isProduction: "MetricBaseGraphQLField" = MetricBaseGraphQLField("isProduction")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    lastIngestedAt: "MetricBaseGraphQLField" = MetricBaseGraphQLField("lastIngestedAt")
    lastModifiedAt: "MetricBaseGraphQLField" = MetricBaseGraphQLField("lastModifiedAt")

    @classmethod
    def logicalId(cls) -> "MetricLogicalIdFields":
        return MetricLogicalIdFields("logicalId")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def sourceInfo(cls) -> "SourceInfoFields":
        return SourceInfoFields("sourceInfo")

    @classmethod
    def systemContacts(cls) -> "SystemContactsFields":
        return SystemContactsFields("systemContacts")

    @classmethod
    def systemDescription(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("systemDescription")

    systemTagValues: "MetricBaseGraphQLField" = MetricBaseGraphQLField(
        "systemTagValues"
    )

    @classmethod
    def systemTags(cls) -> "SystemTagsFields":
        return SystemTagsFields("systemTags")

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            MetricBaseGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "AuditStampFields",
            "BrowsePathFields",
            "DbtMetricFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "MetricLogicalIdFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "SourceInfoFields",
            "SystemContactsFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
        ]
    ) -> "MetricBaseInterface":
        """Subfields should come from the MetricBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricBaseInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "MetricBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class MetricConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "MetricEdgeFields":
        return MetricEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "MetricConnectionGraphQLField" = MetricConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            MetricConnectionGraphQLField, "MetricEdgeFields", "PageInfoFields"
        ]
    ) -> "MetricConnectionFields":
        """Subfields should come from the MetricConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricConnectionFields":
        self._alias = alias
        return self


class MetricEdgeFields(GraphQLField):
    cursor: "MetricEdgeGraphQLField" = MetricEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "MetricFields":
        return MetricFields("node")

    def fields(
        self, *subfields: Union[MetricEdgeGraphQLField, "MetricFields"]
    ) -> "MetricEdgeFields":
        """Subfields should come from the MetricEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricEdgeFields":
        self._alias = alias
        return self


class MetricFilterFields(GraphQLField):
    field: "MetricFilterGraphQLField" = MetricFilterGraphQLField("field")
    operator: "MetricFilterGraphQLField" = MetricFilterGraphQLField("operator")
    value: "MetricFilterGraphQLField" = MetricFilterGraphQLField("value")

    def fields(self, *subfields: MetricFilterGraphQLField) -> "MetricFilterFields":
        """Subfields should come from the MetricFilterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricFilterFields":
        self._alias = alias
        return self


class MetricInfoFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "MetricInfoGraphQLField" = MetricInfoGraphQLField("createdAt")
    entityId: "MetricInfoGraphQLField" = MetricInfoGraphQLField("entityId")

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    def fields(
        self, *subfields: Union[MetricInfoGraphQLField, "AuditStampFields"]
    ) -> "MetricInfoFields":
        """Subfields should come from the MetricInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricInfoFields":
        self._alias = alias
        return self


class MetricInfoBaseInterface(GraphQLField):
    createdAt: "MetricInfoBaseGraphQLField" = MetricInfoBaseGraphQLField("createdAt")
    entityId: "MetricInfoBaseGraphQLField" = MetricInfoBaseGraphQLField("entityId")

    def fields(
        self, *subfields: MetricInfoBaseGraphQLField
    ) -> "MetricInfoBaseInterface":
        """Subfields should come from the MetricInfoBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricInfoBaseInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "MetricInfoBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class MetricLogicalIdFields(GraphQLField):
    name: "MetricLogicalIdGraphQLField" = MetricLogicalIdGraphQLField("name")
    type: "MetricLogicalIdGraphQLField" = MetricLogicalIdGraphQLField("type")

    def fields(
        self, *subfields: MetricLogicalIdGraphQLField
    ) -> "MetricLogicalIdFields":
        """Subfields should come from the MetricLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricLogicalIdFields":
        self._alias = alias
        return self


class MetricSearchInfoFields(GraphQLField):
    type: "MetricSearchInfoGraphQLField" = MetricSearchInfoGraphQLField("type")

    def fields(
        self, *subfields: MetricSearchInfoGraphQLField
    ) -> "MetricSearchInfoFields":
        """Subfields should come from the MetricSearchInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricSearchInfoFields":
        self._alias = alias
        return self


class MetricSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "AssetSearchDocumentFields":
        return AssetSearchDocumentFields("documents")

    errorMessage: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField(
        "errorMessage"
    )
    from_: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField("from")
    hasMore: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField(
        "paginationToken"
    )
    searchContext: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField(
        "searchContext"
    )
    searchIndex: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField(
        "searchIndex"
    )
    size: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField("size")
    totalCount: "MetricSearchResultGraphQLField" = MetricSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            MetricSearchResultGraphQLField,
            "AggregationMetadataFields",
            "AssetSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "MetricSearchResultFields":
        """Subfields should come from the MetricSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricSearchResultFields":
        self._alias = alias
        return self


class MicrosoftSocialLoginFields(GraphQLField):
    allowedEmailPatterns: "MicrosoftSocialLoginGraphQLField" = (
        MicrosoftSocialLoginGraphQLField("allowedEmailPatterns")
    )

    def fields(
        self, *subfields: MicrosoftSocialLoginGraphQLField
    ) -> "MicrosoftSocialLoginFields":
        """Subfields should come from the MicrosoftSocialLoginFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MicrosoftSocialLoginFields":
        self._alias = alias
        return self


class NamespaceFields(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def assetContacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("assetContacts")

    @classmethod
    def assetsGovernedTags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[GovernedTagFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "GovernedTagFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "assetsGovernedTags", arguments=cleared_arguments
        )

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    @classmethod
    def childNamespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("childNamespaces", arguments=cleared_arguments)

    createdAt: "NamespaceGraphQLField" = NamespaceGraphQLField("createdAt")

    @classmethod
    def customAssetOrdering(
        cls, *, type: Optional[UserDefinedOrderType] = None
    ) -> "OrderedEntryFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "UserDefinedOrderType", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return OrderedEntryFields("customAssetOrdering", arguments=cleared_arguments)

    deletedAt: "NamespaceGraphQLField" = NamespaceGraphQLField("deletedAt")

    @classmethod
    def descriptions(cls) -> "DerivedAssetDescriptionsFields":
        return DerivedAssetDescriptionsFields("descriptions")

    displayName: "NamespaceGraphQLField" = NamespaceGraphQLField("displayName")
    domainAssetsCount: "NamespaceGraphQLField" = NamespaceGraphQLField(
        "domainAssetsCount"
    )
    entityType: "NamespaceGraphQLField" = NamespaceGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def governedTags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governedTags", arguments=cleared_arguments
        )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "NamespaceGraphQLField" = NamespaceGraphQLField("id")
    isDeleted: "NamespaceGraphQLField" = NamespaceGraphQLField("isDeleted")
    isViewerAuthor: "NamespaceGraphQLField" = NamespaceGraphQLField("isViewerAuthor")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledgeCards(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledgeCards", arguments=cleared_arguments
        )

    lastIngestedAt: "NamespaceGraphQLField" = NamespaceGraphQLField("lastIngestedAt")
    lastModifiedAt: "NamespaceGraphQLField" = NamespaceGraphQLField("lastModifiedAt")

    @classmethod
    def logicalId(cls) -> "NamespaceLogicalIdFields":
        return NamespaceLogicalIdFields("logicalId")

    @classmethod
    def namespaceAssets(cls) -> "NamespaceAssetsFields":
        return NamespaceAssetsFields("namespaceAssets")

    @classmethod
    def namespaceInfo(cls) -> "NamespaceInfoFields":
        return NamespaceInfoFields("namespaceInfo")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def parentNamespace(cls) -> "NamespaceFields":
        return NamespaceFields("parentNamespace")

    @classmethod
    def recentlyViewedBy(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "ViewedByConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewedByConnectionFields("recentlyViewedBy", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def summary(cls) -> "NamespaceSummaryFields":
        return NamespaceSummaryFields("summary")

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    viewerCanAssign: "NamespaceGraphQLField" = NamespaceGraphQLField("viewerCanAssign")
    viewerCanAssignAssetContacts: "NamespaceGraphQLField" = NamespaceGraphQLField(
        "viewerCanAssignAssetContacts"
    )
    viewerCanDelete: "NamespaceGraphQLField" = NamespaceGraphQLField("viewerCanDelete")
    viewerCanEdit: "NamespaceGraphQLField" = NamespaceGraphQLField("viewerCanEdit")
    viewerHasPinned: "NamespaceGraphQLField" = NamespaceGraphQLField("viewerHasPinned")

    def fields(
        self,
        *subfields: Union[
            NamespaceGraphQLField,
            "AggregationMetadataFields",
            "AssetContactsFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "DerivedAssetDescriptionsFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceAssetsFields",
            "NamespaceConnectionFields",
            "NamespaceFields",
            "NamespaceInfoFields",
            "NamespaceLogicalIdFields",
            "NamespaceSummaryFields",
            "OrderedEntryFields",
            "PersonConnectionFields",
            "UserDefinedResourceConnectionFields",
            "ViewedByConnectionFields",
        ]
    ) -> "NamespaceFields":
        """Subfields should come from the NamespaceFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceFields":
        self._alias = alias
        return self


class NamespaceAssetsFields(GraphQLField):
    @classmethod
    def assets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("assets", arguments=cleared_arguments)

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "NamespaceAssetsGraphQLField" = NamespaceAssetsGraphQLField("createdAt")
    entityId: "NamespaceAssetsGraphQLField" = NamespaceAssetsGraphQLField("entityId")

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    @classmethod
    def namedAssetCollections(
        cls,
        *,
        id: Optional[str] = None,
        name: Optional[str] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "CustomSortableNamedAssetCollectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "String", "value": id},
            "name": {"type": "String", "value": name},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return CustomSortableNamedAssetCollectionFields(
            "namedAssetCollections", arguments=cleared_arguments
        )

    def fields(
        self,
        *subfields: Union[
            NamespaceAssetsGraphQLField,
            "AuditStampFields",
            "CustomSortableNamedAssetCollectionFields",
            "EntityConnectionFields",
        ]
    ) -> "NamespaceAssetsFields":
        """Subfields should come from the NamespaceAssetsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceAssetsFields":
        self._alias = alias
        return self


class NamespaceBaseInterface(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField("createdAt")
    deletedAt: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField("deletedAt")
    displayName: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField("displayName")
    entityType: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField("id")
    isDeleted: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField("isDeleted")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    lastIngestedAt: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField(
        "lastIngestedAt"
    )
    lastModifiedAt: "NamespaceBaseGraphQLField" = NamespaceBaseGraphQLField(
        "lastModifiedAt"
    )

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            NamespaceBaseGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "NamespaceBaseInterface":
        """Subfields should come from the NamespaceBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceBaseInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "NamespaceBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class NamespaceConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "NamespaceEdgeFields":
        return NamespaceEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "NamespaceConnectionGraphQLField" = NamespaceConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            NamespaceConnectionGraphQLField, "NamespaceEdgeFields", "PageInfoFields"
        ]
    ) -> "NamespaceConnectionFields":
        """Subfields should come from the NamespaceConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceConnectionFields":
        self._alias = alias
        return self


class NamespaceDeletePayloadFields(GraphQLField):
    deletedIds: "NamespaceDeletePayloadGraphQLField" = (
        NamespaceDeletePayloadGraphQLField("deletedIds")
    )
    failedIds: "NamespaceDeletePayloadGraphQLField" = (
        NamespaceDeletePayloadGraphQLField("failedIds")
    )

    def fields(
        self, *subfields: NamespaceDeletePayloadGraphQLField
    ) -> "NamespaceDeletePayloadFields":
        """Subfields should come from the NamespaceDeletePayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceDeletePayloadFields":
        self._alias = alias
        return self


class NamespaceDescriptionFields(GraphQLField):
    text: "NamespaceDescriptionGraphQLField" = NamespaceDescriptionGraphQLField("text")
    tokenizedText: "NamespaceDescriptionGraphQLField" = (
        NamespaceDescriptionGraphQLField("tokenizedText")
    )

    def fields(
        self, *subfields: NamespaceDescriptionGraphQLField
    ) -> "NamespaceDescriptionFields":
        """Subfields should come from the NamespaceDescriptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceDescriptionFields":
        self._alias = alias
        return self


class NamespaceEdgeFields(GraphQLField):
    cursor: "NamespaceEdgeGraphQLField" = NamespaceEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "NamespaceFields":
        return NamespaceFields("node")

    def fields(
        self, *subfields: Union[NamespaceEdgeGraphQLField, "NamespaceFields"]
    ) -> "NamespaceEdgeFields":
        """Subfields should come from the NamespaceEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceEdgeFields":
        self._alias = alias
        return self


class NamespaceHighlightFields(GraphQLField):
    contactDisplayNames: "NamespaceHighlightGraphQLField" = (
        NamespaceHighlightGraphQLField("contactDisplayNames")
    )
    description: "NamespaceHighlightGraphQLField" = NamespaceHighlightGraphQLField(
        "description"
    )
    governedTags: "NamespaceHighlightGraphQLField" = NamespaceHighlightGraphQLField(
        "governedTags"
    )
    hashtags: "NamespaceHighlightGraphQLField" = NamespaceHighlightGraphQLField(
        "hashtags"
    )
    name: "NamespaceHighlightGraphQLField" = NamespaceHighlightGraphQLField("name")

    def fields(
        self, *subfields: NamespaceHighlightGraphQLField
    ) -> "NamespaceHighlightFields":
        """Subfields should come from the NamespaceHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceHighlightFields":
        self._alias = alias
        return self


class NamespaceInfoFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "NamespaceInfoGraphQLField" = NamespaceInfoGraphQLField("createdAt")

    @classmethod
    def customAttributes(cls) -> "CustomAttributesFields":
        return CustomAttributesFields("customAttributes")

    @classmethod
    def description(cls) -> "NamespaceDescriptionFields":
        return NamespaceDescriptionFields("description")

    @classmethod
    def detail(cls) -> "NamespaceTypeDetailFields":
        return NamespaceTypeDetailFields("detail")

    entityId: "NamespaceInfoGraphQLField" = NamespaceInfoGraphQLField("entityId")

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    name: "NamespaceInfoGraphQLField" = NamespaceInfoGraphQLField("name")
    visibleTo: "NamespaceInfoGraphQLField" = NamespaceInfoGraphQLField("visibleTo")

    def fields(
        self,
        *subfields: Union[
            NamespaceInfoGraphQLField,
            "AuditStampFields",
            "CustomAttributesFields",
            "NamespaceDescriptionFields",
            "NamespaceTypeDetailFields",
        ]
    ) -> "NamespaceInfoFields":
        """Subfields should come from the NamespaceInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceInfoFields":
        self._alias = alias
        return self


class NamespaceInfoBaseInterface(GraphQLField):
    createdAt: "NamespaceInfoBaseGraphQLField" = NamespaceInfoBaseGraphQLField(
        "createdAt"
    )

    @classmethod
    def customAttributes(cls) -> "CustomAttributesFields":
        return CustomAttributesFields("customAttributes")

    @classmethod
    def description(cls) -> "NamespaceDescriptionFields":
        return NamespaceDescriptionFields("description")

    entityId: "NamespaceInfoBaseGraphQLField" = NamespaceInfoBaseGraphQLField(
        "entityId"
    )
    name: "NamespaceInfoBaseGraphQLField" = NamespaceInfoBaseGraphQLField("name")
    visibleTo: "NamespaceInfoBaseGraphQLField" = NamespaceInfoBaseGraphQLField(
        "visibleTo"
    )

    def fields(
        self,
        *subfields: Union[
            NamespaceInfoBaseGraphQLField,
            "CustomAttributesFields",
            "NamespaceDescriptionFields",
        ]
    ) -> "NamespaceInfoBaseInterface":
        """Subfields should come from the NamespaceInfoBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceInfoBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "NamespaceInfoBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class NamespaceLogicalIdFields(GraphQLField):
    id: "NamespaceLogicalIdGraphQLField" = NamespaceLogicalIdGraphQLField("id")

    def fields(
        self, *subfields: NamespaceLogicalIdGraphQLField
    ) -> "NamespaceLogicalIdFields":
        """Subfields should come from the NamespaceLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceLogicalIdFields":
        self._alias = alias
        return self


class NamespaceSearchDocumentFields(GraphQLField):
    author: "NamespaceSearchDocumentGraphQLField" = NamespaceSearchDocumentGraphQLField(
        "author"
    )
    authorDisplayName: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("authorDisplayName")
    )
    browsePathHierarchy: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browsePathSegments: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    contactDisplayNames: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("contactDisplayNames")
    )
    description: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("description")
    )
    documentId: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("documentId")
    )
    domainDisplayName: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("domainDisplayName")
    )
    domains: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("domains")
    )
    embeddedString_1: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("embeddedString_1")
    )
    embeddedString_2: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("embeddedString_2")
    )
    entityId: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("entityId")
    )
    governedTags: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("governedTags")
    )
    hashtags: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("hashtags")
    )

    @classmethod
    def highlight(cls) -> "NamespaceHighlightFields":
        return NamespaceHighlightFields("highlight")

    isDeleted: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("isDeleted")
    )
    lastRefreshed: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("lastRefreshed")
    )
    name: "NamespaceSearchDocumentGraphQLField" = NamespaceSearchDocumentGraphQLField(
        "name"
    )
    paginationToken: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("paginationToken")
    )

    @classmethod
    def scoreDetails(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("scoreDetails")

    type: "NamespaceSearchDocumentGraphQLField" = NamespaceSearchDocumentGraphQLField(
        "type"
    )
    viewCount: "NamespaceSearchDocumentGraphQLField" = (
        NamespaceSearchDocumentGraphQLField("viewCount")
    )

    def fields(
        self,
        *subfields: Union[
            NamespaceSearchDocumentGraphQLField,
            "BrowsePathFields",
            "NamespaceHighlightFields",
            "SearchScoreDetailsFields",
        ]
    ) -> "NamespaceSearchDocumentFields":
        """Subfields should come from the NamespaceSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceSearchDocumentFields":
        self._alias = alias
        return self


class NamespaceSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "NamespaceSearchDocumentFields":
        return NamespaceSearchDocumentFields("documents")

    errorMessage: "NamespaceSearchResultGraphQLField" = (
        NamespaceSearchResultGraphQLField("errorMessage")
    )
    from_: "NamespaceSearchResultGraphQLField" = NamespaceSearchResultGraphQLField(
        "from"
    )
    hasMore: "NamespaceSearchResultGraphQLField" = NamespaceSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "NamespaceSearchResultGraphQLField" = (
        NamespaceSearchResultGraphQLField("paginationToken")
    )
    searchContext: "NamespaceSearchResultGraphQLField" = (
        NamespaceSearchResultGraphQLField("searchContext")
    )
    searchIndex: "NamespaceSearchResultGraphQLField" = (
        NamespaceSearchResultGraphQLField("searchIndex")
    )
    size: "NamespaceSearchResultGraphQLField" = NamespaceSearchResultGraphQLField(
        "size"
    )
    totalCount: "NamespaceSearchResultGraphQLField" = NamespaceSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            NamespaceSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NamespaceSearchDocumentFields",
            "NodeInterface",
        ]
    ) -> "NamespaceSearchResultFields":
        """Subfields should come from the NamespaceSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceSearchResultFields":
        self._alias = alias
        return self


class NamespaceSummaryFields(GraphQLField):
    @classmethod
    def branchAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("branchAssets", arguments=cleared_arguments)

    @classmethod
    def branchAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[PersonConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "PersonConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("branchAuthors", arguments=cleared_arguments)

    @classmethod
    def branchChildNamespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields(
            "branchChildNamespaces", arguments=cleared_arguments
        )

    id: "NamespaceSummaryGraphQLField" = NamespaceSummaryGraphQLField("id")

    def fields(
        self,
        *subfields: Union[
            NamespaceSummaryGraphQLField,
            "EntityConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "NamespaceSummaryFields":
        """Subfields should come from the NamespaceSummaryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceSummaryFields":
        self._alias = alias
        return self


class NamespaceTypeDetailFields(GraphQLField):
    @classmethod
    def savedQueries(
        cls,
        *,
        namespaceId: Optional[str] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "CustomSortableSavedLiveQueryFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "namespaceId": {"type": "ID", "value": namespaceId},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return CustomSortableSavedLiveQueryFields(
            "savedQueries", arguments=cleared_arguments
        )

    type: "NamespaceTypeDetailGraphQLField" = NamespaceTypeDetailGraphQLField("type")

    def fields(
        self,
        *subfields: Union[
            NamespaceTypeDetailGraphQLField, "CustomSortableSavedLiveQueryFields"
        ]
    ) -> "NamespaceTypeDetailFields":
        """Subfields should come from the NamespaceTypeDetailFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceTypeDetailFields":
        self._alias = alias
        return self


class NamespaceTypeDetailBaseInterface(GraphQLField):
    type: "NamespaceTypeDetailBaseGraphQLField" = NamespaceTypeDetailBaseGraphQLField(
        "type"
    )

    def fields(
        self, *subfields: NamespaceTypeDetailBaseGraphQLField
    ) -> "NamespaceTypeDetailBaseInterface":
        """Subfields should come from the NamespaceTypeDetailBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NamespaceTypeDetailBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "NamespaceTypeDetailBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class NodeInterface(GraphQLField):
    id: "NodeGraphQLField" = NodeGraphQLField("id")

    def fields(self, *subfields: NodeGraphQLField) -> "NodeInterface":
        """Subfields should come from the NodeInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NodeInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "NodeInterface":
        self._inline_fragments[type_name] = subfields
        return self


class NonProdFields(GraphQLField):
    @classmethod
    def datasetPatterns(cls) -> "DatasetPatternFields":
        return DatasetPatternFields("datasetPatterns")

    def fields(
        self, *subfields: Union[NonProdGraphQLField, "DatasetPatternFields"]
    ) -> "NonProdFields":
        """Subfields should come from the NonProdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NonProdFields":
        self._alias = alias
        return self


class OIDCFields(GraphQLField):
    signInRedirectUrl: "OIDCGraphQLField" = OIDCGraphQLField("signInRedirectUrl")

    def fields(self, *subfields: OIDCGraphQLField) -> "OIDCFields":
        """Subfields should come from the OIDCFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OIDCFields":
        self._alias = alias
        return self


class OktaSSOFields(GraphQLField):
    clientId: "OktaSSOGraphQLField" = OktaSSOGraphQLField("clientId")
    clientSecret: "OktaSSOGraphQLField" = OktaSSOGraphQLField("clientSecret")
    issuer: "OktaSSOGraphQLField" = OktaSSOGraphQLField("issuer")

    def fields(self, *subfields: OktaSSOGraphQLField) -> "OktaSSOFields":
        """Subfields should come from the OktaSSOFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OktaSSOFields":
        self._alias = alias
        return self


class OnboardingEmailFields(GraphQLField):
    emailType: "OnboardingEmailGraphQLField" = OnboardingEmailGraphQLField("emailType")
    hasBeenSent: "OnboardingEmailGraphQLField" = OnboardingEmailGraphQLField(
        "hasBeenSent"
    )

    def fields(
        self, *subfields: OnboardingEmailGraphQLField
    ) -> "OnboardingEmailFields":
        """Subfields should come from the OnboardingEmailFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OnboardingEmailFields":
        self._alias = alias
        return self


class OnboardingExperienceFields(GraphQLField):
    getStartedStepCompletions: "OnboardingExperienceGraphQLField" = (
        OnboardingExperienceGraphQLField("getStartedStepCompletions")
    )
    hasDismissedGetStartedSteps: "OnboardingExperienceGraphQLField" = (
        OnboardingExperienceGraphQLField("hasDismissedGetStartedSteps")
    )
    hasDismissedProfileCompletion: "OnboardingExperienceGraphQLField" = (
        OnboardingExperienceGraphQLField("hasDismissedProfileCompletion")
    )

    @classmethod
    def onboardingEmails(cls) -> "OnboardingEmailFields":
        return OnboardingEmailFields("onboardingEmails")

    profileCompletionSteps: "OnboardingExperienceGraphQLField" = (
        OnboardingExperienceGraphQLField("profileCompletionSteps")
    )

    def fields(
        self,
        *subfields: Union[OnboardingExperienceGraphQLField, "OnboardingEmailFields"]
    ) -> "OnboardingExperienceFields":
        """Subfields should come from the OnboardingExperienceFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OnboardingExperienceFields":
        self._alias = alias
        return self


class OrderedEntryFields(GraphQLField):
    id: "OrderedEntryGraphQLField" = OrderedEntryGraphQLField("id")

    @classmethod
    def orderedEntries(cls) -> "OrderedEntryFields":
        return OrderedEntryFields("orderedEntries")

    def fields(
        self, *subfields: Union[OrderedEntryGraphQLField, "OrderedEntryFields"]
    ) -> "OrderedEntryFields":
        """Subfields should come from the OrderedEntryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OrderedEntryFields":
        self._alias = alias
        return self


class OrganizationFields(GraphQLField):
    about: "OrganizationGraphQLField" = OrganizationGraphQLField("about")
    logoUrl: "OrganizationGraphQLField" = OrganizationGraphQLField("logoUrl")
    name: "OrganizationGraphQLField" = OrganizationGraphQLField("name")

    def fields(self, *subfields: OrganizationGraphQLField) -> "OrganizationFields":
        """Subfields should come from the OrganizationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OrganizationFields":
        self._alias = alias
        return self


class OverallDataQualityFields(GraphQLField):
    computedAt: "OverallDataQualityGraphQLField" = OverallDataQualityGraphQLField(
        "computedAt"
    )
    createdAt: "OverallDataQualityGraphQLField" = OverallDataQualityGraphQLField(
        "createdAt"
    )
    entityId: "OverallDataQualityGraphQLField" = OverallDataQualityGraphQLField(
        "entityId"
    )
    status: "OverallDataQualityGraphQLField" = OverallDataQualityGraphQLField("status")

    @classmethod
    def statusSources(cls) -> "DataQualityStatusSourceFields":
        return DataQualityStatusSourceFields("statusSources")

    def fields(
        self,
        *subfields: Union[
            OverallDataQualityGraphQLField, "DataQualityStatusSourceFields"
        ]
    ) -> "OverallDataQualityFields":
        """Subfields should come from the OverallDataQualityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OverallDataQualityFields":
        self._alias = alias
        return self


class PageInfoFields(GraphQLField):
    endCursor: "PageInfoGraphQLField" = PageInfoGraphQLField("endCursor")
    hasNextPage: "PageInfoGraphQLField" = PageInfoGraphQLField("hasNextPage")
    hasPreviousPage: "PageInfoGraphQLField" = PageInfoGraphQLField("hasPreviousPage")
    startCursor: "PageInfoGraphQLField" = PageInfoGraphQLField("startCursor")

    def fields(self, *subfields: PageInfoGraphQLField) -> "PageInfoFields":
        """Subfields should come from the PageInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PageInfoFields":
        self._alias = alias
        return self


class PersonFields(GraphQLField):
    @classmethod
    def activity(cls) -> "PersonActivityFields":
        return PersonActivityFields("activity")

    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "PersonGraphQLField" = PersonGraphQLField("createdAt")
    deletedAt: "PersonGraphQLField" = PersonGraphQLField("deletedAt")
    displayName: "PersonGraphQLField" = PersonGraphQLField("displayName")

    @classmethod
    def entitiesWithAuthoredKnowledgeCards(
        cls,
        entityTypes: EntityType,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "entityTypes": {"type": "EntityType!", "value": entityTypes},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields(
            "entitiesWithAuthoredKnowledgeCards", arguments=cleared_arguments
        )

    entityType: "PersonGraphQLField" = PersonGraphQLField("entityType")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def following(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        followedEntities: Optional[EntityType] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "followedEntities": {"type": "EntityType", "value": followedEntities},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("following", arguments=cleared_arguments)

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    @classmethod
    def hashtagsUsed(cls) -> "HashtagFields":
        return HashtagFields("hashtagsUsed")

    id: "PersonGraphQLField" = PersonGraphQLField("id")
    isDeleted: "PersonGraphQLField" = PersonGraphQLField("isDeleted")
    isViewer: "PersonGraphQLField" = PersonGraphQLField("isViewer")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledgeCardsAuthored(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledgeCardsAuthored", arguments=cleared_arguments
        )

    lastIngestedAt: "PersonGraphQLField" = PersonGraphQLField("lastIngestedAt")
    lastModifiedAt: "PersonGraphQLField" = PersonGraphQLField("lastModifiedAt")

    @classmethod
    def logicalId(cls) -> "PersonLogicalIdFields":
        return PersonLogicalIdFields("logicalId")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def organization(cls) -> "PersonOrganizationFields":
        return PersonOrganizationFields("organization")

    @classmethod
    def personalization(cls) -> "PersonalizationOptionsFields":
        return PersonalizationOptionsFields("personalization")

    @classmethod
    def pinnedAssets(cls) -> "PersonPinsFields":
        return PersonPinsFields("pinnedAssets")

    @classmethod
    def properties(cls) -> "PersonPropertiesFields":
        return PersonPropertiesFields("properties")

    @classmethod
    def queriedDatasets(cls) -> "DatasetFields":
        return DatasetFields("queriedDatasets")

    @classmethod
    def recentQueries(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[QueryInfoConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "QueryInfoConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "QueryInfoConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return QueryInfoConnectionFields("recentQueries", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def savedQueries(cls) -> "SavedLiveQueryFields":
        return SavedLiveQueryFields("savedQueries")

    @classmethod
    def slackProfile(cls) -> "PersonSlackProfileFields":
        return PersonSlackProfileFields("slackProfile")

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    viewerCanSendInvite: "PersonGraphQLField" = PersonGraphQLField(
        "viewerCanSendInvite"
    )

    def fields(
        self,
        *subfields: Union[
            PersonGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "DatasetFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonActivityFields",
            "PersonConnectionFields",
            "PersonLogicalIdFields",
            "PersonOrganizationFields",
            "PersonPinsFields",
            "PersonPropertiesFields",
            "PersonSlackProfileFields",
            "PersonalizationOptionsFields",
            "QueryInfoConnectionFields",
            "SavedLiveQueryFields",
        ]
    ) -> "PersonFields":
        """Subfields should come from the PersonFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonFields":
        self._alias = alias
        return self


class PersonActivityFields(GraphQLField):
    @classmethod
    def recentAISearches(cls) -> "AISearchQueryFields":
        return AISearchQueryFields("recentAISearches")

    @classmethod
    def recentSearches(cls) -> "SearchQueryFields":
        return SearchQueryFields("recentSearches")

    @classmethod
    def recentlyViewed(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        viewContext: Optional[SearchContext] = None
    ) -> "ViewActivityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "viewContext": {"type": "SearchContext", "value": viewContext},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewActivityConnectionFields(
            "recentlyViewed", arguments=cleared_arguments
        )

    def fields(
        self,
        *subfields: Union[
            PersonActivityGraphQLField,
            "AISearchQueryFields",
            "SearchQueryFields",
            "ViewActivityConnectionFields",
        ]
    ) -> "PersonActivityFields":
        """Subfields should come from the PersonActivityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonActivityFields":
        self._alias = alias
        return self


class PersonConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "PersonEdgeFields":
        return PersonEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "PersonConnectionGraphQLField" = PersonConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            PersonConnectionGraphQLField, "PageInfoFields", "PersonEdgeFields"
        ]
    ) -> "PersonConnectionFields":
        """Subfields should come from the PersonConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonConnectionFields":
        self._alias = alias
        return self


class PersonDetailsInterfaceInterface(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "PersonDetailsInterfaceGraphQLField" = (
        PersonDetailsInterfaceGraphQLField("createdAt")
    )
    deletedAt: "PersonDetailsInterfaceGraphQLField" = (
        PersonDetailsInterfaceGraphQLField("deletedAt")
    )
    displayName: "PersonDetailsInterfaceGraphQLField" = (
        PersonDetailsInterfaceGraphQLField("displayName")
    )
    entityType: "PersonDetailsInterfaceGraphQLField" = (
        PersonDetailsInterfaceGraphQLField("entityType")
    )

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "PersonDetailsInterfaceGraphQLField" = PersonDetailsInterfaceGraphQLField("id")
    isDeleted: "PersonDetailsInterfaceGraphQLField" = (
        PersonDetailsInterfaceGraphQLField("isDeleted")
    )

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    lastIngestedAt: "PersonDetailsInterfaceGraphQLField" = (
        PersonDetailsInterfaceGraphQLField("lastIngestedAt")
    )
    lastModifiedAt: "PersonDetailsInterfaceGraphQLField" = (
        PersonDetailsInterfaceGraphQLField("lastModifiedAt")
    )

    @classmethod
    def logicalId(cls) -> "PersonLogicalIdFields":
        return PersonLogicalIdFields("logicalId")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def organization(cls) -> "PersonOrganizationFields":
        return PersonOrganizationFields("organization")

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            PersonDetailsInterfaceGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "PersonLogicalIdFields",
            "PersonOrganizationFields",
        ]
    ) -> "PersonDetailsInterfaceInterface":
        """Subfields should come from the PersonDetailsInterfaceInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonDetailsInterfaceInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "PersonDetailsInterfaceInterface":
        self._inline_fragments[type_name] = subfields
        return self


class PersonEdgeFields(GraphQLField):
    cursor: "PersonEdgeGraphQLField" = PersonEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "PersonFields":
        return PersonFields("node")

    def fields(
        self, *subfields: Union[PersonEdgeGraphQLField, "PersonFields"]
    ) -> "PersonEdgeFields":
        """Subfields should come from the PersonEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonEdgeFields":
        self._alias = alias
        return self


class PersonHighlightFields(GraphQLField):
    contactDisplayNames: "PersonHighlightGraphQLField" = PersonHighlightGraphQLField(
        "contactDisplayNames"
    )
    email: "PersonHighlightGraphQLField" = PersonHighlightGraphQLField("email")
    governedTags: "PersonHighlightGraphQLField" = PersonHighlightGraphQLField(
        "governedTags"
    )
    hashtags: "PersonHighlightGraphQLField" = PersonHighlightGraphQLField("hashtags")
    name: "PersonHighlightGraphQLField" = PersonHighlightGraphQLField("name")

    def fields(
        self, *subfields: PersonHighlightGraphQLField
    ) -> "PersonHighlightFields":
        """Subfields should come from the PersonHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonHighlightFields":
        self._alias = alias
        return self


class PersonLogicalIdFields(GraphQLField):
    email: "PersonLogicalIdGraphQLField" = PersonLogicalIdGraphQLField("email")

    def fields(
        self, *subfields: PersonLogicalIdGraphQLField
    ) -> "PersonLogicalIdFields":
        """Subfields should come from the PersonLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonLogicalIdFields":
        self._alias = alias
        return self


class PersonOrganizationFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField(
        "createdAt"
    )
    department: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField(
        "department"
    )
    division: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField(
        "division"
    )
    employeeNumber: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField(
        "employeeNumber"
    )
    entityId: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField(
        "entityId"
    )
    groups: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField("groups")

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    manager: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField(
        "manager"
    )
    name: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField("name")
    title: "PersonOrganizationGraphQLField" = PersonOrganizationGraphQLField("title")

    def fields(
        self, *subfields: Union[PersonOrganizationGraphQLField, "AuditStampFields"]
    ) -> "PersonOrganizationFields":
        """Subfields should come from the PersonOrganizationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonOrganizationFields":
        self._alias = alias
        return self


class PersonPinsFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "PersonPinsGraphQLField" = PersonPinsGraphQLField("createdAt")
    entityId: "PersonPinsGraphQLField" = PersonPinsGraphQLField("entityId")

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    @classmethod
    def pins(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[PinsConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        types: Optional[EntityType] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "PinsConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "types": {"type": "EntityType", "value": types},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("pins", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            PersonPinsGraphQLField, "AuditStampFields", "EntityConnectionFields"
        ]
    ) -> "PersonPinsFields":
        """Subfields should come from the PersonPinsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonPinsFields":
        self._alias = alias
        return self


class PersonPinsPinningOutputFields(GraphQLField):
    @classmethod
    def pinnedOrUnpinned(cls) -> "EntityInterface":
        return EntityInterface("pinnedOrUnpinned")

    @classmethod
    def pinner(cls) -> "PersonFields":
        return PersonFields("pinner")

    def fields(
        self,
        *subfields: Union[
            PersonPinsPinningOutputGraphQLField, "EntityInterface", "PersonFields"
        ]
    ) -> "PersonPinsPinningOutputFields":
        """Subfields should come from the PersonPinsPinningOutputFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonPinsPinningOutputFields":
        self._alias = alias
        return self


class PersonPropertiesFields(GraphQLField):
    aboutMe: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField("aboutMe")
    avatarUrl: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "avatarUrl"
    )

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "createdAt"
    )
    displayName: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "displayName"
    )
    entityId: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField("entityId")
    firstName: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "firstName"
    )
    fullName: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField("fullName")
    issuer: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField("issuer")
    lastActive: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "lastActive"
    )
    lastLoggedIn: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "lastLoggedIn"
    )

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    lastName: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField("lastName")
    mobilePhone: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "mobilePhone"
    )
    occupation: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "occupation"
    )
    primaryPhone: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "primaryPhone"
    )
    providerName: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField(
        "providerName"
    )
    role: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField("role")
    status: "PersonPropertiesGraphQLField" = PersonPropertiesGraphQLField("status")

    def fields(
        self, *subfields: Union[PersonPropertiesGraphQLField, "AuditStampFields"]
    ) -> "PersonPropertiesFields":
        """Subfields should come from the PersonPropertiesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonPropertiesFields":
        self._alias = alias
        return self


class PersonSearchDocumentFields(GraphQLField):
    browsePathHierarchy: "PersonSearchDocumentGraphQLField" = (
        PersonSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browsePathSegments: "PersonSearchDocumentGraphQLField" = (
        PersonSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    contactDisplayNames: "PersonSearchDocumentGraphQLField" = (
        PersonSearchDocumentGraphQLField("contactDisplayNames")
    )
    department: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "department"
    )
    documentId: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "documentId"
    )
    email: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "email"
    )
    embeddedString_1: "PersonSearchDocumentGraphQLField" = (
        PersonSearchDocumentGraphQLField("embeddedString_1")
    )
    embeddedString_2: "PersonSearchDocumentGraphQLField" = (
        PersonSearchDocumentGraphQLField("embeddedString_2")
    )
    entityId: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "entityId"
    )
    governedTags: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "governedTags"
    )
    hashtags: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "hashtags"
    )

    @classmethod
    def highlight(cls) -> "PersonHighlightFields":
        return PersonHighlightFields("highlight")

    isDeleted: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "isDeleted"
    )
    lastRefreshed: "PersonSearchDocumentGraphQLField" = (
        PersonSearchDocumentGraphQLField("lastRefreshed")
    )
    name: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField("name")
    paginationToken: "PersonSearchDocumentGraphQLField" = (
        PersonSearchDocumentGraphQLField("paginationToken")
    )

    @classmethod
    def scoreDetails(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("scoreDetails")

    skills: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "skills"
    )
    title: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "title"
    )
    viewCount: "PersonSearchDocumentGraphQLField" = PersonSearchDocumentGraphQLField(
        "viewCount"
    )

    def fields(
        self,
        *subfields: Union[
            PersonSearchDocumentGraphQLField,
            "BrowsePathFields",
            "PersonHighlightFields",
            "SearchScoreDetailsFields",
        ]
    ) -> "PersonSearchDocumentFields":
        """Subfields should come from the PersonSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonSearchDocumentFields":
        self._alias = alias
        return self


class PersonSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "PersonSearchDocumentFields":
        return PersonSearchDocumentFields("documents")

    errorMessage: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField(
        "errorMessage"
    )
    from_: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField("from")
    hasMore: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField(
        "paginationToken"
    )
    searchContext: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField(
        "searchContext"
    )
    searchIndex: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField(
        "searchIndex"
    )
    size: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField("size")
    totalCount: "PersonSearchResultGraphQLField" = PersonSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            PersonSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "PersonSearchDocumentFields",
        ]
    ) -> "PersonSearchResultFields":
        """Subfields should come from the PersonSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonSearchResultFields":
        self._alias = alias
        return self


class PersonSlackProfileFields(GraphQLField):
    createdAt: "PersonSlackProfileGraphQLField" = PersonSlackProfileGraphQLField(
        "createdAt"
    )
    deleted: "PersonSlackProfileGraphQLField" = PersonSlackProfileGraphQLField(
        "deleted"
    )
    entityId: "PersonSlackProfileGraphQLField" = PersonSlackProfileGraphQLField(
        "entityId"
    )
    realName: "PersonSlackProfileGraphQLField" = PersonSlackProfileGraphQLField(
        "realName"
    )
    slackId: "PersonSlackProfileGraphQLField" = PersonSlackProfileGraphQLField(
        "slackId"
    )
    teamId: "PersonSlackProfileGraphQLField" = PersonSlackProfileGraphQLField("teamId")
    username: "PersonSlackProfileGraphQLField" = PersonSlackProfileGraphQLField(
        "username"
    )

    def fields(
        self, *subfields: PersonSlackProfileGraphQLField
    ) -> "PersonSlackProfileFields":
        """Subfields should come from the PersonSlackProfileFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonSlackProfileFields":
        self._alias = alias
        return self


class PersonalizationOptionsFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "PersonalizationOptionsGraphQLField" = (
        PersonalizationOptionsGraphQLField("createdAt")
    )
    entityId: "PersonalizationOptionsGraphQLField" = PersonalizationOptionsGraphQLField(
        "entityId"
    )

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    @classmethod
    def onboarding(cls) -> "OnboardingExperienceFields":
        return OnboardingExperienceFields("onboarding")

    persona: "PersonalizationOptionsGraphQLField" = PersonalizationOptionsGraphQLField(
        "persona"
    )

    def fields(
        self,
        *subfields: Union[
            PersonalizationOptionsGraphQLField,
            "AuditStampFields",
            "OnboardingExperienceFields",
        ]
    ) -> "PersonalizationOptionsFields":
        """Subfields should come from the PersonalizationOptionsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonalizationOptionsFields":
        self._alias = alias
        return self


class PersonalizationOptionsBaseInterface(GraphQLField):
    createdAt: "PersonalizationOptionsBaseGraphQLField" = (
        PersonalizationOptionsBaseGraphQLField("createdAt")
    )
    entityId: "PersonalizationOptionsBaseGraphQLField" = (
        PersonalizationOptionsBaseGraphQLField("entityId")
    )

    def fields(
        self, *subfields: PersonalizationOptionsBaseGraphQLField
    ) -> "PersonalizationOptionsBaseInterface":
        """Subfields should come from the PersonalizationOptionsBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonalizationOptionsBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "PersonalizationOptionsBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class PersonalizationTraitInterface(GraphQLField):
    @classmethod
    def activity(cls) -> "PersonActivityFields":
        return PersonActivityFields("activity")

    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "PersonalizationTraitGraphQLField" = PersonalizationTraitGraphQLField(
        "createdAt"
    )
    deletedAt: "PersonalizationTraitGraphQLField" = PersonalizationTraitGraphQLField(
        "deletedAt"
    )
    displayName: "PersonalizationTraitGraphQLField" = PersonalizationTraitGraphQLField(
        "displayName"
    )
    entityType: "PersonalizationTraitGraphQLField" = PersonalizationTraitGraphQLField(
        "entityType"
    )

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "PersonalizationTraitGraphQLField" = PersonalizationTraitGraphQLField("id")
    isDeleted: "PersonalizationTraitGraphQLField" = PersonalizationTraitGraphQLField(
        "isDeleted"
    )

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    lastIngestedAt: "PersonalizationTraitGraphQLField" = (
        PersonalizationTraitGraphQLField("lastIngestedAt")
    )
    lastModifiedAt: "PersonalizationTraitGraphQLField" = (
        PersonalizationTraitGraphQLField("lastModifiedAt")
    )

    @classmethod
    def logicalId(cls) -> "PersonLogicalIdFields":
        return PersonLogicalIdFields("logicalId")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def organization(cls) -> "PersonOrganizationFields":
        return PersonOrganizationFields("organization")

    @classmethod
    def personalization(cls) -> "PersonalizationOptionsFields":
        return PersonalizationOptionsFields("personalization")

    @classmethod
    def properties(cls) -> "PersonPropertiesFields":
        return PersonPropertiesFields("properties")

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def savedQueries(cls) -> "SavedLiveQueryFields":
        return SavedLiveQueryFields("savedQueries")

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            PersonalizationTraitGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonActivityFields",
            "PersonConnectionFields",
            "PersonLogicalIdFields",
            "PersonOrganizationFields",
            "PersonPropertiesFields",
            "PersonalizationOptionsFields",
            "SavedLiveQueryFields",
        ]
    ) -> "PersonalizationTraitInterface":
        """Subfields should come from the PersonalizationTraitInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PersonalizationTraitInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "PersonalizationTraitInterface":
        self._inline_fragments[type_name] = subfields
        return self


class PipelineFields(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def azureDataFactoryPipeline(cls) -> "AzureDataFactoryPipelineFields":
        return AzureDataFactoryPipelineFields("azureDataFactoryPipeline")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "PipelineGraphQLField" = PipelineGraphQLField("createdAt")
    deletedAt: "PipelineGraphQLField" = PipelineGraphQLField("deletedAt")
    displayName: "PipelineGraphQLField" = PipelineGraphQLField("displayName")
    entityType: "PipelineGraphQLField" = PipelineGraphQLField("entityType")

    @classmethod
    def fivetran(cls) -> "FivetranPipelineFields":
        return FivetranPipelineFields("fivetran")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def forceShown(cls) -> "AuditStampFields":
        return AuditStampFields("forceShown")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "PipelineGraphQLField" = PipelineGraphQLField("id")

    @classmethod
    def informaticaMapping(cls) -> "InformaticaMappingFields":
        return InformaticaMappingFields("informaticaMapping")

    isComplete: "PipelineGraphQLField" = PipelineGraphQLField("isComplete")
    isDeleted: "PipelineGraphQLField" = PipelineGraphQLField("isDeleted")
    isProduction: "PipelineGraphQLField" = PipelineGraphQLField("isProduction")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    lastIngestedAt: "PipelineGraphQLField" = PipelineGraphQLField("lastIngestedAt")
    lastModifiedAt: "PipelineGraphQLField" = PipelineGraphQLField("lastModifiedAt")

    @classmethod
    def logicalId(cls) -> "PipelineLogicalIdFields":
        return PipelineLogicalIdFields("logicalId")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def powerBiDataflow(cls) -> "PowerBIDataflowFields":
        return PowerBIDataflowFields("powerBiDataflow")

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def sourceInfo(cls) -> "SourceInfoFields":
        return SourceInfoFields("sourceInfo")

    @classmethod
    def spark(cls) -> "SparkJobFields":
        return SparkJobFields("spark")

    @classmethod
    def structure(cls) -> "AssetStructureFields":
        return AssetStructureFields("structure")

    @classmethod
    def systemContacts(cls) -> "SystemContactsFields":
        return SystemContactsFields("systemContacts")

    @classmethod
    def systemDescription(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("systemDescription")

    systemTagValues: "PipelineGraphQLField" = PipelineGraphQLField("systemTagValues")

    @classmethod
    def systemTags(cls) -> "SystemTagsFields":
        return SystemTagsFields("systemTags")

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            PipelineGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "AssetStructureFields",
            "AuditStampFields",
            "AzureDataFactoryPipelineFields",
            "BrowsePathFields",
            "EntityConnectionFields",
            "FivetranPipelineFields",
            "HashtagFields",
            "InformaticaMappingFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "PipelineLogicalIdFields",
            "PowerBIDataflowFields",
            "SourceInfoFields",
            "SparkJobFields",
            "SystemContactsFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
        ]
    ) -> "PipelineFields":
        """Subfields should come from the PipelineFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineFields":
        self._alias = alias
        return self


class PipelineHighlightFields(GraphQLField):
    contactDisplayNames: "PipelineHighlightGraphQLField" = (
        PipelineHighlightGraphQLField("contactDisplayNames")
    )
    description: "PipelineHighlightGraphQLField" = PipelineHighlightGraphQLField(
        "description"
    )
    governedTags: "PipelineHighlightGraphQLField" = PipelineHighlightGraphQLField(
        "governedTags"
    )
    hashtags: "PipelineHighlightGraphQLField" = PipelineHighlightGraphQLField(
        "hashtags"
    )
    name: "PipelineHighlightGraphQLField" = PipelineHighlightGraphQLField("name")
    pipelineId: "PipelineHighlightGraphQLField" = PipelineHighlightGraphQLField(
        "pipelineId"
    )

    def fields(
        self, *subfields: PipelineHighlightGraphQLField
    ) -> "PipelineHighlightFields":
        """Subfields should come from the PipelineHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineHighlightFields":
        self._alias = alias
        return self


class PipelineInfoFields(GraphQLField):
    createdAt: "PipelineInfoGraphQLField" = PipelineInfoGraphQLField("createdAt")
    entityId: "PipelineInfoGraphQLField" = PipelineInfoGraphQLField("entityId")

    @classmethod
    def pipelineMapping(cls) -> "PipelineMappingFields":
        return PipelineMappingFields("pipelineMapping")

    def fields(
        self, *subfields: Union[PipelineInfoGraphQLField, "PipelineMappingFields"]
    ) -> "PipelineInfoFields":
        """Subfields should come from the PipelineInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineInfoFields":
        self._alias = alias
        return self


class PipelineLogicalIdFields(GraphQLField):
    name: "PipelineLogicalIdGraphQLField" = PipelineLogicalIdGraphQLField("name")
    type: "PipelineLogicalIdGraphQLField" = PipelineLogicalIdGraphQLField("type")

    def fields(
        self, *subfields: PipelineLogicalIdGraphQLField
    ) -> "PipelineLogicalIdFields":
        """Subfields should come from the PipelineLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineLogicalIdFields":
        self._alias = alias
        return self


class PipelineMappingFields(GraphQLField):
    isVirtual: "PipelineMappingGraphQLField" = PipelineMappingGraphQLField("isVirtual")

    @classmethod
    def pipeline(cls) -> "PipelineFields":
        return PipelineFields("pipeline")

    pipelineEntityId: "PipelineMappingGraphQLField" = PipelineMappingGraphQLField(
        "pipelineEntityId"
    )
    sourceEntityId: "PipelineMappingGraphQLField" = PipelineMappingGraphQLField(
        "sourceEntityId"
    )

    def fields(
        self, *subfields: Union[PipelineMappingGraphQLField, "PipelineFields"]
    ) -> "PipelineMappingFields":
        """Subfields should come from the PipelineMappingFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineMappingFields":
        self._alias = alias
        return self


class PipelineSearchDocumentFields(GraphQLField):
    browsePathHierarchy: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browsePathSegments: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    contactDisplayNames: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("contactDisplayNames")
    )
    description: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("description")
    )
    documentId: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("documentId")
    )
    domainDisplayNames: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("domainDisplayNames")
    )
    domains: "PipelineSearchDocumentGraphQLField" = PipelineSearchDocumentGraphQLField(
        "domains"
    )
    embeddedString_1: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("embeddedString_1")
    )
    embeddedString_2: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("embeddedString_2")
    )
    entityId: "PipelineSearchDocumentGraphQLField" = PipelineSearchDocumentGraphQLField(
        "entityId"
    )
    governedTags: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("governedTags")
    )
    hasColumnLineage: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("hasColumnLineage")
    )
    hasTableLineage: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("hasTableLineage")
    )
    hashtags: "PipelineSearchDocumentGraphQLField" = PipelineSearchDocumentGraphQLField(
        "hashtags"
    )

    @classmethod
    def highlight(cls) -> "PipelineHighlightFields":
        return PipelineHighlightFields("highlight")

    isComplete: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("isComplete")
    )
    isDeleted: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("isDeleted")
    )
    isProduction: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("isProduction")
    )
    knowledgeCardCount: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("knowledgeCardCount")
    )
    lastRefreshed: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("lastRefreshed")
    )
    name: "PipelineSearchDocumentGraphQLField" = PipelineSearchDocumentGraphQLField(
        "name"
    )
    overallDataQuality: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("overallDataQuality")
    )
    paginationToken: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("paginationToken")
    )
    pipelineId: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("pipelineId")
    )

    @classmethod
    def scoreDetails(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("scoreDetails")

    type: "PipelineSearchDocumentGraphQLField" = PipelineSearchDocumentGraphQLField(
        "type"
    )
    viewCount: "PipelineSearchDocumentGraphQLField" = (
        PipelineSearchDocumentGraphQLField("viewCount")
    )

    def fields(
        self,
        *subfields: Union[
            PipelineSearchDocumentGraphQLField,
            "BrowsePathFields",
            "PipelineHighlightFields",
            "SearchScoreDetailsFields",
        ]
    ) -> "PipelineSearchDocumentFields":
        """Subfields should come from the PipelineSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineSearchDocumentFields":
        self._alias = alias
        return self


class PipelineSearchInfoFields(GraphQLField):
    pipelineId: "PipelineSearchInfoGraphQLField" = PipelineSearchInfoGraphQLField(
        "pipelineId"
    )

    def fields(
        self, *subfields: PipelineSearchInfoGraphQLField
    ) -> "PipelineSearchInfoFields":
        """Subfields should come from the PipelineSearchInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineSearchInfoFields":
        self._alias = alias
        return self


class PipelineSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "PipelineSearchDocumentFields":
        return PipelineSearchDocumentFields("documents")

    errorMessage: "PipelineSearchResultGraphQLField" = PipelineSearchResultGraphQLField(
        "errorMessage"
    )
    from_: "PipelineSearchResultGraphQLField" = PipelineSearchResultGraphQLField("from")
    hasMore: "PipelineSearchResultGraphQLField" = PipelineSearchResultGraphQLField(
        "hasMore"
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "PipelineSearchResultGraphQLField" = (
        PipelineSearchResultGraphQLField("paginationToken")
    )
    searchContext: "PipelineSearchResultGraphQLField" = (
        PipelineSearchResultGraphQLField("searchContext")
    )
    searchIndex: "PipelineSearchResultGraphQLField" = PipelineSearchResultGraphQLField(
        "searchIndex"
    )
    size: "PipelineSearchResultGraphQLField" = PipelineSearchResultGraphQLField("size")
    totalCount: "PipelineSearchResultGraphQLField" = PipelineSearchResultGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            PipelineSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "PipelineSearchDocumentFields",
        ]
    ) -> "PipelineSearchResultFields":
        """Subfields should come from the PipelineSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PipelineSearchResultFields":
        self._alias = alias
        return self


class PowerBIColumnFields(GraphQLField):
    field: "PowerBIColumnGraphQLField" = PowerBIColumnGraphQLField("field")
    type: "PowerBIColumnGraphQLField" = PowerBIColumnGraphQLField("type")

    def fields(self, *subfields: PowerBIColumnGraphQLField) -> "PowerBIColumnFields":
        """Subfields should come from the PowerBIColumnFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIColumnFields":
        self._alias = alias
        return self


class PowerBIDataflowFields(GraphQLField):
    configuredBy: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField(
        "configuredBy"
    )
    dataflowUrl: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField(
        "dataflowUrl"
    )
    description: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField(
        "description"
    )
    document: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField("document")
    lastRefreshed: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField(
        "lastRefreshed"
    )
    modifiedBy: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField(
        "modifiedBy"
    )
    modifiedDateTime: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField(
        "modifiedDateTime"
    )
    name: "PowerBIDataflowGraphQLField" = PowerBIDataflowGraphQLField("name")

    @classmethod
    def refreshSchedule(cls) -> "PowerBIRefreshScheduleFields":
        return PowerBIRefreshScheduleFields("refreshSchedule")

    def fields(
        self,
        *subfields: Union[PowerBIDataflowGraphQLField, "PowerBIRefreshScheduleFields"]
    ) -> "PowerBIDataflowFields":
        """Subfields should come from the PowerBIDataflowFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIDataflowFields":
        self._alias = alias
        return self


class PowerBIDatasetFields(GraphQLField):
    configuredBy: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField(
        "configuredBy"
    )
    createdAt: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField("createdAt")
    createdDate: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField(
        "createdDate"
    )
    description: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField(
        "description"
    )

    @classmethod
    def downstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstreamOfType", arguments=cleared_arguments
        )

    @classmethod
    def endorsement(cls) -> "PowerBiEndorsementFields":
        return PowerBiEndorsementFields("endorsement")

    entityId: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField("entityId")

    @classmethod
    def fieldCrowdSourcedDescriptions(
        cls, *, filters: Optional[KnowledgeCardConnectionFilterInput] = None
    ) -> "KnowledgeCardFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardFields(
            "fieldCrowdSourcedDescriptions", arguments=cleared_arguments
        )

    lastRefreshed: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField(
        "lastRefreshed"
    )
    name: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField("name")

    @classmethod
    def parameters(cls) -> "PowerBIDatasetParameterFields":
        return PowerBIDatasetParameterFields("parameters")

    @classmethod
    def refreshSchedule(cls) -> "PowerBIRefreshScheduleFields":
        return PowerBIRefreshScheduleFields("refreshSchedule")

    @classmethod
    def sensitivityLabel(cls) -> "PowerBiSensitivityLabelFields":
        return PowerBiSensitivityLabelFields("sensitivityLabel")

    sourceDatasets: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField(
        "sourceDatasets"
    )

    @classmethod
    def tables(cls) -> "PowerBIDatasetTableFields":
        return PowerBIDatasetTableFields("tables")

    @classmethod
    def upstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstreamOfType", arguments=cleared_arguments
        )

    url: "PowerBIDatasetGraphQLField" = PowerBIDatasetGraphQLField("url")

    @classmethod
    def viewerCanAddFieldDescriptionFor(
        cls, tableName: str, *, fieldPaths: Optional[str] = None
    ) -> "FieldPathPermissionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "fieldPaths": {"type": "String", "value": fieldPaths},
            "tableName": {"type": "String!", "value": tableName},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FieldPathPermissionFields(
            "viewerCanAddFieldDescriptionFor", arguments=cleared_arguments
        )

    @classmethod
    def workspace(cls) -> "PowerBiWorkspaceFields":
        return PowerBiWorkspaceFields("workspace")

    def fields(
        self,
        *subfields: Union[
            PowerBIDatasetGraphQLField,
            "EntityLineageConnectionFields",
            "FieldPathPermissionFields",
            "KnowledgeCardFields",
            "PowerBIDatasetParameterFields",
            "PowerBIDatasetTableFields",
            "PowerBIRefreshScheduleFields",
            "PowerBiEndorsementFields",
            "PowerBiSensitivityLabelFields",
            "PowerBiWorkspaceFields",
        ]
    ) -> "PowerBIDatasetFields":
        """Subfields should come from the PowerBIDatasetFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIDatasetFields":
        self._alias = alias
        return self


class PowerBIDatasetParameterFields(GraphQLField):
    isRequired: "PowerBIDatasetParameterGraphQLField" = (
        PowerBIDatasetParameterGraphQLField("isRequired")
    )
    name: "PowerBIDatasetParameterGraphQLField" = PowerBIDatasetParameterGraphQLField(
        "name"
    )
    type: "PowerBIDatasetParameterGraphQLField" = PowerBIDatasetParameterGraphQLField(
        "type"
    )
    value: "PowerBIDatasetParameterGraphQLField" = PowerBIDatasetParameterGraphQLField(
        "value"
    )

    def fields(
        self, *subfields: PowerBIDatasetParameterGraphQLField
    ) -> "PowerBIDatasetParameterFields":
        """Subfields should come from the PowerBIDatasetParameterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIDatasetParameterFields":
        self._alias = alias
        return self


class PowerBIDatasetSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "VirtualViewSearchDocumentFields":
        return VirtualViewSearchDocumentFields("documents")

    errorMessage: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("errorMessage")
    )
    from_: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("from")
    )
    hasMore: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("paginationToken")
    )
    searchContext: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("searchContext")
    )
    searchIndex: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("searchIndex")
    )
    size: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("size")
    )
    totalCount: "PowerBIDatasetSearchResultGraphQLField" = (
        PowerBIDatasetSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            PowerBIDatasetSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "VirtualViewSearchDocumentFields",
        ]
    ) -> "PowerBIDatasetSearchResultFields":
        """Subfields should come from the PowerBIDatasetSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIDatasetSearchResultFields":
        self._alias = alias
        return self


class PowerBIDatasetTableFields(GraphQLField):
    @classmethod
    def columns(cls) -> "PowerBIColumnFields":
        return PowerBIColumnFields("columns")

    expression: "PowerBIDatasetTableGraphQLField" = PowerBIDatasetTableGraphQLField(
        "expression"
    )

    @classmethod
    def measures(cls) -> "PowerBIMeasureFields":
        return PowerBIMeasureFields("measures")

    name: "PowerBIDatasetTableGraphQLField" = PowerBIDatasetTableGraphQLField("name")
    sources: "PowerBIDatasetTableGraphQLField" = PowerBIDatasetTableGraphQLField(
        "sources"
    )

    def fields(
        self,
        *subfields: Union[
            PowerBIDatasetTableGraphQLField,
            "PowerBIColumnFields",
            "PowerBIMeasureFields",
        ]
    ) -> "PowerBIDatasetTableFields":
        """Subfields should come from the PowerBIDatasetTableFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIDatasetTableFields":
        self._alias = alias
        return self


class PowerBIMeasureFields(GraphQLField):
    description: "PowerBIMeasureGraphQLField" = PowerBIMeasureGraphQLField(
        "description"
    )
    expression: "PowerBIMeasureGraphQLField" = PowerBIMeasureGraphQLField("expression")
    field: "PowerBIMeasureGraphQLField" = PowerBIMeasureGraphQLField("field")

    def fields(self, *subfields: PowerBIMeasureGraphQLField) -> "PowerBIMeasureFields":
        """Subfields should come from the PowerBIMeasureFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIMeasureFields":
        self._alias = alias
        return self


class PowerBIRefreshScheduleFields(GraphQLField):
    days: "PowerBIRefreshScheduleGraphQLField" = PowerBIRefreshScheduleGraphQLField(
        "days"
    )
    enabled: "PowerBIRefreshScheduleGraphQLField" = PowerBIRefreshScheduleGraphQLField(
        "enabled"
    )
    frequencyInMinutes: "PowerBIRefreshScheduleGraphQLField" = (
        PowerBIRefreshScheduleGraphQLField("frequencyInMinutes")
    )
    localTimeZoneId: "PowerBIRefreshScheduleGraphQLField" = (
        PowerBIRefreshScheduleGraphQLField("localTimeZoneId")
    )
    notifyOption: "PowerBIRefreshScheduleGraphQLField" = (
        PowerBIRefreshScheduleGraphQLField("notifyOption")
    )
    times: "PowerBIRefreshScheduleGraphQLField" = PowerBIRefreshScheduleGraphQLField(
        "times"
    )

    def fields(
        self, *subfields: PowerBIRefreshScheduleGraphQLField
    ) -> "PowerBIRefreshScheduleFields":
        """Subfields should come from the PowerBIRefreshScheduleFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBIRefreshScheduleFields":
        self._alias = alias
        return self


class PowerBiAppFields(GraphQLField):
    id: "PowerBiAppGraphQLField" = PowerBiAppGraphQLField("id")
    name: "PowerBiAppGraphQLField" = PowerBiAppGraphQLField("name")

    def fields(self, *subfields: PowerBiAppGraphQLField) -> "PowerBiAppFields":
        """Subfields should come from the PowerBiAppFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiAppFields":
        self._alias = alias
        return self


class PowerBiEndorsementFields(GraphQLField):
    certifiedBy: "PowerBiEndorsementGraphQLField" = PowerBiEndorsementGraphQLField(
        "certifiedBy"
    )
    endorsement: "PowerBiEndorsementGraphQLField" = PowerBiEndorsementGraphQLField(
        "endorsement"
    )

    def fields(
        self, *subfields: PowerBiEndorsementGraphQLField
    ) -> "PowerBiEndorsementFields":
        """Subfields should come from the PowerBiEndorsementFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiEndorsementFields":
        self._alias = alias
        return self


class PowerBiInfoFields(GraphQLField):
    @classmethod
    def app(cls) -> "PowerBiAppFields":
        return PowerBiAppFields("app")

    createdBy: "PowerBiInfoGraphQLField" = PowerBiInfoGraphQLField("createdBy")
    createdDateTime: "PowerBiInfoGraphQLField" = PowerBiInfoGraphQLField(
        "createdDateTime"
    )

    @classmethod
    def endorsement(cls) -> "PowerBiEndorsementFields":
        return PowerBiEndorsementFields("endorsement")

    modifiedBy: "PowerBiInfoGraphQLField" = PowerBiInfoGraphQLField("modifiedBy")
    modifiedDateTime: "PowerBiInfoGraphQLField" = PowerBiInfoGraphQLField(
        "modifiedDateTime"
    )
    powerBiDashboardType: "PowerBiInfoGraphQLField" = PowerBiInfoGraphQLField(
        "powerBiDashboardType"
    )

    @classmethod
    def sensitivityLabel(cls) -> "PowerBiSensitivityLabelFields":
        return PowerBiSensitivityLabelFields("sensitivityLabel")

    @classmethod
    def subscriptions(cls) -> "PowerBiSubscriptionFields":
        return PowerBiSubscriptionFields("subscriptions")

    @classmethod
    def workspace(cls) -> "PowerBiWorkspaceFields":
        return PowerBiWorkspaceFields("workspace")

    def fields(
        self,
        *subfields: Union[
            PowerBiInfoGraphQLField,
            "PowerBiAppFields",
            "PowerBiEndorsementFields",
            "PowerBiSensitivityLabelFields",
            "PowerBiSubscriptionFields",
            "PowerBiWorkspaceFields",
        ]
    ) -> "PowerBiInfoFields":
        """Subfields should come from the PowerBiInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiInfoFields":
        self._alias = alias
        return self


class PowerBiSensitivityLabelFields(GraphQLField):
    description: "PowerBiSensitivityLabelGraphQLField" = (
        PowerBiSensitivityLabelGraphQLField("description")
    )
    id: "PowerBiSensitivityLabelGraphQLField" = PowerBiSensitivityLabelGraphQLField(
        "id"
    )
    name: "PowerBiSensitivityLabelGraphQLField" = PowerBiSensitivityLabelGraphQLField(
        "name"
    )

    def fields(
        self, *subfields: PowerBiSensitivityLabelGraphQLField
    ) -> "PowerBiSensitivityLabelFields":
        """Subfields should come from the PowerBiSensitivityLabelFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiSensitivityLabelFields":
        self._alias = alias
        return self


class PowerBiSubscriptionFields(GraphQLField):
    artifactDisplayName: "PowerBiSubscriptionGraphQLField" = (
        PowerBiSubscriptionGraphQLField("artifactDisplayName")
    )
    endDate: "PowerBiSubscriptionGraphQLField" = PowerBiSubscriptionGraphQLField(
        "endDate"
    )
    frequency: "PowerBiSubscriptionGraphQLField" = PowerBiSubscriptionGraphQLField(
        "frequency"
    )
    id: "PowerBiSubscriptionGraphQLField" = PowerBiSubscriptionGraphQLField("id")
    startDate: "PowerBiSubscriptionGraphQLField" = PowerBiSubscriptionGraphQLField(
        "startDate"
    )
    subArtifactDisplayName: "PowerBiSubscriptionGraphQLField" = (
        PowerBiSubscriptionGraphQLField("subArtifactDisplayName")
    )
    title: "PowerBiSubscriptionGraphQLField" = PowerBiSubscriptionGraphQLField("title")

    @classmethod
    def users(cls) -> "PowerBiSubscriptionUserFields":
        return PowerBiSubscriptionUserFields("users")

    def fields(
        self,
        *subfields: Union[
            PowerBiSubscriptionGraphQLField, "PowerBiSubscriptionUserFields"
        ]
    ) -> "PowerBiSubscriptionFields":
        """Subfields should come from the PowerBiSubscriptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiSubscriptionFields":
        self._alias = alias
        return self


class PowerBiSubscriptionUserFields(GraphQLField):
    displayName: "PowerBiSubscriptionUserGraphQLField" = (
        PowerBiSubscriptionUserGraphQLField("displayName")
    )
    emailAddress: "PowerBiSubscriptionUserGraphQLField" = (
        PowerBiSubscriptionUserGraphQLField("emailAddress")
    )

    def fields(
        self, *subfields: PowerBiSubscriptionUserGraphQLField
    ) -> "PowerBiSubscriptionUserFields":
        """Subfields should come from the PowerBiSubscriptionUserFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiSubscriptionUserFields":
        self._alias = alias
        return self


class PowerBiUserInterface(GraphQLField):
    displayName: "PowerBiUserGraphQLField" = PowerBiUserGraphQLField("displayName")
    emailAddress: "PowerBiUserGraphQLField" = PowerBiUserGraphQLField("emailAddress")

    def fields(self, *subfields: PowerBiUserGraphQLField) -> "PowerBiUserInterface":
        """Subfields should come from the PowerBiUserInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiUserInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "PowerBiUserInterface":
        self._inline_fragments[type_name] = subfields
        return self


class PowerBiWorkspaceFields(GraphQLField):
    name: "PowerBiWorkspaceGraphQLField" = PowerBiWorkspaceGraphQLField("name")
    url: "PowerBiWorkspaceGraphQLField" = PowerBiWorkspaceGraphQLField("url")

    @classmethod
    def users(cls) -> "PowerBiWorkspaceUserFields":
        return PowerBiWorkspaceUserFields("users")

    def fields(
        self,
        *subfields: Union[PowerBiWorkspaceGraphQLField, "PowerBiWorkspaceUserFields"]
    ) -> "PowerBiWorkspaceFields":
        """Subfields should come from the PowerBiWorkspaceFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiWorkspaceFields":
        self._alias = alias
        return self


class PowerBiWorkspaceUserFields(GraphQLField):
    displayName: "PowerBiWorkspaceUserGraphQLField" = PowerBiWorkspaceUserGraphQLField(
        "displayName"
    )
    emailAddress: "PowerBiWorkspaceUserGraphQLField" = PowerBiWorkspaceUserGraphQLField(
        "emailAddress"
    )
    groupUserAccessRight: "PowerBiWorkspaceUserGraphQLField" = (
        PowerBiWorkspaceUserGraphQLField("groupUserAccessRight")
    )

    def fields(
        self, *subfields: PowerBiWorkspaceUserGraphQLField
    ) -> "PowerBiWorkspaceUserFields":
        """Subfields should come from the PowerBiWorkspaceUserFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PowerBiWorkspaceUserFields":
        self._alias = alias
        return self


class PurgeDataQualityFields(GraphQLField):
    enabled: "PurgeDataQualityGraphQLField" = PurgeDataQualityGraphQLField("enabled")
    thresholdHours: "PurgeDataQualityGraphQLField" = PurgeDataQualityGraphQLField(
        "thresholdHours"
    )

    def fields(
        self, *subfields: PurgeDataQualityGraphQLField
    ) -> "PurgeDataQualityFields":
        """Subfields should come from the PurgeDataQualityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PurgeDataQualityFields":
        self._alias = alias
        return self


class QueryCountFields(GraphQLField):
    count: "QueryCountGraphQLField" = QueryCountGraphQLField("count")
    level: "QueryCountGraphQLField" = QueryCountGraphQLField("level")
    percentile: "QueryCountGraphQLField" = QueryCountGraphQLField("percentile")

    def fields(self, *subfields: QueryCountGraphQLField) -> "QueryCountFields":
        """Subfields should come from the QueryCountFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryCountFields":
        self._alias = alias
        return self


class QueryCountPercentileFields(GraphQLField):
    last7Days: "QueryCountPercentileGraphQLField" = QueryCountPercentileGraphQLField(
        "last7Days"
    )
    last24Hours: "QueryCountPercentileGraphQLField" = QueryCountPercentileGraphQLField(
        "last24Hours"
    )
    last30Days: "QueryCountPercentileGraphQLField" = QueryCountPercentileGraphQLField(
        "last30Days"
    )
    last90Days: "QueryCountPercentileGraphQLField" = QueryCountPercentileGraphQLField(
        "last90Days"
    )
    last365Days: "QueryCountPercentileGraphQLField" = QueryCountPercentileGraphQLField(
        "last365Days"
    )

    def fields(
        self, *subfields: QueryCountPercentileGraphQLField
    ) -> "QueryCountPercentileFields":
        """Subfields should come from the QueryCountPercentileFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryCountPercentileFields":
        self._alias = alias
        return self


class QueryCountsFields(GraphQLField):
    @classmethod
    def last7Days(cls) -> "QueryCountFields":
        return QueryCountFields("last7Days")

    @classmethod
    def last24Hours(cls) -> "QueryCountFields":
        return QueryCountFields("last24Hours")

    @classmethod
    def last30Days(cls) -> "QueryCountFields":
        return QueryCountFields("last30Days")

    @classmethod
    def last90Days(cls) -> "QueryCountFields":
        return QueryCountFields("last90Days")

    @classmethod
    def last365Days(cls) -> "QueryCountFields":
        return QueryCountFields("last365Days")

    def fields(
        self, *subfields: Union[QueryCountsGraphQLField, "QueryCountFields"]
    ) -> "QueryCountsFields":
        """Subfields should come from the QueryCountsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryCountsFields":
        self._alias = alias
        return self


class QueryExplainerFields(GraphQLField):
    explanation: "QueryExplainerGraphQLField" = QueryExplainerGraphQLField(
        "explanation"
    )
    explanationId: "QueryExplainerGraphQLField" = QueryExplainerGraphQLField(
        "explanationId"
    )

    @classmethod
    def tokenizedContent(cls) -> "QueryExplainerTokenizedContentFields":
        return QueryExplainerTokenizedContentFields("tokenizedContent")

    type: "QueryExplainerGraphQLField" = QueryExplainerGraphQLField("type")

    def fields(
        self,
        *subfields: Union[
            QueryExplainerGraphQLField, "QueryExplainerTokenizedContentFields"
        ]
    ) -> "QueryExplainerFields":
        """Subfields should come from the QueryExplainerFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryExplainerFields":
        self._alias = alias
        return self


class QueryExplainerTokenizedContentFields(GraphQLField):
    explanation: "QueryExplainerTokenizedContentGraphQLField" = (
        QueryExplainerTokenizedContentGraphQLField("explanation")
    )

    def fields(
        self, *subfields: QueryExplainerTokenizedContentGraphQLField
    ) -> "QueryExplainerTokenizedContentFields":
        """Subfields should come from the QueryExplainerTokenizedContentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryExplainerTokenizedContentFields":
        self._alias = alias
        return self


class QueryInfoFields(GraphQLField):
    bytesRead: "QueryInfoGraphQLField" = QueryInfoGraphQLField("bytesRead")
    bytesWritten: "QueryInfoGraphQLField" = QueryInfoGraphQLField("bytesWritten")
    cost: "QueryInfoGraphQLField" = QueryInfoGraphQLField("cost")
    elapsedTime: "QueryInfoGraphQLField" = QueryInfoGraphQLField("elapsedTime")
    entityIds: "QueryInfoGraphQLField" = QueryInfoGraphQLField("entityIds")
    id: "QueryInfoGraphQLField" = QueryInfoGraphQLField("id")
    issuedAt: "QueryInfoGraphQLField" = QueryInfoGraphQLField("issuedAt")
    issuedBy: "QueryInfoGraphQLField" = QueryInfoGraphQLField("issuedBy")
    issuedByEmail: "QueryInfoGraphQLField" = QueryInfoGraphQLField("issuedByEmail")

    @classmethod
    def issuedToAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("issuedToAssets", arguments=cleared_arguments)

    platform: "QueryInfoGraphQLField" = QueryInfoGraphQLField("platform")
    query: "QueryInfoGraphQLField" = QueryInfoGraphQLField("query")

    @classmethod
    def queryDescription(cls) -> "KnowledgeCardFields":
        return KnowledgeCardFields("queryDescription")

    @classmethod
    def queryDescriptions(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "queryDescriptions", arguments=cleared_arguments
        )

    rowsRead: "QueryInfoGraphQLField" = QueryInfoGraphQLField("rowsRead")
    rowsWritten: "QueryInfoGraphQLField" = QueryInfoGraphQLField("rowsWritten")
    runCount: "QueryInfoGraphQLField" = QueryInfoGraphQLField("runCount")

    def fields(
        self,
        *subfields: Union[
            QueryInfoGraphQLField,
            "EntityConnectionFields",
            "KnowledgeCardConnectionFields",
            "KnowledgeCardFields",
        ]
    ) -> "QueryInfoFields":
        """Subfields should come from the QueryInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryInfoFields":
        self._alias = alias
        return self


class QueryInfoConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "QueryInfoEdgeFields":
        return QueryInfoEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "QueryInfoConnectionGraphQLField" = QueryInfoConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            QueryInfoConnectionGraphQLField, "PageInfoFields", "QueryInfoEdgeFields"
        ]
    ) -> "QueryInfoConnectionFields":
        """Subfields should come from the QueryInfoConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryInfoConnectionFields":
        self._alias = alias
        return self


class QueryInfoEdgeFields(GraphQLField):
    cursor: "QueryInfoEdgeGraphQLField" = QueryInfoEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "QueryInfoFields":
        return QueryInfoFields("node")

    def fields(
        self, *subfields: Union[QueryInfoEdgeGraphQLField, "QueryInfoFields"]
    ) -> "QueryInfoEdgeFields":
        """Subfields should come from the QueryInfoEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryInfoEdgeFields":
        self._alias = alias
        return self


class QueryKnowledgeCardFields(GraphQLField):
    @classmethod
    def explanations(cls) -> "QueryExplainerFields":
        return QueryExplainerFields("explanations")

    isGenerated: "QueryKnowledgeCardGraphQLField" = QueryKnowledgeCardGraphQLField(
        "isGenerated"
    )
    isMarkedAsCurated: "QueryKnowledgeCardGraphQLField" = (
        QueryKnowledgeCardGraphQLField("isMarkedAsCurated")
    )
    isSameAsOriginalQuery: "QueryKnowledgeCardGraphQLField" = (
        QueryKnowledgeCardGraphQLField("isSameAsOriginalQuery")
    )
    parsedStatement: "QueryKnowledgeCardGraphQLField" = QueryKnowledgeCardGraphQLField(
        "parsedStatement"
    )
    query: "QueryKnowledgeCardGraphQLField" = QueryKnowledgeCardGraphQLField("query")
    queryId: "QueryKnowledgeCardGraphQLField" = QueryKnowledgeCardGraphQLField(
        "queryId"
    )

    @classmethod
    def queryInfo(cls) -> "QueryInfoFields":
        return QueryInfoFields("queryInfo")

    @classmethod
    def queryInfoCopy(cls) -> "QueryInfoFields":
        return QueryInfoFields("queryInfoCopy")

    title: "QueryKnowledgeCardGraphQLField" = QueryKnowledgeCardGraphQLField("title")

    def fields(
        self,
        *subfields: Union[
            QueryKnowledgeCardGraphQLField, "QueryExplainerFields", "QueryInfoFields"
        ]
    ) -> "QueryKnowledgeCardFields":
        """Subfields should come from the QueryKnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryKnowledgeCardFields":
        self._alias = alias
        return self


class QueryResultFields(GraphQLField):
    columns: "QueryResultGraphQLField" = QueryResultGraphQLField("columns")
    hasMore: "QueryResultGraphQLField" = QueryResultGraphQLField("hasMore")

    @classmethod
    def rows(cls) -> "ResultRowFields":
        return ResultRowFields("rows")

    def fields(
        self, *subfields: Union[QueryResultGraphQLField, "ResultRowFields"]
    ) -> "QueryResultFields":
        """Subfields should come from the QueryResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryResultFields":
        self._alias = alias
        return self


class QuickSightDatasetSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "VirtualViewSearchDocumentFields":
        return VirtualViewSearchDocumentFields("documents")

    errorMessage: "QuickSightDatasetSearchResultGraphQLField" = (
        QuickSightDatasetSearchResultGraphQLField("errorMessage")
    )
    from_: "QuickSightDatasetSearchResultGraphQLField" = (
        QuickSightDatasetSearchResultGraphQLField("from")
    )
    hasMore: "QuickSightDatasetSearchResultGraphQLField" = (
        QuickSightDatasetSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "QuickSightDatasetSearchResultGraphQLField" = (
        QuickSightDatasetSearchResultGraphQLField("paginationToken")
    )
    searchContext: "QuickSightDatasetSearchResultGraphQLField" = (
        QuickSightDatasetSearchResultGraphQLField("searchContext")
    )
    searchIndex: "QuickSightDatasetSearchResultGraphQLField" = (
        QuickSightDatasetSearchResultGraphQLField("searchIndex")
    )
    size: "QuickSightDatasetSearchResultGraphQLField" = (
        QuickSightDatasetSearchResultGraphQLField("size")
    )
    totalCount: "QuickSightDatasetSearchResultGraphQLField" = (
        QuickSightDatasetSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            QuickSightDatasetSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "VirtualViewSearchDocumentFields",
        ]
    ) -> "QuickSightDatasetSearchResultFields":
        """Subfields should come from the QuickSightDatasetSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QuickSightDatasetSearchResultFields":
        self._alias = alias
        return self


class RecentUserActivitiesFields(GraphQLField):
    @classmethod
    def actors(cls) -> "UserActivityActorInfoFields":
        return UserActivityActorInfoFields("actors")

    @classmethod
    def aggregatedActivities(cls) -> "UserActivityFields":
        return UserActivityFields("aggregatedActivities")

    def fields(
        self,
        *subfields: Union[
            RecentUserActivitiesGraphQLField,
            "UserActivityActorInfoFields",
            "UserActivityFields",
        ]
    ) -> "RecentUserActivitiesFields":
        """Subfields should come from the RecentUserActivitiesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "RecentUserActivitiesFields":
        self._alias = alias
        return self


class ResultRowFields(GraphQLField):
    rowId: "ResultRowGraphQLField" = ResultRowGraphQLField("rowId")
    values: "ResultRowGraphQLField" = ResultRowGraphQLField("values")

    def fields(self, *subfields: ResultRowGraphQLField) -> "ResultRowFields":
        """Subfields should come from the ResultRowFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ResultRowFields":
        self._alias = alias
        return self


class RunCrawlerResponseFields(GraphQLField):
    errorMessage: "RunCrawlerResponseGraphQLField" = RunCrawlerResponseGraphQLField(
        "errorMessage"
    )
    success: "RunCrawlerResponseGraphQLField" = RunCrawlerResponseGraphQLField(
        "success"
    )

    def fields(
        self, *subfields: RunCrawlerResponseGraphQLField
    ) -> "RunCrawlerResponseFields":
        """Subfields should come from the RunCrawlerResponseFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "RunCrawlerResponseFields":
        self._alias = alias
        return self


class SAMLFields(GraphQLField):
    entityId: "SAMLGraphQLField" = SAMLGraphQLField("entityId")
    replyACSUrl: "SAMLGraphQLField" = SAMLGraphQLField("replyACSUrl")
    signOnUrl: "SAMLGraphQLField" = SAMLGraphQLField("signOnUrl")

    def fields(self, *subfields: SAMLGraphQLField) -> "SAMLFields":
        """Subfields should come from the SAMLFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SAMLFields":
        self._alias = alias
        return self


class SQLExplainerResultFields(GraphQLField):
    businessSummary: "SQLExplainerResultGraphQLField" = SQLExplainerResultGraphQLField(
        "businessSummary"
    )
    technicalSummary: "SQLExplainerResultGraphQLField" = SQLExplainerResultGraphQLField(
        "technicalSummary"
    )
    title: "SQLExplainerResultGraphQLField" = SQLExplainerResultGraphQLField("title")

    def fields(
        self, *subfields: SQLExplainerResultGraphQLField
    ) -> "SQLExplainerResultFields":
        """Subfields should come from the SQLExplainerResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SQLExplainerResultFields":
        self._alias = alias
        return self


class SSOFields(GraphQLField):
    @classmethod
    def azureAd(cls) -> "AzureAdSSOFields":
        return AzureAdSSOFields("azureAd")

    @classmethod
    def googleWorkspace(cls) -> "GoogleWorkspaceSSOFields":
        return GoogleWorkspaceSSOFields("googleWorkspace")

    @classmethod
    def ldap(cls) -> "LDAPFields":
        return LDAPFields("ldap")

    @classmethod
    def okta(cls) -> "OktaSSOFields":
        return OktaSSOFields("okta")

    def fields(
        self,
        *subfields: Union[
            SSOGraphQLField,
            "AzureAdSSOFields",
            "GoogleWorkspaceSSOFields",
            "LDAPFields",
            "OktaSSOFields",
        ]
    ) -> "SSOFields":
        """Subfields should come from the SSOFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SSOFields":
        self._alias = alias
        return self


class SampleSearchQuestionFields(GraphQLField):
    question: "SampleSearchQuestionGraphQLField" = SampleSearchQuestionGraphQLField(
        "question"
    )
    response: "SampleSearchQuestionGraphQLField" = SampleSearchQuestionGraphQLField(
        "response"
    )

    @classmethod
    def sourceAssets(cls) -> "EntityConnectionFields":
        return EntityConnectionFields("sourceAssets")

    def fields(
        self,
        *subfields: Union[SampleSearchQuestionGraphQLField, "EntityConnectionFields"]
    ) -> "SampleSearchQuestionFields":
        """Subfields should come from the SampleSearchQuestionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SampleSearchQuestionFields":
        self._alias = alias
        return self


class SavedLiveQueryFields(GraphQLField):
    context: "SavedLiveQueryGraphQLField" = SavedLiveQueryGraphQLField("context")

    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    facetsJSON: "SavedLiveQueryGraphQLField" = SavedLiveQueryGraphQLField("facetsJSON")
    id: "SavedLiveQueryGraphQLField" = SavedLiveQueryGraphQLField("id")
    keyword: "SavedLiveQueryGraphQLField" = SavedLiveQueryGraphQLField("keyword")

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    name: "SavedLiveQueryGraphQLField" = SavedLiveQueryGraphQLField("name")

    def fields(
        self, *subfields: Union[SavedLiveQueryGraphQLField, "AuditStampFields"]
    ) -> "SavedLiveQueryFields":
        """Subfields should come from the SavedLiveQueryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SavedLiveQueryFields":
        self._alias = alias
        return self


class SchemaFieldFields(GraphQLField):
    description: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("description")
    fieldName: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("fieldName")
    fieldPath: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("fieldPath")
    isUnique: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("isUnique")
    maxLength: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("maxLength")
    nativeType: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("nativeType")
    nullable: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("nullable")
    precision: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("precision")

    @classmethod
    def subfields(cls) -> "SchemaFieldFields":
        return SchemaFieldFields("subfields")

    tags: "SchemaFieldGraphQLField" = SchemaFieldGraphQLField("tags")

    def fields(
        self, *subfields: Union[SchemaFieldGraphQLField, "SchemaFieldFields"]
    ) -> "SchemaFieldFields":
        """Subfields should come from the SchemaFieldFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SchemaFieldFields":
        self._alias = alias
        return self


class SchemaFieldWithCommonAttributesFields(GraphQLField):
    @classmethod
    def assetContacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("assetContacts")

    @classmethod
    def description(cls) -> "UserDefinedResourceDescriptionFields":
        return UserDefinedResourceDescriptionFields("description")

    fieldPath: "SchemaFieldWithCommonAttributesGraphQLField" = (
        SchemaFieldWithCommonAttributesGraphQLField("fieldPath")
    )

    @classmethod
    def governedTags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governedTags", arguments=cleared_arguments
        )

    def fields(
        self,
        *subfields: Union[
            SchemaFieldWithCommonAttributesGraphQLField,
            "AssetContactsFields",
            "UserDefinedResourceConnectionFields",
            "UserDefinedResourceDescriptionFields",
        ]
    ) -> "SchemaFieldWithCommonAttributesFields":
        """Subfields should come from the SchemaFieldWithCommonAttributesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SchemaFieldWithCommonAttributesFields":
        self._alias = alias
        return self


class SearchQueryFields(GraphQLField):
    context: "SearchQueryGraphQLField" = SearchQueryGraphQLField("context")
    facetsJSON: "SearchQueryGraphQLField" = SearchQueryGraphQLField("facetsJSON")
    id: "SearchQueryGraphQLField" = SearchQueryGraphQLField("id")
    keyword: "SearchQueryGraphQLField" = SearchQueryGraphQLField("keyword")
    name: "SearchQueryGraphQLField" = SearchQueryGraphQLField("name")

    def fields(self, *subfields: SearchQueryGraphQLField) -> "SearchQueryFields":
        """Subfields should come from the SearchQueryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SearchQueryFields":
        self._alias = alias
        return self


class SearchScoreDetailsFields(GraphQLField):
    description: "SearchScoreDetailsGraphQLField" = SearchScoreDetailsGraphQLField(
        "description"
    )

    @classmethod
    def details(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("details")

    value: "SearchScoreDetailsGraphQLField" = SearchScoreDetailsGraphQLField("value")

    def fields(
        self,
        *subfields: Union[SearchScoreDetailsGraphQLField, "SearchScoreDetailsFields"]
    ) -> "SearchScoreDetailsFields":
        """Subfields should come from the SearchScoreDetailsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SearchScoreDetailsFields":
        self._alias = alias
        return self


class SearchStatisticsResultFields(GraphQLField):
    errorMessage: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("errorMessage")
    )
    hasColumnLineage: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("hasColumnLineage")
    )
    hasContact: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("hasContact")
    )
    hasDescription: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("hasDescription")
    )
    hasGovernedTag: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("hasGovernedTag")
    )
    hasTableLineage: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("hasTableLineage")
    )
    searchContext: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("searchContext")
    )
    searchIndex: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("searchIndex")
    )
    totalCount: "SearchStatisticsResultGraphQLField" = (
        SearchStatisticsResultGraphQLField("totalCount")
    )

    def fields(
        self, *subfields: SearchStatisticsResultGraphQLField
    ) -> "SearchStatisticsResultFields":
        """Subfields should come from the SearchStatisticsResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SearchStatisticsResultFields":
        self._alias = alias
        return self


class SettingsFields(GraphQLField):
    @classmethod
    def authorization(cls) -> "AuthorizationFields":
        return AuthorizationFields("authorization")

    @classmethod
    def customMetadataConfig(cls) -> "CustomMetadataConfigFields":
        return CustomMetadataConfigFields("customMetadataConfig")

    @classmethod
    def customUserDefinedOrderHierarchy(cls) -> "UserSpecifiedOrderingFields":
        return UserSpecifiedOrderingFields("customUserDefinedOrderHierarchy")

    @classmethod
    def hardDeletion(cls) -> "HardDeletionFields":
        return HardDeletionFields("hardDeletion")

    @classmethod
    def nonProd(cls) -> "NonProdFields":
        return NonProdFields("nonProd")

    @classmethod
    def organization(cls) -> "OrganizationFields":
        return OrganizationFields("organization")

    @classmethod
    def purgeDataQuality(cls) -> "PurgeDataQualityFields":
        return PurgeDataQualityFields("purgeDataQuality")

    serviceAccounts: "SettingsGraphQLField" = SettingsGraphQLField("serviceAccounts")

    @classmethod
    def socialLogin(cls) -> "SocialLoginFields":
        return SocialLoginFields("socialLogin")

    @classmethod
    def softDeletion(cls) -> "SoftDeletionFields":
        return SoftDeletionFields("softDeletion")

    @classmethod
    def sso(cls) -> "SSOFields":
        return SSOFields("sso")

    def fields(
        self,
        *subfields: Union[
            SettingsGraphQLField,
            "AuthorizationFields",
            "CustomMetadataConfigFields",
            "HardDeletionFields",
            "NonProdFields",
            "OrganizationFields",
            "PurgeDataQualityFields",
            "SSOFields",
            "SocialLoginFields",
            "SoftDeletionFields",
            "UserSpecifiedOrderingFields",
        ]
    ) -> "SettingsFields":
        """Subfields should come from the SettingsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SettingsFields":
        self._alias = alias
        return self


class SetupInfoFields(GraphQLField):
    crawlerIpAddresses: "SetupInfoGraphQLField" = SetupInfoGraphQLField(
        "crawlerIpAddresses"
    )

    @classmethod
    def oidc(cls) -> "OIDCFields":
        return OIDCFields("oidc")

    @classmethod
    def saml(cls) -> "SAMLFields":
        return SAMLFields("saml")

    def fields(
        self, *subfields: Union[SetupInfoGraphQLField, "OIDCFields", "SAMLFields"]
    ) -> "SetupInfoFields":
        """Subfields should come from the SetupInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SetupInfoFields":
        self._alias = alias
        return self


class SimilarAssetsResultItemFields(GraphQLField):
    @classmethod
    def dataset(cls) -> "DatasetFields":
        return DatasetFields("dataset")

    entityId: "SimilarAssetsResultItemGraphQLField" = (
        SimilarAssetsResultItemGraphQLField("entityId")
    )
    schemaSimilarity: "SimilarAssetsResultItemGraphQLField" = (
        SimilarAssetsResultItemGraphQLField("schemaSimilarity")
    )
    vectorSimilarity: "SimilarAssetsResultItemGraphQLField" = (
        SimilarAssetsResultItemGraphQLField("vectorSimilarity")
    )

    def fields(
        self, *subfields: Union[SimilarAssetsResultItemGraphQLField, "DatasetFields"]
    ) -> "SimilarAssetsResultItemFields":
        """Subfields should come from the SimilarAssetsResultItemFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SimilarAssetsResultItemFields":
        self._alias = alias
        return self


class SnowflakeStreamInfoFields(GraphQLField):
    createdAt: "SnowflakeStreamInfoGraphQLField" = SnowflakeStreamInfoGraphQLField(
        "createdAt"
    )
    entityId: "SnowflakeStreamInfoGraphQLField" = SnowflakeStreamInfoGraphQLField(
        "entityId"
    )
    sourceType: "SnowflakeStreamInfoGraphQLField" = SnowflakeStreamInfoGraphQLField(
        "sourceType"
    )
    stale: "SnowflakeStreamInfoGraphQLField" = SnowflakeStreamInfoGraphQLField("stale")
    staleAfter: "SnowflakeStreamInfoGraphQLField" = SnowflakeStreamInfoGraphQLField(
        "staleAfter"
    )
    streamType: "SnowflakeStreamInfoGraphQLField" = SnowflakeStreamInfoGraphQLField(
        "streamType"
    )

    def fields(
        self, *subfields: SnowflakeStreamInfoGraphQLField
    ) -> "SnowflakeStreamInfoFields":
        """Subfields should come from the SnowflakeStreamInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SnowflakeStreamInfoFields":
        self._alias = alias
        return self


class SocialLoginFields(GraphQLField):
    @classmethod
    def google(cls) -> "GoogleSocialLoginFields":
        return GoogleSocialLoginFields("google")

    @classmethod
    def linkedIn(cls) -> "LinkedInSocialLoginFields":
        return LinkedInSocialLoginFields("linkedIn")

    @classmethod
    def microsoft(cls) -> "MicrosoftSocialLoginFields":
        return MicrosoftSocialLoginFields("microsoft")

    def fields(
        self,
        *subfields: Union[
            SocialLoginGraphQLField,
            "GoogleSocialLoginFields",
            "LinkedInSocialLoginFields",
            "MicrosoftSocialLoginFields",
        ]
    ) -> "SocialLoginFields":
        """Subfields should come from the SocialLoginFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SocialLoginFields":
        self._alias = alias
        return self


class SoftDeletionFields(GraphQLField):
    enabled: "SoftDeletionGraphQLField" = SoftDeletionGraphQLField("enabled")
    thresholdHours: "SoftDeletionGraphQLField" = SoftDeletionGraphQLField(
        "thresholdHours"
    )

    def fields(self, *subfields: SoftDeletionGraphQLField) -> "SoftDeletionFields":
        """Subfields should come from the SoftDeletionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SoftDeletionFields":
        self._alias = alias
        return self


class SourceFieldFields(GraphQLField):
    @classmethod
    def dataset(cls) -> "DatasetLogicalIdFields":
        return DatasetLogicalIdFields("dataset")

    field: "SourceFieldGraphQLField" = SourceFieldGraphQLField("field")
    sourceEntityId: "SourceFieldGraphQLField" = SourceFieldGraphQLField(
        "sourceEntityId"
    )

    def fields(
        self, *subfields: Union[SourceFieldGraphQLField, "DatasetLogicalIdFields"]
    ) -> "SourceFieldFields":
        """Subfields should come from the SourceFieldFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SourceFieldFields":
        self._alias = alias
        return self


class SourceInfoFields(GraphQLField):
    createdAt: "SourceInfoGraphQLField" = SourceInfoGraphQLField("createdAt")
    createdAtSource: "SourceInfoGraphQLField" = SourceInfoGraphQLField(
        "createdAtSource"
    )
    createdBy: "SourceInfoGraphQLField" = SourceInfoGraphQLField("createdBy")
    entityId: "SourceInfoGraphQLField" = SourceInfoGraphQLField("entityId")
    lastUpdated: "SourceInfoGraphQLField" = SourceInfoGraphQLField("lastUpdated")
    mainUrl: "SourceInfoGraphQLField" = SourceInfoGraphQLField("mainUrl")
    updatedBy: "SourceInfoGraphQLField" = SourceInfoGraphQLField("updatedBy")

    def fields(self, *subfields: SourceInfoGraphQLField) -> "SourceInfoFields":
        """Subfields should come from the SourceInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SourceInfoFields":
        self._alias = alias
        return self


class SparkJobFields(GraphQLField):
    description: "SparkJobGraphQLField" = SparkJobGraphQLField("description")
    sourceCodeUrl: "SparkJobGraphQLField" = SparkJobGraphQLField("sourceCodeUrl")
    sql: "SparkJobGraphQLField" = SparkJobGraphQLField("sql")

    def fields(self, *subfields: SparkJobGraphQLField) -> "SparkJobFields":
        """Subfields should come from the SparkJobFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SparkJobFields":
        self._alias = alias
        return self


class SqlSchemaFields(GraphQLField):
    @classmethod
    def foreignKey(cls) -> "ForeignKeyFields":
        return ForeignKeyFields("foreignKey")

    materialization: "SqlSchemaGraphQLField" = SqlSchemaGraphQLField("materialization")
    primaryKey: "SqlSchemaGraphQLField" = SqlSchemaGraphQLField("primaryKey")
    snapshotTime: "SqlSchemaGraphQLField" = SqlSchemaGraphQLField("snapshotTime")
    tableSchema: "SqlSchemaGraphQLField" = SqlSchemaGraphQLField("tableSchema")

    def fields(
        self, *subfields: Union[SqlSchemaGraphQLField, "ForeignKeyFields"]
    ) -> "SqlSchemaFields":
        """Subfields should come from the SqlSchemaFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SqlSchemaFields":
        self._alias = alias
        return self


class StatusFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    status: "StatusGraphQLField" = StatusGraphQLField("status")

    def fields(
        self, *subfields: Union[StatusGraphQLField, "AuditStampFields"]
    ) -> "StatusFields":
        """Subfields should come from the StatusFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StatusFields":
        self._alias = alias
        return self


class SuggestItemFields(GraphQLField):
    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    entityId: "SuggestItemGraphQLField" = SuggestItemGraphQLField("entityId")
    entityType: "SuggestItemGraphQLField" = SuggestItemGraphQLField("entityType")
    index: "SuggestItemGraphQLField" = SuggestItemGraphQLField("index")
    logicalId: "LogicalIdUnion" = LogicalIdUnion("logicalId")
    nativeType: "SuggestItemGraphQLField" = SuggestItemGraphQLField("nativeType")
    score: "SuggestItemGraphQLField" = SuggestItemGraphQLField("score")
    searchContext: "SuggestItemGraphQLField" = SuggestItemGraphQLField("searchContext")
    text: "SuggestItemGraphQLField" = SuggestItemGraphQLField("text")

    def fields(
        self,
        *subfields: Union[SuggestItemGraphQLField, "BrowsePathFields", "LogicalIdUnion"]
    ) -> "SuggestItemFields":
        """Subfields should come from the SuggestItemFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SuggestItemFields":
        self._alias = alias
        return self


class SuggestResultFields(GraphQLField):
    @classmethod
    def results(cls) -> "SuggestItemFields":
        return SuggestItemFields("results")

    totalCount: "SuggestResultGraphQLField" = SuggestResultGraphQLField("totalCount")

    def fields(
        self, *subfields: Union[SuggestResultGraphQLField, "SuggestItemFields"]
    ) -> "SuggestResultFields":
        """Subfields should come from the SuggestResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SuggestResultFields":
        self._alias = alias
        return self


class SystemContactFields(GraphQLField):
    email: "SystemContactGraphQLField" = SystemContactGraphQLField("email")
    systemContactSource: "SystemContactGraphQLField" = SystemContactGraphQLField(
        "systemContactSource"
    )

    def fields(self, *subfields: SystemContactGraphQLField) -> "SystemContactFields":
        """Subfields should come from the SystemContactFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemContactFields":
        self._alias = alias
        return self


class SystemContactsFields(GraphQLField):
    @classmethod
    def contacts(cls) -> "SystemContactFields":
        return SystemContactFields("contacts")

    createdAt: "SystemContactsGraphQLField" = SystemContactsGraphQLField("createdAt")
    entityId: "SystemContactsGraphQLField" = SystemContactsGraphQLField("entityId")

    def fields(
        self, *subfields: Union[SystemContactsGraphQLField, "SystemContactFields"]
    ) -> "SystemContactsFields":
        """Subfields should come from the SystemContactsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemContactsFields":
        self._alias = alias
        return self


class SystemDescriptionFields(GraphQLField):
    createdAt: "SystemDescriptionGraphQLField" = SystemDescriptionGraphQLField(
        "createdAt"
    )
    description: "SystemDescriptionGraphQLField" = SystemDescriptionGraphQLField(
        "description"
    )
    entityId: "SystemDescriptionGraphQLField" = SystemDescriptionGraphQLField(
        "entityId"
    )
    platform: "SystemDescriptionGraphQLField" = SystemDescriptionGraphQLField(
        "platform"
    )

    def fields(
        self, *subfields: SystemDescriptionGraphQLField
    ) -> "SystemDescriptionFields":
        """Subfields should come from the SystemDescriptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemDescriptionFields":
        self._alias = alias
        return self


class SystemTagFields(GraphQLField):
    key: "SystemTagGraphQLField" = SystemTagGraphQLField("key")
    systemTagSource: "SystemTagGraphQLField" = SystemTagGraphQLField("systemTagSource")
    value: "SystemTagGraphQLField" = SystemTagGraphQLField("value")

    def fields(self, *subfields: SystemTagGraphQLField) -> "SystemTagFields":
        """Subfields should come from the SystemTagFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemTagFields":
        self._alias = alias
        return self


class SystemTagCountsFields(GraphQLField):
    description: "SystemTagCountsGraphQLField" = SystemTagCountsGraphQLField(
        "description"
    )

    @classmethod
    def entityCounts(cls) -> "EntityCountFields":
        return EntityCountFields("entityCounts")

    id: "SystemTagCountsGraphQLField" = SystemTagCountsGraphQLField("id")
    key: "SystemTagCountsGraphQLField" = SystemTagCountsGraphQLField("key")
    source: "SystemTagCountsGraphQLField" = SystemTagCountsGraphQLField("source")
    value: "SystemTagCountsGraphQLField" = SystemTagCountsGraphQLField("value")

    def fields(
        self, *subfields: Union[SystemTagCountsGraphQLField, "EntityCountFields"]
    ) -> "SystemTagCountsFields":
        """Subfields should come from the SystemTagCountsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemTagCountsFields":
        self._alias = alias
        return self


class SystemTagCountsConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "SystemTagCountsEdgeFields":
        return SystemTagCountsEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "SystemTagCountsConnectionGraphQLField" = (
        SystemTagCountsConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            SystemTagCountsConnectionGraphQLField,
            "PageInfoFields",
            "SystemTagCountsEdgeFields",
        ]
    ) -> "SystemTagCountsConnectionFields":
        """Subfields should come from the SystemTagCountsConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemTagCountsConnectionFields":
        self._alias = alias
        return self


class SystemTagCountsEdgeFields(GraphQLField):
    cursor: "SystemTagCountsEdgeGraphQLField" = SystemTagCountsEdgeGraphQLField(
        "cursor"
    )

    @classmethod
    def node(cls) -> "SystemTagCountsFields":
        return SystemTagCountsFields("node")

    def fields(
        self,
        *subfields: Union[SystemTagCountsEdgeGraphQLField, "SystemTagCountsFields"]
    ) -> "SystemTagCountsEdgeFields":
        """Subfields should come from the SystemTagCountsEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemTagCountsEdgeFields":
        self._alias = alias
        return self


class SystemTagSourcesFields(GraphQLField):
    sources: "SystemTagSourcesGraphQLField" = SystemTagSourcesGraphQLField("sources")

    def fields(
        self, *subfields: SystemTagSourcesGraphQLField
    ) -> "SystemTagSourcesFields":
        """Subfields should come from the SystemTagSourcesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemTagSourcesFields":
        self._alias = alias
        return self


class SystemTagsFields(GraphQLField):
    createdAt: "SystemTagsGraphQLField" = SystemTagsGraphQLField("createdAt")
    entityId: "SystemTagsGraphQLField" = SystemTagsGraphQLField("entityId")

    @classmethod
    def tags(cls) -> "SystemTagFields":
        return SystemTagFields("tags")

    def fields(
        self, *subfields: Union[SystemTagsGraphQLField, "SystemTagFields"]
    ) -> "SystemTagsFields":
        """Subfields should come from the SystemTagsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemTagsFields":
        self._alias = alias
        return self


class TableColumnsUsageFields(GraphQLField):
    columns: "TableColumnsUsageGraphQLField" = TableColumnsUsageGraphQLField("columns")
    count: "TableColumnsUsageGraphQLField" = TableColumnsUsageGraphQLField("count")

    def fields(
        self, *subfields: TableColumnsUsageGraphQLField
    ) -> "TableColumnsUsageFields":
        """Subfields should come from the TableColumnsUsageFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TableColumnsUsageFields":
        self._alias = alias
        return self


class TableJoinFields(GraphQLField):
    @classmethod
    def scenarios(cls) -> "TableJoinScenarioFields":
        return TableJoinScenarioFields("scenarios")

    totalJoinCount: "TableJoinGraphQLField" = TableJoinGraphQLField("totalJoinCount")

    def fields(
        self, *subfields: Union[TableJoinGraphQLField, "TableJoinScenarioFields"]
    ) -> "TableJoinFields":
        """Subfields should come from the TableJoinFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TableJoinFields":
        self._alias = alias
        return self


class TableJoinScenarioFields(GraphQLField):
    count: "TableJoinScenarioGraphQLField" = TableJoinScenarioGraphQLField("count")
    datasets: "TableJoinScenarioGraphQLField" = TableJoinScenarioGraphQLField(
        "datasets"
    )

    @classmethod
    def filteringColumns(cls) -> "TableColumnsUsageFields":
        return TableColumnsUsageFields("filteringColumns")

    @classmethod
    def joiningColumns(cls) -> "TableColumnsUsageFields":
        return TableColumnsUsageFields("joiningColumns")

    def fields(
        self,
        *subfields: Union[TableJoinScenarioGraphQLField, "TableColumnsUsageFields"]
    ) -> "TableJoinScenarioFields":
        """Subfields should come from the TableJoinScenarioFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TableJoinScenarioFields":
        self._alias = alias
        return self


class TableJoinsFields(GraphQLField):
    @classmethod
    def last7Days(cls) -> "TableJoinFields":
        return TableJoinFields("last7Days")

    @classmethod
    def last24Hours(cls) -> "TableJoinFields":
        return TableJoinFields("last24Hours")

    @classmethod
    def last30Days(cls) -> "TableJoinFields":
        return TableJoinFields("last30Days")

    @classmethod
    def last90Days(cls) -> "TableJoinFields":
        return TableJoinFields("last90Days")

    @classmethod
    def last365Days(cls) -> "TableJoinFields":
        return TableJoinFields("last365Days")

    def fields(
        self, *subfields: Union[TableJoinsGraphQLField, "TableJoinFields"]
    ) -> "TableJoinsFields":
        """Subfields should come from the TableJoinsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TableJoinsFields":
        self._alias = alias
        return self


class TableauDatasourceFields(GraphQLField):
    createdAt: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField(
        "createdAt"
    )
    description: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField(
        "description"
    )

    @classmethod
    def downstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineageFor: Optional[TableauDatasourceDownstreamLineageInput] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {
                "type": "TableauDatasourceDownstreamLineageInput",
                "value": lineageFor,
            },
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstreamOfType", arguments=cleared_arguments
        )

    embedded: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField(
        "embedded"
    )
    entityId: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField(
        "entityId"
    )

    @classmethod
    def fields(cls) -> "TableauFieldFields":
        return TableauFieldFields("fields")

    name: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField("name")
    query: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField("query")
    sourceDatasets: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField(
        "sourceDatasets"
    )
    sourceVirtualViews: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField(
        "sourceVirtualViews"
    )
    source_dataset_account: "TableauDatasourceGraphQLField" = (
        TableauDatasourceGraphQLField("source_dataset_account")
    )
    source_platform: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField(
        "source_platform"
    )

    @classmethod
    def upstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineageFor: Optional[TableauDatasourceUpstreamLineageInput] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {
                "type": "TableauDatasourceUpstreamLineageInput",
                "value": lineageFor,
            },
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstreamOfType", arguments=cleared_arguments
        )

    url: "TableauDatasourceGraphQLField" = TableauDatasourceGraphQLField("url")

    def fields(
        self,
        *subfields: Union[
            TableauDatasourceGraphQLField,
            "EntityLineageConnectionFields",
            "TableauFieldFields",
        ]
    ) -> "TableauDatasourceFields":
        """Subfields should come from the TableauDatasourceFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TableauDatasourceFields":
        self._alias = alias
        return self


class TableauDatasourceSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "VirtualViewSearchDocumentFields":
        return VirtualViewSearchDocumentFields("documents")

    errorMessage: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("errorMessage")
    )
    from_: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("from")
    )
    hasMore: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("paginationToken")
    )
    searchContext: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("searchContext")
    )
    searchIndex: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("searchIndex")
    )
    size: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("size")
    )
    totalCount: "TableauDatasourceSearchResultGraphQLField" = (
        TableauDatasourceSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            TableauDatasourceSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "VirtualViewSearchDocumentFields",
        ]
    ) -> "TableauDatasourceSearchResultFields":
        """Subfields should come from the TableauDatasourceSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TableauDatasourceSearchResultFields":
        self._alias = alias
        return self


class TableauFieldFields(GraphQLField):
    description: "TableauFieldGraphQLField" = TableauFieldGraphQLField("description")
    field: "TableauFieldGraphQLField" = TableauFieldGraphQLField("field")

    def fields(self, *subfields: TableauFieldGraphQLField) -> "TableauFieldFields":
        """Subfields should come from the TableauFieldFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TableauFieldFields":
        self._alias = alias
        return self


class TenantInfoFields(GraphQLField):
    id: "TenantInfoGraphQLField" = TenantInfoGraphQLField("id")
    name: "TenantInfoGraphQLField" = TenantInfoGraphQLField("name")
    status: "TenantInfoGraphQLField" = TenantInfoGraphQLField("status")

    def fields(self, *subfields: TenantInfoGraphQLField) -> "TenantInfoFields":
        """Subfields should come from the TenantInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TenantInfoFields":
        self._alias = alias
        return self


class ThoughtSpotColumnFields(GraphQLField):
    description: "ThoughtSpotColumnGraphQLField" = ThoughtSpotColumnGraphQLField(
        "description"
    )
    field: "ThoughtSpotColumnGraphQLField" = ThoughtSpotColumnGraphQLField("field")
    formula: "ThoughtSpotColumnGraphQLField" = ThoughtSpotColumnGraphQLField("formula")
    name: "ThoughtSpotColumnGraphQLField" = ThoughtSpotColumnGraphQLField("name")
    optionalType: "ThoughtSpotColumnGraphQLField" = ThoughtSpotColumnGraphQLField(
        "optionalType"
    )
    type: "ThoughtSpotColumnGraphQLField" = ThoughtSpotColumnGraphQLField("type")

    def fields(
        self, *subfields: ThoughtSpotColumnGraphQLField
    ) -> "ThoughtSpotColumnFields":
        """Subfields should come from the ThoughtSpotColumnFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThoughtSpotColumnFields":
        self._alias = alias
        return self


class ThoughtSpotDataObjectFields(GraphQLField):
    @classmethod
    def columns(cls) -> "ThoughtSpotColumnFields":
        return ThoughtSpotColumnFields("columns")

    createdAt: "ThoughtSpotDataObjectGraphQLField" = ThoughtSpotDataObjectGraphQLField(
        "createdAt"
    )
    description: "ThoughtSpotDataObjectGraphQLField" = (
        ThoughtSpotDataObjectGraphQLField("description")
    )

    @classmethod
    def downstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineageFor: Optional[ThoughtSpotDataObjectDownstreamLineageInput] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {
                "type": "ThoughtSpotDataObjectDownstreamLineageInput",
                "value": lineageFor,
            },
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstreamOfType", arguments=cleared_arguments
        )

    entityId: "ThoughtSpotDataObjectGraphQLField" = ThoughtSpotDataObjectGraphQLField(
        "entityId"
    )
    name: "ThoughtSpotDataObjectGraphQLField" = ThoughtSpotDataObjectGraphQLField(
        "name"
    )
    sourceDatasets: "ThoughtSpotDataObjectGraphQLField" = (
        ThoughtSpotDataObjectGraphQLField("sourceDatasets")
    )
    sourceVirtualViews: "ThoughtSpotDataObjectGraphQLField" = (
        ThoughtSpotDataObjectGraphQLField("sourceVirtualViews")
    )
    type: "ThoughtSpotDataObjectGraphQLField" = ThoughtSpotDataObjectGraphQLField(
        "type"
    )

    @classmethod
    def upstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineageFor: Optional[ThoughtSpotDataObjectUpstreamLineageInput] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {
                "type": "ThoughtSpotDataObjectUpstreamLineageInput",
                "value": lineageFor,
            },
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstreamOfType", arguments=cleared_arguments
        )

    url: "ThoughtSpotDataObjectGraphQLField" = ThoughtSpotDataObjectGraphQLField("url")

    def fields(
        self,
        *subfields: Union[
            ThoughtSpotDataObjectGraphQLField,
            "EntityLineageConnectionFields",
            "ThoughtSpotColumnFields",
        ]
    ) -> "ThoughtSpotDataObjectFields":
        """Subfields should come from the ThoughtSpotDataObjectFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThoughtSpotDataObjectFields":
        self._alias = alias
        return self


class ThoughtSpotDataObjectSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "VirtualViewSearchDocumentFields":
        return VirtualViewSearchDocumentFields("documents")

    errorMessage: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("errorMessage")
    )
    from_: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("from")
    )
    hasMore: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("paginationToken")
    )
    searchContext: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("searchContext")
    )
    searchIndex: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("searchIndex")
    )
    size: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("size")
    )
    totalCount: "ThoughtSpotDataObjectSearchResultGraphQLField" = (
        ThoughtSpotDataObjectSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            ThoughtSpotDataObjectSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "VirtualViewSearchDocumentFields",
        ]
    ) -> "ThoughtSpotDataObjectSearchResultFields":
        """Subfields should come from the ThoughtSpotDataObjectSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThoughtSpotDataObjectSearchResultFields":
        self._alias = alias
        return self


class ThoughtSpotInfoFields(GraphQLField):
    embedUrl: "ThoughtSpotInfoGraphQLField" = ThoughtSpotInfoGraphQLField("embedUrl")
    type: "ThoughtSpotInfoGraphQLField" = ThoughtSpotInfoGraphQLField("type")

    def fields(
        self, *subfields: ThoughtSpotInfoGraphQLField
    ) -> "ThoughtSpotInfoFields":
        """Subfields should come from the ThoughtSpotInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThoughtSpotInfoFields":
        self._alias = alias
        return self


class ToggleMuteNotificationOutputFields(GraphQLField):
    @classmethod
    def entity(cls) -> "EntityInterface":
        return EntityInterface("entity")

    muted: "ToggleMuteNotificationOutputGraphQLField" = (
        ToggleMuteNotificationOutputGraphQLField("muted")
    )

    def fields(
        self,
        *subfields: Union[ToggleMuteNotificationOutputGraphQLField, "EntityInterface"]
    ) -> "ToggleMuteNotificationOutputFields":
        """Subfields should come from the ToggleMuteNotificationOutputFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ToggleMuteNotificationOutputFields":
        self._alias = alias
        return self


class UnityCatalogFields(GraphQLField):
    createdAt: "UnityCatalogGraphQLField" = UnityCatalogGraphQLField("createdAt")
    datasetType: "UnityCatalogGraphQLField" = UnityCatalogGraphQLField("datasetType")
    entityId: "UnityCatalogGraphQLField" = UnityCatalogGraphQLField("entityId")

    @classmethod
    def tableInfo(cls) -> "UnityCatalogTableInfoFields":
        return UnityCatalogTableInfoFields("tableInfo")

    volumeEntityId: "UnityCatalogGraphQLField" = UnityCatalogGraphQLField(
        "volumeEntityId"
    )

    @classmethod
    def volumeInfo(cls) -> "UnityCatalogVolumeInfoFields":
        return UnityCatalogVolumeInfoFields("volumeInfo")

    def fields(
        self,
        *subfields: Union[
            UnityCatalogGraphQLField,
            "UnityCatalogTableInfoFields",
            "UnityCatalogVolumeInfoFields",
        ]
    ) -> "UnityCatalogFields":
        """Subfields should come from the UnityCatalogFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UnityCatalogFields":
        self._alias = alias
        return self


class UnityCatalogTableInfoFields(GraphQLField):
    dataSourceFormat: "UnityCatalogTableInfoGraphQLField" = (
        UnityCatalogTableInfoGraphQLField("dataSourceFormat")
    )
    owner: "UnityCatalogTableInfoGraphQLField" = UnityCatalogTableInfoGraphQLField(
        "owner"
    )

    @classmethod
    def properties(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("properties")

    storageLocation: "UnityCatalogTableInfoGraphQLField" = (
        UnityCatalogTableInfoGraphQLField("storageLocation")
    )
    type: "UnityCatalogTableInfoGraphQLField" = UnityCatalogTableInfoGraphQLField(
        "type"
    )

    def fields(
        self, *subfields: Union[UnityCatalogTableInfoGraphQLField, "KeyValuePairFields"]
    ) -> "UnityCatalogTableInfoFields":
        """Subfields should come from the UnityCatalogTableInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UnityCatalogTableInfoFields":
        self._alias = alias
        return self


class UnityCatalogVolumeInfoFields(GraphQLField):
    storageLocation: "UnityCatalogVolumeInfoGraphQLField" = (
        UnityCatalogVolumeInfoGraphQLField("storageLocation")
    )
    type: "UnityCatalogVolumeInfoGraphQLField" = UnityCatalogVolumeInfoGraphQLField(
        "type"
    )

    @classmethod
    def volumeFiles(cls) -> "VolumeFileFields":
        return VolumeFileFields("volumeFiles")

    def fields(
        self, *subfields: Union[UnityCatalogVolumeInfoGraphQLField, "VolumeFileFields"]
    ) -> "UnityCatalogVolumeInfoFields":
        """Subfields should come from the UnityCatalogVolumeInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UnityCatalogVolumeInfoFields":
        self._alias = alias
        return self


class UniversalSearchResultFields(GraphQLField):
    response: "UniversalSearchResultGraphQLField" = UniversalSearchResultGraphQLField(
        "response"
    )
    searchFailed: "UniversalSearchResultGraphQLField" = (
        UniversalSearchResultGraphQLField("searchFailed")
    )

    @classmethod
    def sourceAssets(cls) -> "EntityConnectionFields":
        return EntityConnectionFields("sourceAssets")

    def fields(
        self,
        *subfields: Union[UniversalSearchResultGraphQLField, "EntityConnectionFields"]
    ) -> "UniversalSearchResultFields":
        """Subfields should come from the UniversalSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UniversalSearchResultFields":
        self._alias = alias
        return self


class UpdateCrawlerScheduleInterface(GraphQLField):
    description: "UpdateCrawlerScheduleGraphQLField" = (
        UpdateCrawlerScheduleGraphQLField("description")
    )
    enabled: "UpdateCrawlerScheduleGraphQLField" = UpdateCrawlerScheduleGraphQLField(
        "enabled"
    )
    isDaily: "UpdateCrawlerScheduleGraphQLField" = UpdateCrawlerScheduleGraphQLField(
        "isDaily"
    )
    schedule: "UpdateCrawlerScheduleGraphQLField" = UpdateCrawlerScheduleGraphQLField(
        "schedule"
    )

    def fields(
        self, *subfields: UpdateCrawlerScheduleGraphQLField
    ) -> "UpdateCrawlerScheduleInterface":
        """Subfields should come from the UpdateCrawlerScheduleInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UpdateCrawlerScheduleInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "UpdateCrawlerScheduleInterface":
        self._inline_fragments[type_name] = subfields
        return self


class UsageKnowledgeCardFields(GraphQLField):
    detail: "UsageKnowledgeCardGraphQLField" = UsageKnowledgeCardGraphQLField("detail")
    example: "UsageKnowledgeCardGraphQLField" = UsageKnowledgeCardGraphQLField(
        "example"
    )
    title: "UsageKnowledgeCardGraphQLField" = UsageKnowledgeCardGraphQLField("title")

    @classmethod
    def tokenizedContent(cls) -> "HowToUseTokenizedContentFields":
        return HowToUseTokenizedContentFields("tokenizedContent")

    def fields(
        self,
        *subfields: Union[
            UsageKnowledgeCardGraphQLField, "HowToUseTokenizedContentFields"
        ]
    ) -> "UsageKnowledgeCardFields":
        """Subfields should come from the UsageKnowledgeCardFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UsageKnowledgeCardFields":
        self._alias = alias
        return self


class UserActivityFields(GraphQLField):
    activityType: "UserActivityGraphQLField" = UserActivityGraphQLField("activityType")

    @classmethod
    def actorInfo(cls) -> "UserActivityActorInfoFields":
        return UserActivityActorInfoFields("actorInfo")

    durationInSeconds: "UserActivityGraphQLField" = UserActivityGraphQLField(
        "durationInSeconds"
    )
    measure: "UserActivityGraphQLField" = UserActivityGraphQLField("measure")
    source: "UserActivityGraphQLField" = UserActivityGraphQLField("source")
    timestamp: "UserActivityGraphQLField" = UserActivityGraphQLField("timestamp")

    def fields(
        self, *subfields: Union[UserActivityGraphQLField, "UserActivityActorInfoFields"]
    ) -> "UserActivityFields":
        """Subfields should come from the UserActivityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserActivityFields":
        self._alias = alias
        return self


class UserActivityActorInfoFields(GraphQLField):
    email: "UserActivityActorInfoGraphQLField" = UserActivityActorInfoGraphQLField(
        "email"
    )

    def fields(
        self, *subfields: UserActivityActorInfoGraphQLField
    ) -> "UserActivityActorInfoFields":
        """Subfields should come from the UserActivityActorInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserActivityActorInfoFields":
        self._alias = alias
        return self


class UserDefinedResourceFields(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def assetsLinkedToResource(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssociatedAssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "AssociatedAssetConnectionFilterInput",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields(
            "assetsLinkedToResource", arguments=cleared_arguments
        )

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    @classmethod
    def childResources(
        cls,
        filters: ResourceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "ResourceInfoConnectionFilterInput!", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "childResources", arguments=cleared_arguments
        )

    @classmethod
    def commonColumnAttributes(cls) -> "CommonColumnAttributesFields":
        return CommonColumnAttributesFields("commonColumnAttributes")

    countMatchingColumns: "UserDefinedResourceGraphQLField" = (
        UserDefinedResourceGraphQLField("countMatchingColumns")
    )
    createdAt: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField(
        "createdAt"
    )
    deletedAt: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField(
        "deletedAt"
    )
    displayName: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField(
        "displayName"
    )
    entityType: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField(
        "entityType"
    )

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField("id")
    isDeleted: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField(
        "isDeleted"
    )
    isViewerAuthor: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField(
        "isViewerAuthor"
    )

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    lastIngestedAt: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField(
        "lastIngestedAt"
    )
    lastModifiedAt: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField(
        "lastModifiedAt"
    )

    @classmethod
    def logicalId(cls) -> "UserDefinedResourceLogicalIdFields":
        return UserDefinedResourceLogicalIdFields("logicalId")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def parentResource(cls) -> "UserDefinedResourceFields":
        return UserDefinedResourceFields("parentResource")

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    @classmethod
    def userDefinedResourceInfo(cls) -> "UserDefinedResourceInfoFields":
        return UserDefinedResourceInfoFields("userDefinedResourceInfo")

    viewerCanAssign: "UserDefinedResourceGraphQLField" = (
        UserDefinedResourceGraphQLField("viewerCanAssign")
    )
    viewerCanDelete: "UserDefinedResourceGraphQLField" = (
        UserDefinedResourceGraphQLField("viewerCanDelete")
    )
    viewerCanEdit: "UserDefinedResourceGraphQLField" = UserDefinedResourceGraphQLField(
        "viewerCanEdit"
    )

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "CommonColumnAttributesFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
            "UserDefinedResourceConnectionFields",
            "UserDefinedResourceFields",
            "UserDefinedResourceInfoFields",
            "UserDefinedResourceLogicalIdFields",
        ]
    ) -> "UserDefinedResourceFields":
        """Subfields should come from the UserDefinedResourceFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceFields":
        self._alias = alias
        return self


class UserDefinedResourceBaseInterface(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "UserDefinedResourceBaseGraphQLField" = (
        UserDefinedResourceBaseGraphQLField("createdAt")
    )
    deletedAt: "UserDefinedResourceBaseGraphQLField" = (
        UserDefinedResourceBaseGraphQLField("deletedAt")
    )
    displayName: "UserDefinedResourceBaseGraphQLField" = (
        UserDefinedResourceBaseGraphQLField("displayName")
    )
    entityType: "UserDefinedResourceBaseGraphQLField" = (
        UserDefinedResourceBaseGraphQLField("entityType")
    )

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "UserDefinedResourceBaseGraphQLField" = UserDefinedResourceBaseGraphQLField(
        "id"
    )
    isDeleted: "UserDefinedResourceBaseGraphQLField" = (
        UserDefinedResourceBaseGraphQLField("isDeleted")
    )

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    lastIngestedAt: "UserDefinedResourceBaseGraphQLField" = (
        UserDefinedResourceBaseGraphQLField("lastIngestedAt")
    )
    lastModifiedAt: "UserDefinedResourceBaseGraphQLField" = (
        UserDefinedResourceBaseGraphQLField("lastModifiedAt")
    )

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceBaseGraphQLField,
            "AggregationMetadataFields",
            "AssetFollowersFields",
            "BrowsePathFields",
            "EntityConnectionFields",
            "HashtagFields",
            "KnowledgeCardConnectionFields",
            "NamespaceConnectionFields",
            "PersonConnectionFields",
        ]
    ) -> "UserDefinedResourceBaseInterface":
        """Subfields should come from the UserDefinedResourceBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "UserDefinedResourceBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class UserDefinedResourceConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "UserDefinedResourceEdgeFields":
        return UserDefinedResourceEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "UserDefinedResourceConnectionGraphQLField" = (
        UserDefinedResourceConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceConnectionGraphQLField,
            "PageInfoFields",
            "UserDefinedResourceEdgeFields",
        ]
    ) -> "UserDefinedResourceConnectionFields":
        """Subfields should come from the UserDefinedResourceConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceConnectionFields":
        self._alias = alias
        return self


class UserDefinedResourceDeletePayloadFields(GraphQLField):
    deletedIds: "UserDefinedResourceDeletePayloadGraphQLField" = (
        UserDefinedResourceDeletePayloadGraphQLField("deletedIds")
    )
    failedIds: "UserDefinedResourceDeletePayloadGraphQLField" = (
        UserDefinedResourceDeletePayloadGraphQLField("failedIds")
    )

    def fields(
        self, *subfields: UserDefinedResourceDeletePayloadGraphQLField
    ) -> "UserDefinedResourceDeletePayloadFields":
        """Subfields should come from the UserDefinedResourceDeletePayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceDeletePayloadFields":
        self._alias = alias
        return self


class UserDefinedResourceDescriptionFields(GraphQLField):
    text: "UserDefinedResourceDescriptionGraphQLField" = (
        UserDefinedResourceDescriptionGraphQLField("text")
    )
    tokenizedText: "UserDefinedResourceDescriptionGraphQLField" = (
        UserDefinedResourceDescriptionGraphQLField("tokenizedText")
    )

    def fields(
        self, *subfields: UserDefinedResourceDescriptionGraphQLField
    ) -> "UserDefinedResourceDescriptionFields":
        """Subfields should come from the UserDefinedResourceDescriptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceDescriptionFields":
        self._alias = alias
        return self


class UserDefinedResourceEdgeFields(GraphQLField):
    cursor: "UserDefinedResourceEdgeGraphQLField" = UserDefinedResourceEdgeGraphQLField(
        "cursor"
    )

    @classmethod
    def node(cls) -> "UserDefinedResourceFields":
        return UserDefinedResourceFields("node")

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceEdgeGraphQLField, "UserDefinedResourceFields"
        ]
    ) -> "UserDefinedResourceEdgeFields":
        """Subfields should come from the UserDefinedResourceEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceEdgeFields":
        self._alias = alias
        return self


class UserDefinedResourceHighlightFields(GraphQLField):
    contactDisplayNames: "UserDefinedResourceHighlightGraphQLField" = (
        UserDefinedResourceHighlightGraphQLField("contactDisplayNames")
    )
    description: "UserDefinedResourceHighlightGraphQLField" = (
        UserDefinedResourceHighlightGraphQLField("description")
    )
    governedTags: "UserDefinedResourceHighlightGraphQLField" = (
        UserDefinedResourceHighlightGraphQLField("governedTags")
    )
    hashtags: "UserDefinedResourceHighlightGraphQLField" = (
        UserDefinedResourceHighlightGraphQLField("hashtags")
    )
    name: "UserDefinedResourceHighlightGraphQLField" = (
        UserDefinedResourceHighlightGraphQLField("name")
    )

    def fields(
        self, *subfields: UserDefinedResourceHighlightGraphQLField
    ) -> "UserDefinedResourceHighlightFields":
        """Subfields should come from the UserDefinedResourceHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceHighlightFields":
        self._alias = alias
        return self


class UserDefinedResourceInfoFields(GraphQLField):
    @classmethod
    def created(cls) -> "AuditStampFields":
        return AuditStampFields("created")

    createdAt: "UserDefinedResourceInfoGraphQLField" = (
        UserDefinedResourceInfoGraphQLField("createdAt")
    )

    @classmethod
    def customTagAttributes(cls) -> "CustomTagAttributesFields":
        return CustomTagAttributesFields("customTagAttributes")

    @classmethod
    def description(cls) -> "UserDefinedResourceDescriptionFields":
        return UserDefinedResourceDescriptionFields("description")

    entityId: "UserDefinedResourceInfoGraphQLField" = (
        UserDefinedResourceInfoGraphQLField("entityId")
    )

    @classmethod
    def lastModified(cls) -> "AuditStampFields":
        return AuditStampFields("lastModified")

    name: "UserDefinedResourceInfoGraphQLField" = UserDefinedResourceInfoGraphQLField(
        "name"
    )
    type: "UserDefinedResourceInfoGraphQLField" = UserDefinedResourceInfoGraphQLField(
        "type"
    )

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceInfoGraphQLField,
            "AuditStampFields",
            "CustomTagAttributesFields",
            "UserDefinedResourceDescriptionFields",
        ]
    ) -> "UserDefinedResourceInfoFields":
        """Subfields should come from the UserDefinedResourceInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceInfoFields":
        self._alias = alias
        return self


class UserDefinedResourceInfoBaseInterface(GraphQLField):
    createdAt: "UserDefinedResourceInfoBaseGraphQLField" = (
        UserDefinedResourceInfoBaseGraphQLField("createdAt")
    )

    @classmethod
    def customTagAttributes(cls) -> "CustomTagAttributesFields":
        return CustomTagAttributesFields("customTagAttributes")

    @classmethod
    def description(cls) -> "UserDefinedResourceDescriptionFields":
        return UserDefinedResourceDescriptionFields("description")

    entityId: "UserDefinedResourceInfoBaseGraphQLField" = (
        UserDefinedResourceInfoBaseGraphQLField("entityId")
    )
    name: "UserDefinedResourceInfoBaseGraphQLField" = (
        UserDefinedResourceInfoBaseGraphQLField("name")
    )
    type: "UserDefinedResourceInfoBaseGraphQLField" = (
        UserDefinedResourceInfoBaseGraphQLField("type")
    )

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceInfoBaseGraphQLField,
            "CustomTagAttributesFields",
            "UserDefinedResourceDescriptionFields",
        ]
    ) -> "UserDefinedResourceInfoBaseInterface":
        """Subfields should come from the UserDefinedResourceInfoBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceInfoBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "UserDefinedResourceInfoBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class UserDefinedResourceLogicalIdFields(GraphQLField):
    id: "UserDefinedResourceLogicalIdGraphQLField" = (
        UserDefinedResourceLogicalIdGraphQLField("id")
    )

    def fields(
        self, *subfields: UserDefinedResourceLogicalIdGraphQLField
    ) -> "UserDefinedResourceLogicalIdFields":
        """Subfields should come from the UserDefinedResourceLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceLogicalIdFields":
        self._alias = alias
        return self


class UserDefinedResourceSearchDocumentFields(GraphQLField):
    author: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("author")
    )
    authorDisplayName: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("authorDisplayName")
    )
    browsePathHierarchy: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browsePathSegments: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    contactDisplayNames: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("contactDisplayNames")
    )
    description: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("description")
    )
    documentId: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("documentId")
    )
    embeddedString_1: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("embeddedString_1")
    )
    embeddedString_2: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("embeddedString_2")
    )
    entityId: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("entityId")
    )
    governedTags: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("governedTags")
    )
    hashtags: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("hashtags")
    )

    @classmethod
    def highlight(cls) -> "UserDefinedResourceHighlightFields":
        return UserDefinedResourceHighlightFields("highlight")

    isDeleted: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("isDeleted")
    )
    lastRefreshed: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("lastRefreshed")
    )
    name: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("name")
    )
    paginationToken: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("paginationToken")
    )

    @classmethod
    def scoreDetails(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("scoreDetails")

    type: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("type")
    )
    viewCount: "UserDefinedResourceSearchDocumentGraphQLField" = (
        UserDefinedResourceSearchDocumentGraphQLField("viewCount")
    )

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceSearchDocumentGraphQLField,
            "BrowsePathFields",
            "SearchScoreDetailsFields",
            "UserDefinedResourceHighlightFields",
        ]
    ) -> "UserDefinedResourceSearchDocumentFields":
        """Subfields should come from the UserDefinedResourceSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceSearchDocumentFields":
        self._alias = alias
        return self


class UserDefinedResourceSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "UserDefinedResourceSearchDocumentFields":
        return UserDefinedResourceSearchDocumentFields("documents")

    errorMessage: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("errorMessage")
    )
    from_: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("from")
    )
    hasMore: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    paginationToken: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("paginationToken")
    )
    searchContext: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("searchContext")
    )
    searchIndex: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("searchIndex")
    )
    size: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("size")
    )
    totalCount: "UserDefinedResourceSearchResultGraphQLField" = (
        UserDefinedResourceSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            UserDefinedResourceSearchResultGraphQLField,
            "AggregationMetadataFields",
            "UserDefinedResourceSearchDocumentFields",
        ]
    ) -> "UserDefinedResourceSearchResultFields":
        """Subfields should come from the UserDefinedResourceSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserDefinedResourceSearchResultFields":
        self._alias = alias
        return self


class UserQueryCountFields(GraphQLField):
    count: "UserQueryCountGraphQLField" = UserQueryCountGraphQLField("count")
    user: "UserQueryCountGraphQLField" = UserQueryCountGraphQLField("user")

    def fields(self, *subfields: UserQueryCountGraphQLField) -> "UserQueryCountFields":
        """Subfields should come from the UserQueryCountFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserQueryCountFields":
        self._alias = alias
        return self


class UserQueryCountsFields(GraphQLField):
    @classmethod
    def last7Days(cls) -> "UserQueryCountFields":
        return UserQueryCountFields("last7Days")

    last7DaysQueriedByCount: "UserQueryCountsGraphQLField" = (
        UserQueryCountsGraphQLField("last7DaysQueriedByCount")
    )

    @classmethod
    def last24Hours(cls) -> "UserQueryCountFields":
        return UserQueryCountFields("last24Hours")

    last24HoursQueriedByCount: "UserQueryCountsGraphQLField" = (
        UserQueryCountsGraphQLField("last24HoursQueriedByCount")
    )

    @classmethod
    def last30Days(cls) -> "UserQueryCountFields":
        return UserQueryCountFields("last30Days")

    last30DaysQueriedByCount: "UserQueryCountsGraphQLField" = (
        UserQueryCountsGraphQLField("last30DaysQueriedByCount")
    )

    @classmethod
    def last90Days(cls) -> "UserQueryCountFields":
        return UserQueryCountFields("last90Days")

    last90DaysQueriedByCount: "UserQueryCountsGraphQLField" = (
        UserQueryCountsGraphQLField("last90DaysQueriedByCount")
    )

    @classmethod
    def last365Days(cls) -> "UserQueryCountFields":
        return UserQueryCountFields("last365Days")

    last365DaysQueriedByCount: "UserQueryCountsGraphQLField" = (
        UserQueryCountsGraphQLField("last365DaysQueriedByCount")
    )

    def fields(
        self, *subfields: Union[UserQueryCountsGraphQLField, "UserQueryCountFields"]
    ) -> "UserQueryCountsFields":
        """Subfields should come from the UserQueryCountsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserQueryCountsFields":
        self._alias = alias
        return self


class UserSpecifiedOrderingFields(GraphQLField):
    @classmethod
    def orderedEntries(cls) -> "OrderedEntryFields":
        return OrderedEntryFields("orderedEntries")

    type: "UserSpecifiedOrderingGraphQLField" = UserSpecifiedOrderingGraphQLField(
        "type"
    )

    def fields(
        self, *subfields: Union[UserSpecifiedOrderingGraphQLField, "OrderedEntryFields"]
    ) -> "UserSpecifiedOrderingFields":
        """Subfields should come from the UserSpecifiedOrderingFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserSpecifiedOrderingFields":
        self._alias = alias
        return self


class VersionHistoryFields(GraphQLField):
    @classmethod
    def after(cls) -> "EntityInterface":
        return EntityInterface("after")

    @classmethod
    def before(cls) -> "EntityInterface":
        return EntityInterface("before")

    date: "VersionHistoryGraphQLField" = VersionHistoryGraphQLField("date")

    @classmethod
    def entity(cls) -> "EntityInterface":
        return EntityInterface("entity")

    updated: "VersionHistoryGraphQLField" = VersionHistoryGraphQLField("updated")
    versionId: "VersionHistoryGraphQLField" = VersionHistoryGraphQLField("versionId")

    def fields(
        self, *subfields: Union[VersionHistoryGraphQLField, "EntityInterface"]
    ) -> "VersionHistoryFields":
        """Subfields should come from the VersionHistoryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VersionHistoryFields":
        self._alias = alias
        return self


class VersionHistoryConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "VersionHistoryEdgeFields":
        return VersionHistoryEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "VersionHistoryConnectionGraphQLField" = (
        VersionHistoryConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            VersionHistoryConnectionGraphQLField,
            "PageInfoFields",
            "VersionHistoryEdgeFields",
        ]
    ) -> "VersionHistoryConnectionFields":
        """Subfields should come from the VersionHistoryConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VersionHistoryConnectionFields":
        self._alias = alias
        return self


class VersionHistoryEdgeFields(GraphQLField):
    cursor: "VersionHistoryEdgeGraphQLField" = VersionHistoryEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "VersionHistoryFields":
        return VersionHistoryFields("node")

    def fields(
        self, *subfields: Union[VersionHistoryEdgeGraphQLField, "VersionHistoryFields"]
    ) -> "VersionHistoryEdgeFields":
        """Subfields should come from the VersionHistoryEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VersionHistoryEdgeFields":
        self._alias = alias
        return self


class ViewActivityConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "ViewActivityEdgeFields":
        return ViewActivityEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "ViewActivityConnectionGraphQLField" = (
        ViewActivityConnectionGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            ViewActivityConnectionGraphQLField,
            "PageInfoFields",
            "ViewActivityEdgeFields",
        ]
    ) -> "ViewActivityConnectionFields":
        """Subfields should come from the ViewActivityConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ViewActivityConnectionFields":
        self._alias = alias
        return self


class ViewActivityEdgeFields(GraphQLField):
    cursor: "ViewActivityEdgeGraphQLField" = ViewActivityEdgeGraphQLField("cursor")
    lastViewedAt: "ViewActivityEdgeGraphQLField" = ViewActivityEdgeGraphQLField(
        "lastViewedAt"
    )

    @classmethod
    def node(cls) -> "EntityInterface":
        return EntityInterface("node")

    viewContext: "ViewActivityEdgeGraphQLField" = ViewActivityEdgeGraphQLField(
        "viewContext"
    )

    def fields(
        self, *subfields: Union[ViewActivityEdgeGraphQLField, "EntityInterface"]
    ) -> "ViewActivityEdgeFields":
        """Subfields should come from the ViewActivityEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ViewActivityEdgeFields":
        self._alias = alias
        return self


class ViewedByConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "ViewedByEdgeFields":
        return ViewedByEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "ViewedByConnectionGraphQLField" = ViewedByConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            ViewedByConnectionGraphQLField, "PageInfoFields", "ViewedByEdgeFields"
        ]
    ) -> "ViewedByConnectionFields":
        """Subfields should come from the ViewedByConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ViewedByConnectionFields":
        self._alias = alias
        return self


class ViewedByEdgeFields(GraphQLField):
    cursor: "ViewedByEdgeGraphQLField" = ViewedByEdgeGraphQLField("cursor")
    lastViewedAt: "ViewedByEdgeGraphQLField" = ViewedByEdgeGraphQLField("lastViewedAt")

    @classmethod
    def node(cls) -> "PersonFields":
        return PersonFields("node")

    def fields(
        self, *subfields: Union[ViewedByEdgeGraphQLField, "PersonFields"]
    ) -> "ViewedByEdgeFields":
        """Subfields should come from the ViewedByEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ViewedByEdgeFields":
        self._alias = alias
        return self


class ViewerPermissionsFields(GraphQLField):
    @classmethod
    def canAssignNamespace(cls, type: NamespaceType) -> "ViewerPermissionsGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "NamespaceType!", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewerPermissionsGraphQLField(
            "canAssignNamespace", arguments=cleared_arguments
        )

    @classmethod
    def canAssignUserDefinedResource(
        cls, type: UserDefinedResourceType
    ) -> "ViewerPermissionsGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "UserDefinedResourceType!", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewerPermissionsGraphQLField(
            "canAssignUserDefinedResource", arguments=cleared_arguments
        )

    @classmethod
    def canCreateKnowledgeCard(
        cls, type: KnowledgeCardType
    ) -> "ViewerPermissionsGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "KnowledgeCardType!", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewerPermissionsGraphQLField(
            "canCreateKnowledgeCard", arguments=cleared_arguments
        )

    @classmethod
    def canCreateNamespace(cls, type: NamespaceType) -> "ViewerPermissionsGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "NamespaceType!", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewerPermissionsGraphQLField(
            "canCreateNamespace", arguments=cleared_arguments
        )

    @classmethod
    def canCreateUserDefinedResource(
        cls, type: UserDefinedResourceType
    ) -> "ViewerPermissionsGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "UserDefinedResourceType!", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewerPermissionsGraphQLField(
            "canCreateUserDefinedResource", arguments=cleared_arguments
        )

    canCurateQuery: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canCurateQuery"
    )
    canEditApiKeys: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canEditApiKeys"
    )
    canEditCrawlers: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canEditCrawlers"
    )
    canEditGroups: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canEditGroups"
    )
    canEditUsers: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canEditUsers"
    )
    canEnrollGroupsAsFollowers: "ViewerPermissionsGraphQLField" = (
        ViewerPermissionsGraphQLField("canEnrollGroupsAsFollowers")
    )
    canListUsers: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canListUsers"
    )
    canManageCustomDataGroupingOrder: "ViewerPermissionsGraphQLField" = (
        ViewerPermissionsGraphQLField("canManageCustomDataGroupingOrder")
    )
    canRunQuery: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canRunQuery"
    )
    canSearchUsers: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canSearchUsers"
    )
    canSeeApiKeys: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canSeeApiKeys"
    )
    canSeeCrawlers: "ViewerPermissionsGraphQLField" = ViewerPermissionsGraphQLField(
        "canSeeCrawlers"
    )

    def fields(
        self, *subfields: ViewerPermissionsGraphQLField
    ) -> "ViewerPermissionsFields":
        """Subfields should come from the ViewerPermissionsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ViewerPermissionsFields":
        self._alias = alias
        return self


class VirtualViewFields(GraphQLField):
    @classmethod
    def anchorEntityFilters(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("anchorEntityFilters")

    @classmethod
    def assetContacts(cls) -> "AssetContactsFields":
        return AssetContactsFields("assetContacts")

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    createdAt: "VirtualViewGraphQLField" = VirtualViewGraphQLField("createdAt")

    @classmethod
    def dbtModel(cls) -> "DbtModelFields":
        return DbtModelFields("dbtModel")

    deletedAt: "VirtualViewGraphQLField" = VirtualViewGraphQLField("deletedAt")

    @classmethod
    def descriptions(cls) -> "DerivedAssetDescriptionsFields":
        return DerivedAssetDescriptionsFields("descriptions")

    displayName: "VirtualViewGraphQLField" = VirtualViewGraphQLField("displayName")

    @classmethod
    def downstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineageFor: Optional[LineageFilterInput] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineageFor},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "downstreamOfType", arguments=cleared_arguments
        )

    entityType: "VirtualViewGraphQLField" = VirtualViewGraphQLField("entityType")

    @classmethod
    def entityUpstream(cls) -> "EntityUpstreamFields":
        return EntityUpstreamFields("entityUpstream")

    @classmethod
    def followership(cls) -> "AssetFollowersFields":
        return AssetFollowersFields("followership")

    @classmethod
    def forceShown(cls) -> "AuditStampFields":
        return AuditStampFields("forceShown")

    @classmethod
    def governedTags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "UserDefinedResourceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            "governedTags", arguments=cleared_arguments
        )

    @classmethod
    def hashtags(cls) -> "HashtagFields":
        return HashtagFields("hashtags")

    id: "VirtualViewGraphQLField" = VirtualViewGraphQLField("id")

    @classmethod
    def interestedParties(cls) -> "InterestedPartyFields":
        return InterestedPartyFields("interestedParties")

    isComplete: "VirtualViewGraphQLField" = VirtualViewGraphQLField("isComplete")
    isDeleted: "VirtualViewGraphQLField" = VirtualViewGraphQLField("isDeleted")
    isProduction: "VirtualViewGraphQLField" = VirtualViewGraphQLField("isProduction")

    @classmethod
    def knowledge(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields("knowledge", arguments=cleared_arguments)

    @classmethod
    def knowledgeCards(
        cls,
        *,
        after: Optional[str] = None,
        anchorId: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "KnowledgeCardConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchorId},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            "knowledgeCards", arguments=cleared_arguments
        )

    @classmethod
    def labels(cls) -> "AnchorEntityLabelFields":
        return AnchorEntityLabelFields("labels")

    lastIngestedAt: "VirtualViewGraphQLField" = VirtualViewGraphQLField(
        "lastIngestedAt"
    )
    lastModifiedAt: "VirtualViewGraphQLField" = VirtualViewGraphQLField(
        "lastModifiedAt"
    )

    @classmethod
    def logicalId(cls) -> "VirtualViewLogicalIdFields":
        return VirtualViewLogicalIdFields("logicalId")

    @classmethod
    def lookerExplore(cls) -> "LookerExploreFields":
        return LookerExploreFields("lookerExplore")

    @classmethod
    def lookerView(cls) -> "LookerViewFields":
        return LookerViewFields("lookerView")

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None,
        orderByUserDefinedOrder: Optional[UserDefinedOrderType] = None
    ) -> "NamespaceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": orderByUserDefinedOrder,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields("namespaces", arguments=cleared_arguments)

    @classmethod
    def overallDataQuality(cls) -> "OverallDataQualityFields":
        return OverallDataQualityFields("overallDataQuality")

    @classmethod
    def pipelineInfo(cls) -> "PipelineInfoFields":
        return PipelineInfoFields("pipelineInfo")

    @classmethod
    def powerBIDataset(cls) -> "PowerBIDatasetFields":
        return PowerBIDatasetFields("powerBIDataset")

    @classmethod
    def recentUserActivities(
        cls, *, input: Optional[RecentUserActivitiesFilterInput] = None
    ) -> "RecentUserActivitiesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "RecentUserActivitiesFilterInput", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return RecentUserActivitiesFields(
            "recentUserActivities", arguments=cleared_arguments
        )

    @classmethod
    def recentlyViewedBy(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "ViewedByConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ViewedByConnectionFields("recentlyViewedBy", arguments=cleared_arguments)

    @classmethod
    def relatedAssets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[AssetConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "AssetConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityConnectionFields("relatedAssets", arguments=cleared_arguments)

    @classmethod
    def schema(cls) -> "VirtualViewSchemaFields":
        return VirtualViewSchemaFields("schema")

    @classmethod
    def sourceInfo(cls) -> "SourceInfoFields":
        return SourceInfoFields("sourceInfo")

    @classmethod
    def structure(cls) -> "AssetStructureFields":
        return AssetStructureFields("structure")

    @classmethod
    def systemContacts(cls) -> "SystemContactsFields":
        return SystemContactsFields("systemContacts")

    @classmethod
    def systemDescription(cls) -> "SystemDescriptionFields":
        return SystemDescriptionFields("systemDescription")

    systemTagValues: "VirtualViewGraphQLField" = VirtualViewGraphQLField(
        "systemTagValues"
    )

    @classmethod
    def systemTags(cls) -> "SystemTagsFields":
        return SystemTagsFields("systemTags")

    @classmethod
    def tableauDatasource(cls) -> "TableauDatasourceFields":
        return TableauDatasourceFields("tableauDatasource")

    @classmethod
    def thoughtSpot(cls) -> "ThoughtSpotDataObjectFields":
        return ThoughtSpotDataObjectFields("thoughtSpot")

    @classmethod
    def topAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields("topAuthors", arguments=cleared_arguments)

    @classmethod
    def topKnowledgeCardAuthors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "PersonConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(
            "topKnowledgeCardAuthors", arguments=cleared_arguments
        )

    @classmethod
    def upstreamOfType(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        lineageFor: Optional[LineageFilterInput] = None,
        orderBy: Optional[ConnectionOrderBy] = None
    ) -> "EntityLineageConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "lineageFor": {"type": "LineageFilterInput", "value": lineageFor},
            "orderBy": {"type": "ConnectionOrderBy", "value": orderBy},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EntityLineageConnectionFields(
            "upstreamOfType", arguments=cleared_arguments
        )

    viewerCanAssignAssetContacts: "VirtualViewGraphQLField" = VirtualViewGraphQLField(
        "viewerCanAssignAssetContacts"
    )
    viewerHasPinned: "VirtualViewGraphQLField" = VirtualViewGraphQLField(
        "viewerHasPinned"
    )

    def fields(
        self,
        *subfields: Union[
            VirtualViewGraphQLField,
            "AggregationMetadataFields",
            "AnchorEntityLabelFields",
            "AssetContactsFields",
            "AssetFollowersFields",
            "AssetStructureFields",
            "AuditStampFields",
            "BrowsePathFields",
            "DbtModelFields",
            "DerivedAssetDescriptionsFields",
            "EntityConnectionFields",
            "EntityLineageConnectionFields",
            "EntityUpstreamFields",
            "HashtagFields",
            "InterestedPartyFields",
            "KnowledgeCardConnectionFields",
            "LookerExploreFields",
            "LookerViewFields",
            "NamespaceConnectionFields",
            "OverallDataQualityFields",
            "PersonConnectionFields",
            "PipelineInfoFields",
            "PowerBIDatasetFields",
            "RecentUserActivitiesFields",
            "SourceInfoFields",
            "SystemContactsFields",
            "SystemDescriptionFields",
            "SystemTagsFields",
            "TableauDatasourceFields",
            "ThoughtSpotDataObjectFields",
            "UserDefinedResourceConnectionFields",
            "ViewedByConnectionFields",
            "VirtualViewLogicalIdFields",
            "VirtualViewSchemaFields",
        ]
    ) -> "VirtualViewFields":
        """Subfields should come from the VirtualViewFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewFields":
        self._alias = alias
        return self


class VirtualViewConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "VirtualViewEdgeFields":
        return VirtualViewEdgeFields("edges")

    @classmethod
    def pageInfo(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    totalCount: "VirtualViewConnectionGraphQLField" = VirtualViewConnectionGraphQLField(
        "totalCount"
    )

    def fields(
        self,
        *subfields: Union[
            VirtualViewConnectionGraphQLField, "PageInfoFields", "VirtualViewEdgeFields"
        ]
    ) -> "VirtualViewConnectionFields":
        """Subfields should come from the VirtualViewConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewConnectionFields":
        self._alias = alias
        return self


class VirtualViewEdgeFields(GraphQLField):
    cursor: "VirtualViewEdgeGraphQLField" = VirtualViewEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "VirtualViewFields":
        return VirtualViewFields("node")

    def fields(
        self, *subfields: Union[VirtualViewEdgeGraphQLField, "VirtualViewFields"]
    ) -> "VirtualViewEdgeFields":
        """Subfields should come from the VirtualViewEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewEdgeFields":
        self._alias = alias
        return self


class VirtualViewHighlightFields(GraphQLField):
    columnDescriptions: "VirtualViewHighlightGraphQLField" = (
        VirtualViewHighlightGraphQLField("columnDescriptions")
    )
    columnNames: "VirtualViewHighlightGraphQLField" = VirtualViewHighlightGraphQLField(
        "columnNames"
    )
    contactDisplayNames: "VirtualViewHighlightGraphQLField" = (
        VirtualViewHighlightGraphQLField("contactDisplayNames")
    )
    description: "VirtualViewHighlightGraphQLField" = VirtualViewHighlightGraphQLField(
        "description"
    )
    governedTags: "VirtualViewHighlightGraphQLField" = VirtualViewHighlightGraphQLField(
        "governedTags"
    )
    hashtags: "VirtualViewHighlightGraphQLField" = VirtualViewHighlightGraphQLField(
        "hashtags"
    )
    name: "VirtualViewHighlightGraphQLField" = VirtualViewHighlightGraphQLField("name")

    def fields(
        self, *subfields: VirtualViewHighlightGraphQLField
    ) -> "VirtualViewHighlightFields":
        """Subfields should come from the VirtualViewHighlightFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewHighlightFields":
        self._alias = alias
        return self


class VirtualViewLogicalIdFields(GraphQLField):
    name: "VirtualViewLogicalIdGraphQLField" = VirtualViewLogicalIdGraphQLField("name")
    type: "VirtualViewLogicalIdGraphQLField" = VirtualViewLogicalIdGraphQLField("type")

    def fields(
        self, *subfields: VirtualViewLogicalIdGraphQLField
    ) -> "VirtualViewLogicalIdFields":
        """Subfields should come from the VirtualViewLogicalIdFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewLogicalIdFields":
        self._alias = alias
        return self


class VirtualViewSchemaFields(GraphQLField):
    createdAt: "VirtualViewSchemaGraphQLField" = VirtualViewSchemaGraphQLField(
        "createdAt"
    )
    entityId: "VirtualViewSchemaGraphQLField" = VirtualViewSchemaGraphQLField(
        "entityId"
    )

    @classmethod
    def fields(cls) -> "VirtualViewSchemaFieldFields":
        return VirtualViewSchemaFieldFields("fields")

    def fields(
        self,
        *subfields: Union[VirtualViewSchemaGraphQLField, "VirtualViewSchemaFieldFields"]
    ) -> "VirtualViewSchemaFields":
        """Subfields should come from the VirtualViewSchemaFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewSchemaFields":
        self._alias = alias
        return self


class VirtualViewSchemaFieldFields(GraphQLField):
    description: "VirtualViewSchemaFieldGraphQLField" = (
        VirtualViewSchemaFieldGraphQLField("description")
    )
    fieldName: "VirtualViewSchemaFieldGraphQLField" = (
        VirtualViewSchemaFieldGraphQLField("fieldName")
    )
    fieldPath: "VirtualViewSchemaFieldGraphQLField" = (
        VirtualViewSchemaFieldGraphQLField("fieldPath")
    )
    formula: "VirtualViewSchemaFieldGraphQLField" = VirtualViewSchemaFieldGraphQLField(
        "formula"
    )
    optionalType: "VirtualViewSchemaFieldGraphQLField" = (
        VirtualViewSchemaFieldGraphQLField("optionalType")
    )
    type: "VirtualViewSchemaFieldGraphQLField" = VirtualViewSchemaFieldGraphQLField(
        "type"
    )

    def fields(
        self, *subfields: VirtualViewSchemaFieldGraphQLField
    ) -> "VirtualViewSchemaFieldFields":
        """Subfields should come from the VirtualViewSchemaFieldFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewSchemaFieldFields":
        self._alias = alias
        return self


class VirtualViewSearchDocumentFields(GraphQLField):
    browsePathHierarchy: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("browsePathHierarchy")
    )
    browsePathSegments: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("browsePathSegments")
    )

    @classmethod
    def browsePaths(cls) -> "BrowsePathFields":
        return BrowsePathFields("browsePaths")

    columnDescriptions: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("columnDescriptions")
    )
    columnNames: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("columnNames")
    )
    contactDisplayNames: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("contactDisplayNames")
    )
    dbtMaterializationType: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("dbtMaterializationType")
    )
    dbtTags: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("dbtTags")
    )
    description: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("description")
    )
    documentId: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("documentId")
    )
    domainDisplayNames: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("domainDisplayNames")
    )
    domains: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("domains")
    )
    embeddedString_1: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("embeddedString_1")
    )
    embeddedString_2: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("embeddedString_2")
    )
    entityId: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("entityId")
    )
    governedTags: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("governedTags")
    )
    hasColumnLineage: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("hasColumnLineage")
    )
    hasTableLineage: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("hasTableLineage")
    )
    hashtags: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("hashtags")
    )

    @classmethod
    def highlight(cls) -> "VirtualViewHighlightFields":
        return VirtualViewHighlightFields("highlight")

    isComplete: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("isComplete")
    )
    isDeleted: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("isDeleted")
    )
    isProduction: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("isProduction")
    )
    knowledgeCardCount: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("knowledgeCardCount")
    )
    lastRefreshed: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("lastRefreshed")
    )
    lookerTags: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("lookerTags")
    )
    model: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("model")
    )
    name: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("name")
    )
    overallDataQuality: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("overallDataQuality")
    )
    paginationToken: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("paginationToken")
    )
    project: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("project")
    )

    @classmethod
    def scoreDetails(cls) -> "SearchScoreDetailsFields":
        return SearchScoreDetailsFields("scoreDetails")

    tableauTags: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("tableauTags")
    )
    thoughtSpotDataObjectType: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("thoughtSpotDataObjectType")
    )
    thoughtSpotTags: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("thoughtSpotTags")
    )
    type: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("type")
    )
    viewCount: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("viewCount")
    )
    workspace: "VirtualViewSearchDocumentGraphQLField" = (
        VirtualViewSearchDocumentGraphQLField("workspace")
    )

    def fields(
        self,
        *subfields: Union[
            VirtualViewSearchDocumentGraphQLField,
            "BrowsePathFields",
            "SearchScoreDetailsFields",
            "VirtualViewHighlightFields",
        ]
    ) -> "VirtualViewSearchDocumentFields":
        """Subfields should come from the VirtualViewSearchDocumentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewSearchDocumentFields":
        self._alias = alias
        return self


class VirtualViewSearchInfoFields(GraphQLField):
    type: "VirtualViewSearchInfoGraphQLField" = VirtualViewSearchInfoGraphQLField(
        "type"
    )

    def fields(
        self, *subfields: VirtualViewSearchInfoGraphQLField
    ) -> "VirtualViewSearchInfoFields":
        """Subfields should come from the VirtualViewSearchInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewSearchInfoFields":
        self._alias = alias
        return self


class VirtualViewSearchResultFields(GraphQLField):
    @classmethod
    def documents(cls) -> "VirtualViewSearchDocumentFields":
        return VirtualViewSearchDocumentFields("documents")

    errorMessage: "VirtualViewSearchResultGraphQLField" = (
        VirtualViewSearchResultGraphQLField("errorMessage")
    )
    from_: "VirtualViewSearchResultGraphQLField" = VirtualViewSearchResultGraphQLField(
        "from"
    )
    hasMore: "VirtualViewSearchResultGraphQLField" = (
        VirtualViewSearchResultGraphQLField("hasMore")
    )

    @classmethod
    def metadata(cls) -> "AggregationMetadataFields":
        return AggregationMetadataFields("metadata")

    @classmethod
    def nodes(cls) -> "NodeInterface":
        return NodeInterface("nodes")

    paginationToken: "VirtualViewSearchResultGraphQLField" = (
        VirtualViewSearchResultGraphQLField("paginationToken")
    )
    searchContext: "VirtualViewSearchResultGraphQLField" = (
        VirtualViewSearchResultGraphQLField("searchContext")
    )
    searchIndex: "VirtualViewSearchResultGraphQLField" = (
        VirtualViewSearchResultGraphQLField("searchIndex")
    )
    size: "VirtualViewSearchResultGraphQLField" = VirtualViewSearchResultGraphQLField(
        "size"
    )
    totalCount: "VirtualViewSearchResultGraphQLField" = (
        VirtualViewSearchResultGraphQLField("totalCount")
    )

    def fields(
        self,
        *subfields: Union[
            VirtualViewSearchResultGraphQLField,
            "AggregationMetadataFields",
            "NodeInterface",
            "VirtualViewSearchDocumentFields",
        ]
    ) -> "VirtualViewSearchResultFields":
        """Subfields should come from the VirtualViewSearchResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VirtualViewSearchResultFields":
        self._alias = alias
        return self


class VolumeFileFields(GraphQLField):
    entityId: "VolumeFileGraphQLField" = VolumeFileGraphQLField("entityId")
    modification_time: "VolumeFileGraphQLField" = VolumeFileGraphQLField(
        "modification_time"
    )
    name: "VolumeFileGraphQLField" = VolumeFileGraphQLField("name")
    path: "VolumeFileGraphQLField" = VolumeFileGraphQLField("path")
    size: "VolumeFileGraphQLField" = VolumeFileGraphQLField("size")

    def fields(self, *subfields: VolumeFileGraphQLField) -> "VolumeFileFields":
        """Subfields should come from the VolumeFileFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "VolumeFileFields":
        self._alias = alias
        return self


class WebhookFields(GraphQLField):
    _id: "WebhookGraphQLField" = WebhookGraphQLField("_id")
    createdAt: "WebhookGraphQLField" = WebhookGraphQLField("createdAt")
    description: "WebhookGraphQLField" = WebhookGraphQLField("description")
    trigger: "WebhookGraphQLField" = WebhookGraphQLField("trigger")
    url: "WebhookGraphQLField" = WebhookGraphQLField("url")

    def fields(self, *subfields: WebhookGraphQLField) -> "WebhookFields":
        """Subfields should come from the WebhookFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "WebhookFields":
        self._alias = alias
        return self
