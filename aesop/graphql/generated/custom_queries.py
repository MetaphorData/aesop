# Generated by ariadne-codegen

from typing import Any, Dict, Optional

from . import (
    AggregationMetadataName,
    NamespaceType,
    SearchIndex,
    UserDefinedOrderType,
    UserDefinedResourceType,
    WebhookTriggerType,
)
from .custom_fields import (
    ActivityFeedConnectionFields,
    ApiKeyFields,
    AthenaQueryResultFields,
    AutoGeneratedDocumentFields,
    BrowsePathFields,
    CrawlerFields,
    CrawlerTypeResponseFields,
    DashboardConnectionFields,
    DashboardFields,
    DatasetConnectionFields,
    DatasetFields,
    GeneratedAssetDescriptionFields,
    GroupConnectionFields,
    HierarchyConnectionFields,
    HierarchyFields,
    IntegrationsFields,
    KnowledgeCardConnectionFields,
    KnowledgeCardFields,
    MetricConnectionFields,
    MetricFields,
    NamespaceConnectionFields,
    NodeInterface,
    PersonConnectionFields,
    PersonFields,
    QueryInfoFields,
    QueryResultFields,
    SampleSearchQuestionFields,
    SchemaFieldFields,
    SearchStatisticsResultFields,
    SettingsFields,
    SimilarAssetsResultItemFields,
    SQLExplainerResultFields,
    SuggestResultFields,
    SystemTagCountsConnectionFields,
    SystemTagSourcesFields,
    TenantInfoFields,
    UniversalSearchResultFields,
    UserDefinedResourceConnectionFields,
    UserSpecifiedOrderingFields,
    VersionHistoryConnectionFields,
    VersionHistoryFields,
    ViewerPermissionsFields,
    VirtualViewConnectionFields,
    VirtualViewFields,
    WebhookFields,
)
from .custom_typing_fields import GraphQLField, SearchResultUnion
from .input_types import (
    ActivityFeedConnectionFilterInput,
    AthenaQueryRequest,
    AutoGeneratedDocumentInput,
    BaseConnectionFilter,
    ConnectionOrderBy,
    CrawlerFilter,
    DashboardConnectionFilterInput,
    DashboardIdInput,
    DatasetColumnsPatternInput,
    DatasetIdInput,
    GeneratedAssetDescriptionInput,
    GroupConnectionFilterInput,
    HierarchyConnectionFilterInput,
    HierarchyLogicalIdInput,
    KnowledgeCardConnectionFilterInput,
    KnowledgeCardIdInput,
    MetricConnectionFilterInput,
    MetricLogicalIdInput,
    NamespaceInfoConnectionFilterInput,
    PersonConnectionFilterInput,
    PersonLogicalIdInput,
    PowerQueryExplainerInput,
    QueryRequest,
    ResourceInfoConnectionFilterInput,
    SearchFacets,
    SearchQueryFilters,
    SearchResultFieldsSelection,
    SearchResultSort,
    SQLExplainerInput,
    SystemTagsConnectionFilterInput,
    UniversalSearchInput,
    VersionHistoryConnectionFilterInput,
    VirtualViewLogicalIdInput,
)


class Query:
    @classmethod
    def sql_explainer_query(
        cls, request: SQLExplainerInput
    ) -> SQLExplainerResultFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "request": {"type": "SQLExplainerInput!", "value": request}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SQLExplainerResultFields(
            field_name="SQLExplainerQuery", arguments=cleared_arguments
        )

    @classmethod
    def activity_feed(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[ActivityFeedConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> ActivityFeedConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "ActivityFeedConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ActivityFeedConnectionFields(
            field_name="activityFeed", arguments=cleared_arguments
        )

    @classmethod
    def api_keys(cls) -> ApiKeyFields:
        return ApiKeyFields(field_name="apiKeys")

    @classmethod
    def auto_describe(
        cls, input: GeneratedAssetDescriptionInput
    ) -> GeneratedAssetDescriptionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "GeneratedAssetDescriptionInput!", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return GeneratedAssetDescriptionFields(
            field_name="autoDescribe", arguments=cleared_arguments
        )

    @classmethod
    def auto_document(
        cls, input: AutoGeneratedDocumentInput
    ) -> AutoGeneratedDocumentFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "AutoGeneratedDocumentInput!", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return AutoGeneratedDocumentFields(
            field_name="autoDocument", arguments=cleared_arguments
        )

    @classmethod
    def browse(
        cls,
        index: SearchIndex,
        input: str,
        *,
        from_: Optional[int] = None,
        size: Optional[int] = None
    ) -> SearchResultUnion:
        arguments: Dict[str, Dict[str, Any]] = {
            "from": {"type": "Int", "value": from_},
            "index": {"type": "SearchIndex!", "value": index},
            "input": {"type": "String!", "value": input},
            "size": {"type": "Int", "value": size},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SearchResultUnion(field_name="browse", arguments=cleared_arguments)

    @classmethod
    def browse_paths(cls) -> BrowsePathFields:
        return BrowsePathFields(field_name="browsePaths")

    @classmethod
    def common_column_attributes_assigned_contacts(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[PersonConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> PersonConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "PersonConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(
            field_name="commonColumnAttributesAssignedContacts",
            arguments=cleared_arguments,
        )

    @classmethod
    def common_column_attributes_assigned_governed_tags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> UserDefinedResourceConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            field_name="commonColumnAttributesAssignedGovernedTags",
            arguments=cleared_arguments,
        )

    @classmethod
    def common_column_attributes_creators(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[PersonConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> PersonConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "PersonConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(
            field_name="commonColumnAttributesCreators", arguments=cleared_arguments
        )

    @classmethod
    def common_column_attributes_updaters(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[PersonConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> PersonConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "PersonConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(
            field_name="commonColumnAttributesUpdaters", arguments=cleared_arguments
        )

    @classmethod
    def crawler_ip_addresses(cls) -> GraphQLField:
        return GraphQLField(field_name="crawlerIpAddresses")

    @classmethod
    def crawler_types(cls) -> CrawlerTypeResponseFields:
        return CrawlerTypeResponseFields(field_name="crawlerTypes")

    @classmethod
    def crawlers(cls, *, filter: Optional[CrawlerFilter] = None) -> CrawlerFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "filter": {"type": "CrawlerFilter", "value": filter}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return CrawlerFields(field_name="crawlers", arguments=cleared_arguments)

    @classmethod
    def custom_ordering_settings(cls) -> UserSpecifiedOrderingFields:
        return UserSpecifiedOrderingFields(field_name="customOrderingSettings")

    @classmethod
    def dashboard(cls, logical_id: DashboardIdInput) -> DashboardFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "logicalId": {"type": "DashboardIdInput!", "value": logical_id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DashboardFields(field_name="dashboard", arguments=cleared_arguments)

    @classmethod
    def dashboards(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[DashboardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> DashboardConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "DashboardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DashboardConnectionFields(
            field_name="dashboards", arguments=cleared_arguments
        )

    @classmethod
    def dataset(cls, logical_id: DatasetIdInput) -> DatasetFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "logicalId": {"type": "DatasetIdInput!", "value": logical_id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DatasetFields(field_name="dataset", arguments=cleared_arguments)

    @classmethod
    def datasets(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> DatasetConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DatasetConnectionFields(
            field_name="datasets", arguments=cleared_arguments
        )

    @classmethod
    def entity_types(cls) -> GraphQLField:
        return GraphQLField(field_name="entityTypes")

    @classmethod
    def existing_hashtags(cls) -> GraphQLField:
        return GraphQLField(field_name="existingHashtags")

    @classmethod
    def find_columns_matching_pattern(
        cls, pattern: DatasetColumnsPatternInput
    ) -> GraphQLField:
        arguments: Dict[str, Dict[str, Any]] = {
            "pattern": {"type": "DatasetColumnsPatternInput!", "value": pattern}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return GraphQLField(
            field_name="findColumnsMatchingPattern", arguments=cleared_arguments
        )

    @classmethod
    def get_query_info(cls, id: str) -> QueryInfoFields:
        arguments: Dict[str, Dict[str, Any]] = {"id": {"type": "String!", "value": id}}
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return QueryInfoFields(field_name="getQueryInfo", arguments=cleared_arguments)

    @classmethod
    def get_relevant_doc_ids(cls, query: str) -> GraphQLField:
        arguments: Dict[str, Dict[str, Any]] = {
            "query": {"type": "String!", "value": query}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return GraphQLField(field_name="getRelevantDocIds", arguments=cleared_arguments)

    @classmethod
    def get_sample_search_questions(
        cls,
        max_count: float,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> SampleSearchQuestionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "maxCount": {"type": "Float!", "value": max_count},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SampleSearchQuestionFields(
            field_name="getSampleSearchQuestions", arguments=cleared_arguments
        )

    @classmethod
    def group_creators(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[PersonConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> PersonConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "PersonConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(
            field_name="groupCreators", arguments=cleared_arguments
        )

    @classmethod
    def groups(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[GroupConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> GroupConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "GroupConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return GroupConnectionFields(field_name="groups", arguments=cleared_arguments)

    @classmethod
    def hierarchies(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[HierarchyConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> HierarchyConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "HierarchyConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return HierarchyConnectionFields(
            field_name="hierarchies", arguments=cleared_arguments
        )

    @classmethod
    def hierarchy(cls, logical_id: HierarchyLogicalIdInput) -> HierarchyFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "logicalId": {"type": "HierarchyLogicalIdInput!", "value": logical_id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return HierarchyFields(field_name="hierarchy", arguments=cleared_arguments)

    @classmethod
    def integrations(cls) -> IntegrationsFields:
        return IntegrationsFields(field_name="integrations")

    @classmethod
    def is_viewer_crm_contact(cls) -> GraphQLField:
        return GraphQLField(field_name="isViewerCRMContact")

    @classmethod
    def knowledge_card(cls, logical_id: KnowledgeCardIdInput) -> KnowledgeCardFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "logicalId": {"type": "KnowledgeCardIdInput!", "value": logical_id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardFields(
            field_name="knowledgeCard", arguments=cleared_arguments
        )

    @classmethod
    def knowledge_cards(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> KnowledgeCardConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            field_name="knowledgeCards", arguments=cleared_arguments
        )

    @classmethod
    def metric(cls, logical_id: MetricLogicalIdInput) -> MetricFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "logicalId": {"type": "MetricLogicalIdInput!", "value": logical_id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MetricFields(field_name="metric", arguments=cleared_arguments)

    @classmethod
    def metrics(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[MetricConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> MetricConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "MetricConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MetricConnectionFields(field_name="metrics", arguments=cleared_arguments)

    @classmethod
    def namespace_with_name_exists(
        cls, name: str, type: NamespaceType, *, parent: Optional[str] = None
    ) -> GraphQLField:
        arguments: Dict[str, Dict[str, Any]] = {
            "name": {"type": "String!", "value": name},
            "parent": {"type": "ID", "value": parent},
            "type": {"type": "NamespaceType!", "value": type},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return GraphQLField(
            field_name="namespaceWithNameExists", arguments=cleared_arguments
        )

    @classmethod
    def namespaces(
        cls,
        filters: NamespaceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None,
        order_by_user_defined_order: Optional[UserDefinedOrderType] = None
    ) -> NamespaceConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {
                "type": "NamespaceInfoConnectionFilterInput!",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "orderByUserDefinedOrder": {
                "type": "UserDefinedOrderType",
                "value": order_by_user_defined_order,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NamespaceConnectionFields(
            field_name="namespaces", arguments=cleared_arguments
        )

    @classmethod
    def node(cls, id: str) -> NodeInterface:
        arguments: Dict[str, Dict[str, Any]] = {"id": {"type": "ID!", "value": id}}
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NodeInterface(field_name="node", arguments=cleared_arguments)

    @classmethod
    def nodes(cls, id: str) -> NodeInterface:
        arguments: Dict[str, Dict[str, Any]] = {"id": {"type": "ID!", "value": id}}
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NodeInterface(field_name="nodes", arguments=cleared_arguments)

    @classmethod
    def people(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[PersonConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> PersonConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "PersonConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(field_name="people", arguments=cleared_arguments)

    @classmethod
    def person(cls, logical_id: PersonLogicalIdInput) -> PersonFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "logicalId": {"type": "PersonLogicalIdInput!", "value": logical_id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonFields(field_name="person", arguments=cleared_arguments)

    @classmethod
    def platforms_list(cls) -> GraphQLField:
        return GraphQLField(field_name="platformsList")

    @classmethod
    def power_query_explainer_query(
        cls, request: PowerQueryExplainerInput
    ) -> SQLExplainerResultFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "request": {"type": "PowerQueryExplainerInput!", "value": request}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SQLExplainerResultFields(
            field_name="powerQueryExplainerQuery", arguments=cleared_arguments
        )

    @classmethod
    def resource_with_name_exists(
        cls, name: str, type: UserDefinedResourceType, *, parent: Optional[str] = None
    ) -> GraphQLField:
        arguments: Dict[str, Dict[str, Any]] = {
            "name": {"type": "String!", "value": name},
            "parent": {"type": "ID", "value": parent},
            "type": {"type": "UserDefinedResourceType!", "value": type},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return GraphQLField(
            field_name="resourceWithNameExists", arguments=cleared_arguments
        )

    @classmethod
    def run_athena_query(cls, request: AthenaQueryRequest) -> AthenaQueryResultFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "request": {"type": "AthenaQueryRequest!", "value": request}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return AthenaQueryResultFields(
            field_name="runAthenaQuery", arguments=cleared_arguments
        )

    @classmethod
    def run_query(cls, request: QueryRequest) -> QueryResultFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "request": {"type": "QueryRequest!", "value": request}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return QueryResultFields(field_name="runQuery", arguments=cleared_arguments)

    @classmethod
    def search(
        cls,
        input: str,
        *,
        aggregations: Optional[AggregationMetadataName] = None,
        facets: Optional[SearchFacets] = None,
        fields_selection: Optional[SearchResultFieldsSelection] = None,
        filters: Optional[SearchQueryFilters] = None,
        from_: Optional[int] = None,
        indices: Optional[SearchIndex] = None,
        meta_only: Optional[bool] = None,
        related_assets: Optional[str] = None,
        score_details: Optional[bool] = None,
        search_after: Optional[str] = None,
        size: Optional[int] = None,
        sort: Optional[SearchResultSort] = None
    ) -> SearchResultUnion:
        arguments: Dict[str, Dict[str, Any]] = {
            "aggregations": {"type": "AggregationMetadataName", "value": aggregations},
            "facets": {"type": "SearchFacets", "value": facets},
            "fieldsSelection": {
                "type": "SearchResultFieldsSelection",
                "value": fields_selection,
            },
            "filters": {"type": "SearchQueryFilters", "value": filters},
            "from": {"type": "Int", "value": from_},
            "indices": {"type": "SearchIndex", "value": indices},
            "input": {"type": "String!", "value": input},
            "metaOnly": {"type": "Boolean", "value": meta_only},
            "relatedAssets": {"type": "ID", "value": related_assets},
            "scoreDetails": {"type": "Boolean", "value": score_details},
            "searchAfter": {"type": "String", "value": search_after},
            "size": {"type": "Int", "value": size},
            "sort": {"type": "SearchResultSort", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SearchResultUnion(field_name="search", arguments=cleared_arguments)

    @classmethod
    def search_statistics(
        cls,
        input: str,
        *,
        aggregations: Optional[AggregationMetadataName] = None,
        facets: Optional[SearchFacets] = None,
        fields_selection: Optional[SearchResultFieldsSelection] = None,
        filters: Optional[SearchQueryFilters] = None,
        from_: Optional[int] = None,
        indices: Optional[SearchIndex] = None,
        meta_only: Optional[bool] = None,
        related_assets: Optional[str] = None,
        score_details: Optional[bool] = None,
        search_after: Optional[str] = None,
        size: Optional[int] = None,
        sort: Optional[SearchResultSort] = None
    ) -> SearchStatisticsResultFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "aggregations": {"type": "AggregationMetadataName", "value": aggregations},
            "facets": {"type": "SearchFacets", "value": facets},
            "fieldsSelection": {
                "type": "SearchResultFieldsSelection",
                "value": fields_selection,
            },
            "filters": {"type": "SearchQueryFilters", "value": filters},
            "from": {"type": "Int", "value": from_},
            "indices": {"type": "SearchIndex", "value": indices},
            "input": {"type": "String!", "value": input},
            "metaOnly": {"type": "Boolean", "value": meta_only},
            "relatedAssets": {"type": "ID", "value": related_assets},
            "scoreDetails": {"type": "Boolean", "value": score_details},
            "searchAfter": {"type": "String", "value": search_after},
            "size": {"type": "Int", "value": size},
            "sort": {"type": "SearchResultSort", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SearchStatisticsResultFields(
            field_name="searchStatistics", arguments=cleared_arguments
        )

    @classmethod
    def settings(cls) -> SettingsFields:
        return SettingsFields(field_name="settings")

    @classmethod
    def similar_assets(
        cls, entity_id: str, *, max_neighbors: Optional[int] = None
    ) -> SimilarAssetsResultItemFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "entityId": {"type": "ID!", "value": entity_id},
            "maxNeighbors": {"type": "Int", "value": max_neighbors},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SimilarAssetsResultItemFields(
            field_name="similarAssets", arguments=cleared_arguments
        )

    @classmethod
    def subfields(cls, dataset_id: str, field_path: str) -> SchemaFieldFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "datasetId": {"type": "String!", "value": dataset_id},
            "fieldPath": {"type": "String!", "value": field_path},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SchemaFieldFields(field_name="subfields", arguments=cleared_arguments)

    @classmethod
    def suggest(
        cls,
        input: str,
        *,
        aggregations: Optional[AggregationMetadataName] = None,
        facets: Optional[SearchFacets] = None,
        fields_selection: Optional[SearchResultFieldsSelection] = None,
        filters: Optional[SearchQueryFilters] = None,
        from_: Optional[int] = None,
        indices: Optional[SearchIndex] = None,
        meta_only: Optional[bool] = None,
        related_assets: Optional[str] = None,
        score_details: Optional[bool] = None,
        search_after: Optional[str] = None,
        size: Optional[int] = None,
        sort: Optional[SearchResultSort] = None
    ) -> SuggestResultFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "aggregations": {"type": "AggregationMetadataName", "value": aggregations},
            "facets": {"type": "SearchFacets", "value": facets},
            "fieldsSelection": {
                "type": "SearchResultFieldsSelection",
                "value": fields_selection,
            },
            "filters": {"type": "SearchQueryFilters", "value": filters},
            "from": {"type": "Int", "value": from_},
            "indices": {"type": "SearchIndex", "value": indices},
            "input": {"type": "String!", "value": input},
            "metaOnly": {"type": "Boolean", "value": meta_only},
            "relatedAssets": {"type": "ID", "value": related_assets},
            "scoreDetails": {"type": "Boolean", "value": score_details},
            "searchAfter": {"type": "String", "value": search_after},
            "size": {"type": "Int", "value": size},
            "sort": {"type": "SearchResultSort", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SuggestResultFields(field_name="suggest", arguments=cleared_arguments)

    @classmethod
    def supported_platforms_list(cls) -> GraphQLField:
        return GraphQLField(field_name="supportedPlatformsList")

    @classmethod
    def system_tag_counts(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[SystemTagsConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> SystemTagCountsConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "SystemTagsConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SystemTagCountsConnectionFields(
            field_name="systemTagCounts", arguments=cleared_arguments
        )

    @classmethod
    def system_tag_sources(cls) -> SystemTagSourcesFields:
        return SystemTagSourcesFields(field_name="systemTagSources")

    @classmethod
    def tenant(cls, name: str) -> TenantInfoFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "name": {"type": "String!", "value": name}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TenantInfoFields(field_name="tenant", arguments=cleared_arguments)

    @classmethod
    def top_contributors(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> PersonConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PersonConnectionFields(
            field_name="topContributors", arguments=cleared_arguments
        )

    @classmethod
    def trending_documents(
        cls,
        *,
        after: Optional[str] = None,
        anchor_id: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[KnowledgeCardConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> KnowledgeCardConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "anchorId": {"type": "ID", "value": anchor_id},
            "before": {"type": "String", "value": before},
            "filters": {"type": "KnowledgeCardConnectionFilterInput", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return KnowledgeCardConnectionFields(
            field_name="trendingDocuments", arguments=cleared_arguments
        )

    @classmethod
    def trending_governed_tags(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> UserDefinedResourceConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            field_name="trendingGovernedTags", arguments=cleared_arguments
        )

    @classmethod
    def trending_hashtags(cls, size: int) -> GraphQLField:
        arguments: Dict[str, Dict[str, Any]] = {"size": {"type": "Int!", "value": size}}
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return GraphQLField(field_name="trendingHashtags", arguments=cleared_arguments)

    @classmethod
    def universal_search_query(
        cls,
        request: UniversalSearchInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> UniversalSearchResultFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
            "request": {"type": "UniversalSearchInput!", "value": request},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UniversalSearchResultFields(
            field_name="universalSearchQuery", arguments=cleared_arguments
        )

    @classmethod
    def user_defined_resources(
        cls,
        filters: ResourceInfoConnectionFilterInput,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> UserDefinedResourceConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "ResourceInfoConnectionFilterInput!", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserDefinedResourceConnectionFields(
            field_name="userDefinedResources", arguments=cleared_arguments
        )

    @classmethod
    def version(cls, *, version_id: Optional[str] = None) -> VersionHistoryFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "versionId": {"type": "ID", "value": version_id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return VersionHistoryFields(field_name="version", arguments=cleared_arguments)

    @classmethod
    def versions(
        cls,
        entity_id: str,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[VersionHistoryConnectionFilterInput] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> VersionHistoryConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "entityId": {"type": "ID!", "value": entity_id},
            "filters": {
                "type": "VersionHistoryConnectionFilterInput",
                "value": filters,
            },
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return VersionHistoryConnectionFields(
            field_name="versions", arguments=cleared_arguments
        )

    @classmethod
    def viewer(cls) -> PersonFields:
        return PersonFields(field_name="viewer")

    @classmethod
    def viewer_can_assign_user_defined_resource(
        cls, type: UserDefinedResourceType
    ) -> GraphQLField:
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "UserDefinedResourceType!", "value": type}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return GraphQLField(
            field_name="viewerCanAssignUserDefinedResource", arguments=cleared_arguments
        )

    @classmethod
    def viewer_permissions(cls) -> ViewerPermissionsFields:
        return ViewerPermissionsFields(field_name="viewerPermissions")

    @classmethod
    def virtual_view(cls, logical_id: VirtualViewLogicalIdInput) -> VirtualViewFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "logicalId": {"type": "VirtualViewLogicalIdInput!", "value": logical_id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return VirtualViewFields(field_name="virtualView", arguments=cleared_arguments)

    @classmethod
    def virtual_views(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        filters: Optional[BaseConnectionFilter] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[ConnectionOrderBy] = None
    ) -> VirtualViewConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "filters": {"type": "BaseConnectionFilter", "value": filters},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "ConnectionOrderBy", "value": order_by},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return VirtualViewConnectionFields(
            field_name="virtualViews", arguments=cleared_arguments
        )

    @classmethod
    def webhooks(cls, *, trigger: Optional[WebhookTriggerType] = None) -> WebhookFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "trigger": {"type": "WebhookTriggerType", "value": trigger}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return WebhookFields(field_name="webhooks", arguments=cleared_arguments)
